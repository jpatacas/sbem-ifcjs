var NavigationModes;
(function (NavigationModes) {
    NavigationModes[NavigationModes["Orbit"] = 0] = "Orbit";
    NavigationModes[NavigationModes["FirstPerson"] = 1] = "FirstPerson";
    NavigationModes[NavigationModes["Plan"] = 2] = "Plan";
})(NavigationModes || (NavigationModes = {}));
var CameraProjections;
(function (CameraProjections) {
    CameraProjections[CameraProjections["Perspective"] = 0] = "Perspective";
    CameraProjections[CameraProjections["Orthographic"] = 1] = "Orthographic";
})(CameraProjections || (CameraProjections = {}));
class IfcComponent {
    constructor(context) {
        context.addComponent(this);
    }
    update(_delta) { }
}
var dimension;
(function (dimension) {
    dimension["x"] = "x";
    dimension["y"] = "y";
    dimension["z"] = "z";
})(dimension || (dimension = {}));

/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '143';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const NormalBlending = 1;
const AddEquation = 100;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const LessEqualDepth = 3;
const MultiplyOperation = 0;

const UVMapping = 300;
const RepeatWrapping = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const UnsignedByteType = 1009;
const FloatType = 1015;
const RGBAFormat = 1023;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const TangentSpaceNormalMap = 0;
const SRGBColorSpace = 'srgb';
const LinearSRGBColorSpace = 'srgb-linear';
const KeepStencilOp = 7680;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

class EventDispatcher {

	addEventListener( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	}

	hasEventListener( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	}

	removeEventListener( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	}

	dispatchEvent( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

			event.target = null;

		}

	}

}

const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

let _seed = 1234567;


const DEG2RAD = Math.PI / 180;
const RAD2DEG = 180 / Math.PI;

// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
function generateUUID() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}

function clamp( value, min, max ) {

	return Math.max( min, Math.min( max, value ) );

}

// compute euclidean modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
function euclideanModulo( n, m ) {

	return ( ( n % m ) + m ) % m;

}

// Linear mapping from range <a1, a2> to range <b1, b2>
function mapLinear( x, a1, a2, b1, b2 ) {

	return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

}

// https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
function inverseLerp( x, y, value ) {

	if ( x !== y ) {

		return ( value - x ) / ( y - x );

	} else {

		return 0;

	}

}

// https://en.wikipedia.org/wiki/Linear_interpolation
function lerp( x, y, t ) {

	return ( 1 - t ) * x + t * y;

}

// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
function damp( x, y, lambda, dt ) {

	return lerp( x, y, 1 - Math.exp( - lambda * dt ) );

}

// https://www.desmos.com/calculator/vcsjnyz7x4
function pingpong( x, length = 1 ) {

	return length - Math.abs( euclideanModulo( x, length * 2 ) - length );

}

// http://en.wikipedia.org/wiki/Smoothstep
function smoothstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * ( 3 - 2 * x );

}

function smootherstep( x, min, max ) {

	if ( x <= min ) return 0;
	if ( x >= max ) return 1;

	x = ( x - min ) / ( max - min );

	return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

}

// Random integer from <low, high> interval
function randInt( low, high ) {

	return low + Math.floor( Math.random() * ( high - low + 1 ) );

}

// Random float from <low, high> interval
function randFloat( low, high ) {

	return low + Math.random() * ( high - low );

}

// Random float from <-range/2, range/2> interval
function randFloatSpread( range ) {

	return range * ( 0.5 - Math.random() );

}

// Deterministic pseudo-random float in the interval [ 0, 1 ]
function seededRandom( s ) {

	if ( s !== undefined ) _seed = s;

	// Mulberry32 generator

	let t = _seed += 0x6D2B79F5;

	t = Math.imul( t ^ t >>> 15, t | 1 );

	t ^= t + Math.imul( t ^ t >>> 7, t | 61 );

	return ( ( t ^ t >>> 14 ) >>> 0 ) / 4294967296;

}

function degToRad( degrees ) {

	return degrees * DEG2RAD;

}

function radToDeg( radians ) {

	return radians * RAD2DEG;

}

function isPowerOfTwo( value ) {

	return ( value & ( value - 1 ) ) === 0 && value !== 0;

}

function ceilPowerOfTwo( value ) {

	return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

}

function floorPowerOfTwo( value ) {

	return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

}

function setQuaternionFromProperEuler( q, a, b, c, order ) {

	// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

	// rotations are applied to the axes in the order specified by 'order'
	// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
	// angles are in radians

	const cos = Math.cos;
	const sin = Math.sin;

	const c2 = cos( b / 2 );
	const s2 = sin( b / 2 );

	const c13 = cos( ( a + c ) / 2 );
	const s13 = sin( ( a + c ) / 2 );

	const c1_3 = cos( ( a - c ) / 2 );
	const s1_3 = sin( ( a - c ) / 2 );

	const c3_1 = cos( ( c - a ) / 2 );
	const s3_1 = sin( ( c - a ) / 2 );

	switch ( order ) {

		case 'XYX':
			q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
			break;

		case 'YZY':
			q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
			break;

		case 'ZXZ':
			q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
			break;

		case 'XZX':
			q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
			break;

		case 'YXY':
			q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
			break;

		case 'ZYZ':
			q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
			break;

		default:
			console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

	}

}

function denormalize$1( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return value / 65535.0;

		case Uint8Array:

			return value / 255.0;

		case Int16Array:

			return Math.max( value / 32767.0, - 1.0 );

		case Int8Array:

			return Math.max( value / 127.0, - 1.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

function normalize( value, array ) {

	switch ( array.constructor ) {

		case Float32Array:

			return value;

		case Uint16Array:

			return Math.round( value * 65535.0 );

		case Uint8Array:

			return Math.round( value * 255.0 );

		case Int16Array:

			return Math.round( value * 32767.0 );

		case Int8Array:

			return Math.round( value * 127.0 );

		default:

			throw new Error( 'Invalid component type.' );

	}

}

var MathUtils = /*#__PURE__*/Object.freeze({
	__proto__: null,
	DEG2RAD: DEG2RAD,
	RAD2DEG: RAD2DEG,
	generateUUID: generateUUID,
	clamp: clamp,
	euclideanModulo: euclideanModulo,
	mapLinear: mapLinear,
	inverseLerp: inverseLerp,
	lerp: lerp,
	damp: damp,
	pingpong: pingpong,
	smoothstep: smoothstep,
	smootherstep: smootherstep,
	randInt: randInt,
	randFloat: randFloat,
	randFloatSpread: randFloatSpread,
	seededRandom: seededRandom,
	degToRad: degToRad,
	radToDeg: radToDeg,
	isPowerOfTwo: isPowerOfTwo,
	ceilPowerOfTwo: ceilPowerOfTwo,
	floorPowerOfTwo: floorPowerOfTwo,
	setQuaternionFromProperEuler: setQuaternionFromProperEuler,
	normalize: normalize,
	denormalize: denormalize$1
});

class Vector2 {

	constructor( x = 0, y = 0 ) {

		Vector2.prototype.isVector2 = true;

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;

	}

}

class Matrix3 {

	constructor() {

		Matrix3.prototype.isMatrix3 = true;

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

function arrayNeedsUint32( array ) {

	// assumes larger values usually on last

	for ( let i = array.length - 1; i >= 0; -- i ) {

		if ( array[ i ] > 65535 ) return true;

	}

	return false;

}

function createElementNS( name ) {

	return document.createElementNS( 'http://www.w3.org/1999/xhtml', name );

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

// JavaScript RGB-to-RGB transforms, defined as
// FN[InputColorSpace][OutputColorSpace] callback functions.
const FN = {
	[ SRGBColorSpace ]: { [ LinearSRGBColorSpace ]: SRGBToLinear },
	[ LinearSRGBColorSpace ]: { [ SRGBColorSpace ]: LinearToSRGB },
};

const ColorManagement = {

	legacyMode: true,

	get workingColorSpace() {

		return LinearSRGBColorSpace;

	},

	set workingColorSpace( colorSpace ) {

		console.warn( 'THREE.ColorManagement: .workingColorSpace is readonly.' );

	},

	convert: function ( color, sourceColorSpace, targetColorSpace ) {

		if ( this.legacyMode || sourceColorSpace === targetColorSpace || ! sourceColorSpace || ! targetColorSpace ) {

			return color;

		}

		if ( FN[ sourceColorSpace ] && FN[ sourceColorSpace ][ targetColorSpace ] !== undefined ) {

			const fn = FN[ sourceColorSpace ][ targetColorSpace ];

			color.r = fn( color.r );
			color.g = fn( color.g );
			color.b = fn( color.b );

			return color;

		}

		throw new Error( 'Unsupported color space conversion.' );

	},

	fromWorkingColorSpace: function ( color, targetColorSpace ) {

		return this.convert( color, this.workingColorSpace, targetColorSpace );

	},

	toWorkingColorSpace: function ( color, sourceColorSpace ) {

		return this.convert( color, sourceColorSpace, this.workingColorSpace );

	},

};

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _rgb = { r: 0, g: 0, b: 0 };
const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function toComponents( source, target ) {

	target.r = source.r;
	target.g = source.g;
	target.b = source.b;

	return target;

}

class Color {

	constructor( r, g, b ) {

		this.isColor = true;

		this.r = 1;
		this.g = 1;
		this.b = 1;

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex, colorSpace = SRGBColorSpace ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setRGB( r, g, b, colorSpace = LinearSRGBColorSpace ) {

		this.r = r;
		this.g = g;
		this.b = b;

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setHSL( h, s, l, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = euclideanModulo( h, 1 );
		s = clamp( s, 0, 1 );
		l = clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		ColorManagement.toWorkingColorSpace( this, colorSpace );

		return this;

	}

	setStyle( style, colorSpace = SRGBColorSpace ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						ColorManagement.toWorkingColorSpace( this, colorSpace );

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l, colorSpace );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				ColorManagement.toWorkingColorSpace( this, colorSpace );

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style, colorSpace );

		}

		return this;

	}

	setColorName( style, colorSpace = SRGBColorSpace ) {

		// color keywords
		const hex = _colorKeywords[ style.toLowerCase() ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex, colorSpace );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		return clamp( _rgb.r * 255, 0, 255 ) << 16 ^ clamp( _rgb.g * 255, 0, 255 ) << 8 ^ clamp( _rgb.b * 255, 0, 255 ) << 0;

	}

	getHexString( colorSpace = SRGBColorSpace ) {

		return ( '000000' + this.getHex( colorSpace ).toString( 16 ) ).slice( - 6 );

	}

	getHSL( target, colorSpace = LinearSRGBColorSpace ) {

		// h,s,l ranges are in 0.0 - 1.0

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		const r = _rgb.r, g = _rgb.g, b = _rgb.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getRGB( target, colorSpace = LinearSRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		target.r = _rgb.r;
		target.g = _rgb.g;
		target.b = _rgb.b;

		return target;

	}

	getStyle( colorSpace = SRGBColorSpace ) {

		ColorManagement.fromWorkingColorSpace( toComponents( this, _rgb ), colorSpace );

		if ( colorSpace !== SRGBColorSpace ) {

			// Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
			return `color(${ colorSpace } ${ _rgb.r } ${ _rgb.g } ${ _rgb.b })`;

		}

		return `rgb(${( _rgb.r * 255 ) | 0},${( _rgb.g * 255 ) | 0},${( _rgb.b * 255 ) | 0})`;

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = lerp( _hslA.h, _hslB.h, alpha );
		const s = lerp( _hslA.s, _hslB.s, alpha );
		const l = lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

	*[ Symbol.iterator ]() {

		yield this.r;
		yield this.g;
		yield this.b;

	}

}

Color.NAMES = _colorKeywords;

let _canvas;

class ImageUtils {

	static getDataURL( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = createElementNS( 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			console.warn( 'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image );

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

	static sRGBToLinear( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			const canvas = createElementNS( 'canvas' );

			canvas.width = image.width;
			canvas.height = image.height;

			const context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height );

			const imageData = context.getImageData( 0, 0, image.width, image.height );
			const data = imageData.data;

			for ( let i = 0; i < data.length; i ++ ) {

				data[ i ] = SRGBToLinear( data[ i ] / 255 ) * 255;

			}

			context.putImageData( imageData, 0, 0 );

			return canvas;

		} else if ( image.data ) {

			const data = image.data.slice( 0 );

			for ( let i = 0; i < data.length; i ++ ) {

				if ( data instanceof Uint8Array || data instanceof Uint8ClampedArray ) {

					data[ i ] = Math.floor( SRGBToLinear( data[ i ] / 255 ) * 255 );

				} else {

					// assuming float

					data[ i ] = SRGBToLinear( data[ i ] );

				}

			}

			return {
				data: data,
				width: image.width,
				height: image.height
			};

		} else {

			console.warn( 'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.' );
			return image;

		}

	}

}

class Source {

	constructor( data = null ) {

		this.isSource = true;

		this.uuid = generateUUID();

		this.data = data;

		this.version = 0;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.images[ this.uuid ] !== undefined ) {

			return meta.images[ this.uuid ];

		}

		const output = {
			uuid: this.uuid,
			url: ''
		};

		const data = this.data;

		if ( data !== null ) {

			let url;

			if ( Array.isArray( data ) ) {

				// cube texture

				url = [];

				for ( let i = 0, l = data.length; i < l; i ++ ) {

					if ( data[ i ].isDataTexture ) {

						url.push( serializeImage( data[ i ].image ) );

					} else {

						url.push( serializeImage( data[ i ] ) );

					}

				}

			} else {

				// texture

				url = serializeImage( data );

			}

			output.url = url;

		}

		if ( ! isRootObject ) {

			meta.images[ this.uuid ] = output;

		}

		return output;

	}

}

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.from( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		this.isTexture = true;

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = generateUUID();

		this.name = '';

		this.source = new Source( image );
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.userData = {};

		this.version = 0;
		this.onUpdate = null;

		this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
		this.needsPMREMUpdate = false; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)

	}

	get image() {

		return this.source.data;

	}

	set image( value ) {

		this.source.data = value;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.source = source.source;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		this.needsUpdate = true;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			image: this.source.toJSON( meta ).uuid,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( JSON.stringify( this.userData ) !== '{}' ) output.userData = this.userData;

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) {

			this.version ++;
			this.source.needsUpdate = true;

		}

	}

}

Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		Vector4.prototype.isVector4 = true;

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;
		yield this.w;

	}

}

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.isQuaternion = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		let r = vFrom.dot( vTo ) + 1;

		if ( r < Number.EPSILON ) {

			// vFrom and vTo point in opposite directions

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q ) {

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	slerpQuaternions( qa, qb, t ) {

		return this.copy( qa ).slerp( qb, t );

	}

	random() {

		// Derived from http://planning.cs.uiuc.edu/node198.html
		// Note, this source uses w, x, y, z ordering,
		// so we swap the order below.

		const u1 = Math.random();
		const sqrt1u1 = Math.sqrt( 1 - u1 );
		const sqrtu1 = Math.sqrt( u1 );

		const u2 = 2 * Math.PI * Math.random();

		const u3 = 2 * Math.PI * Math.random();

		return this.set(
			sqrt1u1 * Math.cos( u2 ),
			sqrtu1 * Math.sin( u3 ),
			sqrtu1 * Math.cos( u3 ),
			sqrt1u1 * Math.sin( u2 ),
		);

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._w;

	}

}

class Vector3 {

	constructor( x = 0, y = 0, z = 0 ) {

		Vector3.prototype.isVector3 = true;

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v ) {

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v ) {

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		return this.applyQuaternion( _quaternion$4.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion$4.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v ) {

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector$c.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector$c );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector$c.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	setFromEuler( e ) {

		this.x = e._x;
		this.y = e._y;
		this.z = e._z;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

	randomDirection() {

		// Derived from https://mathworld.wolfram.com/SpherePointPicking.html

		const u = ( Math.random() - 0.5 ) * 2;
		const t = Math.random() * Math.PI * 2;
		const f = Math.sqrt( 1 - u ** 2 );

		this.x = f * Math.cos( t );
		this.y = f * Math.sin( t );
		this.z = u;

		return this;

	}

	*[ Symbol.iterator ]() {

		yield this.x;
		yield this.y;
		yield this.z;

	}

}

const _vector$c = /*@__PURE__*/ new Vector3();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

		this.isBox3 = true;

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$b.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object, precise = false ) {

		this.makeEmpty();

		return this.expandByObject( object, precise );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object, precise = false ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {

				const position = geometry.attributes.position;
				for ( let i = 0, l = position.count; i < l; i ++ ) {

					_vector$b.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );
					this.expandByPoint( _vector$b );

				}

			} else {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box$3.copy( geometry.boundingBox );
				_box$3.applyMatrix4( object.matrixWorld );

				this.union( _box$3 );

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ], precise );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$b );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$b.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center );
		_extents.subVectors( this.max, _center );

		// translate triangle to aabb origin
		_v0$2.subVectors( triangle.a, _center );
		_v1$7.subVectors( triangle.b, _center );
		_v2$3.subVectors( triangle.c, _center );

		// compute edge vectors for triangle
		_f0.subVectors( _v1$7, _v0$2 );
		_f1.subVectors( _v2$3, _v1$7 );
		_f2.subVectors( _v0$2, _v2$3 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0$2, _v1$7, _v2$3, _extents );

	}

	clampPoint( point, target ) {

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$b.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$b ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

const _points = [
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3(),
	/*@__PURE__*/ new Vector3()
];

const _vector$b = /*@__PURE__*/ new Vector3();

const _box$3 = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0$2 = /*@__PURE__*/ new Vector3();
const _v1$7 = /*@__PURE__*/ new Vector3();
const _v2$3 = /*@__PURE__*/ new Vector3();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3();
const _f1 = /*@__PURE__*/ new Vector3();
const _f2 = /*@__PURE__*/ new Vector3();

const _center = /*@__PURE__*/ new Vector3();
const _extents = /*@__PURE__*/ new Vector3();
const _triangleNormal = /*@__PURE__*/ new Vector3();
const _testAxis = /*@__PURE__*/ new Vector3();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the separating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the separating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is separating and we can exit
			return false;

		}

	}

	return true;

}

const _box$2 = /*@__PURE__*/ new Box3();
const _v1$6 = /*@__PURE__*/ new Vector3();
const _toFarthestPoint = /*@__PURE__*/ new Vector3();
const _toPoint = /*@__PURE__*/ new Vector3();

class Sphere {

	constructor( center = new Vector3(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$2.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	expandByPoint( point ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671

		_toPoint.subVectors( point, this.center );

		const lengthSq = _toPoint.lengthSq();

		if ( lengthSq > ( this.radius * this.radius ) ) {

			const length = Math.sqrt( lengthSq );
			const missingRadiusHalf = ( length - this.radius ) * 0.5;

			// Nudge this sphere towards the target point. Add half the missing distance to radius,
			// and the other half to position. This gives a tighter enclosure, instead of if
			// the whole missing distance were just added to radius.

			this.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );
			this.radius += missingRadiusHalf;

		}

		return this;

	}

	union( sphere ) {

		// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769

		// To enclose another sphere into this sphere, we only need to enclose two points:
		// 1) Enclose the farthest point on the other sphere into this sphere.
		// 2) Enclose the opposite point of the farthest point into this sphere.

		 if ( this.center.equals( sphere.center ) === true ) {

			 _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );


		} else {

			_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );

		}

		this.expandByPoint( _v1$6.copy( sphere.center ).add( _toFarthestPoint ) );
		this.expandByPoint( _v1$6.copy( sphere.center ).sub( _toFarthestPoint ) );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$a = /*@__PURE__*/ new Vector3();
const _segCenter = /*@__PURE__*/ new Vector3();
const _segDir = /*@__PURE__*/ new Vector3();
const _diff = /*@__PURE__*/ new Vector3();

const _edge1 = /*@__PURE__*/ new Vector3();
const _edge2 = /*@__PURE__*/ new Vector3();
const _normal$1 = /*@__PURE__*/ new Vector3();

class Ray {

	constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$a ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$a.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$a.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$a.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$a.subVectors( sphere.center, this.origin );
		const tca = _vector$a.dot( this.direction );
		const d2 = _vector$a.dot( _vector$a ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$a ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal$1.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal$1 );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal$1 );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		Matrix4.prototype.isMatrix4 = true;

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$5.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$5.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$5.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( xy, xz, yx, yz, zx, zy ) {

		this.set(

			1, yx, zx, 0,
			xy, 1, zy, 0,
			xz, yz, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$5.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$5.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$5.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1$2.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1$2.elements[ 0 ] *= invSX;
		_m1$2.elements[ 1 ] *= invSX;
		_m1$2.elements[ 2 ] *= invSX;

		_m1$2.elements[ 4 ] *= invSY;
		_m1$2.elements[ 5 ] *= invSY;
		_m1$2.elements[ 6 ] *= invSY;

		_m1$2.elements[ 8 ] *= invSZ;
		_m1$2.elements[ 9 ] *= invSZ;
		_m1$2.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1$2 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

const _v1$5 = /*@__PURE__*/ new Vector3();
const _m1$2 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3();
const _y = /*@__PURE__*/ new Vector3();
const _z = /*@__PURE__*/ new Vector3();

const _matrix$1 = /*@__PURE__*/ new Matrix4();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this.isEuler = true;

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order = this._order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order = this._order, update = true ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update === true ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix$1.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix$1, order, update );

	}

	setFromVector3( v, order = this._order ) {

		return this.set( v.x, v.y, v.z, order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$3.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$3, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

	*[ Symbol.iterator ]() {

		yield this._x;
		yield this._y;
		yield this._z;
		yield this._order;

	}

	// @deprecated since r138, 02cf0df1cb4575d5842fef9c85bb5a89fe020d53

	toVector3() {

		console.error( 'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead' );

	}

}

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = ( 1 << channel | 0 ) >>> 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

	isEnabled( channel ) {

		return ( this.mask & ( 1 << channel | 0 ) ) !== 0;

	}

}

let _object3DId = 0;

const _v1$4 = /*@__PURE__*/ new Vector3();
const _q1 = /*@__PURE__*/ new Quaternion();
const _m1$1 = /*@__PURE__*/ new Matrix4();
const _target = /*@__PURE__*/ new Vector3();

const _position$3 = /*@__PURE__*/ new Vector3();
const _scale$2 = /*@__PURE__*/ new Vector3();
const _quaternion$2 = /*@__PURE__*/ new Quaternion();

const _xAxis = /*@__PURE__*/ new Vector3( 1, 0, 0 );
const _yAxis = /*@__PURE__*/ new Vector3( 0, 1, 0 );
const _zAxis = /*@__PURE__*/ new Vector3( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

class Object3D extends EventDispatcher {

	constructor() {

		super();

		this.isObject3D = true;

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	onBeforeRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	onAfterRender( /* renderer, scene, camera, geometry, material, group */ ) {}

	applyMatrix4( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	}

	applyQuaternion( q ) {

		this.quaternion.premultiply( q );

		return this;

	}

	setRotationFromAxisAngle( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	}

	setRotationFromEuler( euler ) {

		this.quaternion.setFromEuler( euler, true );

	}

	setRotationFromMatrix( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	}

	setRotationFromQuaternion( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	}

	rotateOnAxis( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	}

	rotateOnWorldAxis( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	}

	rotateX( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	}

	rotateY( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	}

	rotateZ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	}

	translateOnAxis( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$4.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$4.multiplyScalar( distance ) );

		return this;

	}

	translateX( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	}

	translateY( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	}

	translateZ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	}

	localToWorld( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	}

	worldToLocal( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	}

	lookAt( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position$3.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position$3, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position$3, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	}

	add( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	}

	remove( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	}

	removeFromParent() {

		const parent = this.parent;

		if ( parent !== null ) {

			parent.remove( this );

		}

		return this;

	}

	clear() {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	}

	attach( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		// Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	}

	getObjectById( id ) {

		return this.getObjectByProperty( 'id', id );

	}

	getObjectByName( name ) {

		return this.getObjectByProperty( 'name', name );

	}

	getObjectByProperty( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	}

	getWorldPosition( target ) {

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	}

	getWorldQuaternion( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, target, _scale$2 );

		return target;

	}

	getWorldScale( target ) {

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position$3, _quaternion$2, target );

		return target;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	}

	raycast( /* raycaster, intersects */ ) {}

	traverse( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	}

	traverseVisible( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	}

	traverseAncestors( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	}

	updateMatrix() {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	}

	updateMatrixWorld( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	}

	toJSON( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {},
				nodes: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();
			if ( this.instanceColor !== null ) object.instanceColor = this.instanceColor.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isScene ) {

			if ( this.background ) {

				if ( this.background.isColor ) {

					object.background = this.background.toJSON();

				} else if ( this.background.isTexture ) {

					object.background = this.background.toJSON( meta ).uuid;

				}

			}

			if ( this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true ) {

				object.environment = this.environment.toJSON( meta ).uuid;

			}

		} else if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );
			const nodes = extractFromCache( meta.nodes );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;
			if ( nodes.length > 0 ) output.nodes = nodes;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	}

	clone( recursive ) {

		return new this.constructor().copy( this, recursive );

	}

	copy( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

}

Object3D.DefaultUp = /*@__PURE__*/ new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

const _v0$1 = /*@__PURE__*/ new Vector3();
const _v1$3 = /*@__PURE__*/ new Vector3();
const _v2$2 = /*@__PURE__*/ new Vector3();
const _v3$1 = /*@__PURE__*/ new Vector3();

const _vab = /*@__PURE__*/ new Vector3();
const _vac = /*@__PURE__*/ new Vector3();
const _vbc = /*@__PURE__*/ new Vector3();
const _vap = /*@__PURE__*/ new Vector3();
const _vbp = /*@__PURE__*/ new Vector3();
const _vcp = /*@__PURE__*/ new Vector3();

class Triangle {

	constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$2.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$2 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$2 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3$1 );

		return ( _v3$1.x >= 0 ) && ( _v3$1.y >= 0 ) && ( ( _v3$1.x + _v3$1.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3$1 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3$1.x );
		target.addScaledVector( uv2, _v3$1.y );
		target.addScaledVector( uv3, _v3$1.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	setFromAttributeAndIndices( attribute, i0, i1, i2 ) {

		this.a.fromBufferAttribute( attribute, i0 );
		this.b.fromBufferAttribute( attribute, i1 );
		this.c.fromBufferAttribute( attribute, i2 );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

class Material extends EventDispatcher {

	constructor() {

		super();

		this.isMaterial = true;

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'Material';

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaToCoverage = false;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

		this._alphaTest = 0;

	}

	get alphaTest() {

		return this._alphaTest;

	}

	set alphaTest( value ) {

		if ( this._alphaTest > 0 !== value > 0 ) {

			this.version ++;

		}

		this._alphaTest = value;

	}

	onBuild( /* shaderobject, renderer */ ) {}

	onBeforeRender( /* renderer, scene, camera, geometry, object, group */ ) {}

	onBeforeCompile( /* shaderobject, renderer */ ) {}

	customProgramCacheKey() {

		return this.onBeforeCompile.toString();

	}

	setValues( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatibility if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( isRootObject ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen !== undefined ) data.sheen = this.sheen;
		if ( this.sheenColor && this.sheenColor.isColor ) data.sheenColor = this.sheenColor.getHex();
		if ( this.sheenRoughness !== undefined ) data.sheenRoughness = this.sheenRoughness;
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.specularIntensity !== undefined ) data.specularIntensity = this.specularIntensity;
		if ( this.specularColor && this.specularColor.isColor ) data.specularColor = this.specularColor.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.iridescence !== undefined ) data.iridescence = this.iridescence;
		if ( this.iridescenceIOR !== undefined ) data.iridescenceIOR = this.iridescenceIOR;
		if ( this.iridescenceThicknessRange !== undefined ) data.iridescenceThicknessRange = this.iridescenceThicknessRange;

		if ( this.iridescenceMap && this.iridescenceMap.isTexture ) {

			data.iridescenceMap = this.iridescenceMap.toJSON( meta ).uuid;

		}

		if ( this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture ) {

			data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON( meta ).uuid;

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
		if ( this.specularIntensityMap && this.specularIntensityMap.isTexture ) data.specularIntensityMap = this.specularIntensityMap.toJSON( meta ).uuid;
		if ( this.specularColorMap && this.specularColorMap.isTexture ) data.specularColorMap = this.specularColorMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;

			if ( this.combine !== undefined ) data.combine = this.combine;

		}

		if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
		if ( this.reflectivity !== undefined ) data.reflectivity = this.reflectivity;
		if ( this.refractionRatio !== undefined ) data.refractionRatio = this.refractionRatio;

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.transmission !== undefined ) data.transmission = this.transmission;
		if ( this.transmissionMap && this.transmissionMap.isTexture ) data.transmissionMap = this.transmissionMap.toJSON( meta ).uuid;
		if ( this.thickness !== undefined ) data.thickness = this.thickness;
		if ( this.thicknessMap && this.thicknessMap.isTexture ) data.thicknessMap = this.thicknessMap.toJSON( meta ).uuid;
		if ( this.attenuationDistance !== undefined ) data.attenuationDistance = this.attenuationDistance;
		if ( this.attenuationColor !== undefined ) data.attenuationColor = this.attenuationColor.getHex();

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.shadowSide !== null ) data.shadowSide = this.shadowSide;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;
		data.colorWrite = this.colorWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation !== undefined && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth !== undefined && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.alphaToCoverage === true ) data.alphaToCoverage = this.alphaToCoverage;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( this.fog === false ) data.fog = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRootObject ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.alphaToCoverage = source.alphaToCoverage;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshBasicMaterial = true;

		this.type = 'MeshBasicMaterial';

		this.color = new Color( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

const _vector$9 = /*@__PURE__*/ new Vector3();
const _vector2$1 = /*@__PURE__*/ new Vector2();

class BufferAttribute {

	constructor( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.isBufferAttribute = true;

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	copyArray( array ) {

		this.array.set( array );

		return this;

	}

	copyColorsArray( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	}

	copyVector2sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	}

	copyVector3sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	}

	copyVector4sArray( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	}

	applyMatrix3( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$9.fromBufferAttribute( this, i );
				_vector$9.applyMatrix3( m );

				this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

			}

		}

		return this;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyMatrix4( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.applyNormalMatrix( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$9.fromBufferAttribute( this, i );

			_vector$9.transformDirection( m );

			this.setXYZ( i, _vector$9.x, _vector$9.y, _vector$9.z );

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	getX( index ) {

		return this.array[ index * this.itemSize ];

	}

	setX( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	}

	getY( index ) {

		return this.array[ index * this.itemSize + 1 ];

	}

	setY( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	}

	getZ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	}

	setZ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	}

	getW( index ) {

		return this.array[ index * this.itemSize + 3 ];

	}

	setW( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	}

	setXY( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	clone() {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	}

	toJSON() {

		const data = {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.from( this.array ),
			normalized: this.normalized
		};

		if ( this.name !== '' ) data.name = this.name;
		if ( this.usage !== StaticDrawUsage ) data.usage = this.usage;
		if ( this.updateRange.offset !== 0 || this.updateRange.count !== - 1 ) data.updateRange = this.updateRange;

		return data;

	}

}

class Uint16BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint16Array( array ), itemSize, normalized );

	}

}

class Uint32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Uint32Array( array ), itemSize, normalized );

	}

}


class Float32BufferAttribute extends BufferAttribute {

	constructor( array, itemSize, normalized ) {

		super( new Float32Array( array ), itemSize, normalized );

	}

}

let _id$1 = 0;

const _m1 = /*@__PURE__*/ new Matrix4();
const _obj = /*@__PURE__*/ new Object3D();
const _offset = /*@__PURE__*/ new Vector3();
const _box$1$1 = /*@__PURE__*/ new Box3();
const _boxMorphTargets = /*@__PURE__*/ new Box3();
const _vector$8 = /*@__PURE__*/ new Vector3();

class BufferGeometry extends EventDispatcher {

	constructor() {

		super();

		this.isBufferGeometry = true;

		Object.defineProperty( this, 'id', { value: _id$1 ++ } );

		this.uuid = generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	getIndex() {

		return this.index;

	}

	setIndex( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	}

	getAttribute( name ) {

		return this.attributes[ name ];

	}

	setAttribute( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	}

	deleteAttribute( name ) {

		delete this.attributes[ name ];

		return this;

	}

	hasAttribute( name ) {

		return this.attributes[ name ] !== undefined;

	}

	addGroup( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	}

	clearGroups() {

		this.groups = [];

	}

	setDrawRange( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	}

	applyMatrix4( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	applyQuaternion( q ) {

		_m1.makeRotationFromQuaternion( q );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateX( angle ) {

		// rotate geometry around world x-axis

		_m1.makeRotationX( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateY( angle ) {

		// rotate geometry around world y-axis

		_m1.makeRotationY( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	rotateZ( angle ) {

		// rotate geometry around world z-axis

		_m1.makeRotationZ( angle );

		this.applyMatrix4( _m1 );

		return this;

	}

	translate( x, y, z ) {

		// translate geometry

		_m1.makeTranslation( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	scale( x, y, z ) {

		// scale geometry

		_m1.makeScale( x, y, z );

		this.applyMatrix4( _m1 );

		return this;

	}

	lookAt( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	}

	center() {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	}

	setFromPoints( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3( - Infinity, - Infinity, - Infinity ),
				new Vector3( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$1$1.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( this.boundingBox.min, _box$1$1.min );
						this.boundingBox.expandByPoint( _vector$8 );

						_vector$8.addVectors( this.boundingBox.max, _box$1$1.max );
						this.boundingBox.expandByPoint( _vector$8 );

					} else {

						this.boundingBox.expandByPoint( _box$1$1.min );
						this.boundingBox.expandByPoint( _box$1$1.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$1$1.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$8.addVectors( _box$1$1.min, _boxMorphTargets.min );
						_box$1$1.expandByPoint( _vector$8 );

						_vector$8.addVectors( _box$1$1.max, _boxMorphTargets.max );
						_box$1$1.expandByPoint( _vector$8 );

					} else {

						_box$1$1.expandByPoint( _boxMorphTargets.min );
						_box$1$1.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$1$1.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$8.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$8.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$8.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$8 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	}

	computeTangents() {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( this.hasAttribute( 'tangent' ) === false ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = this.getAttribute( 'tangent' ).array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3();
			tan2[ i ] = new Vector3();

		}

		const vA = new Vector3(),
			vB = new Vector3(),
			vC = new Vector3(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3(),
			tdir = new Vector3();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3(), tmp2 = new Vector3();
		const n = new Vector3(), n2 = new Vector3();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	}

	computeVertexNormals() {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
			const cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	}

	merge( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	}

	normalizeNormals() {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$8.fromBufferAttribute( normals, i );

			_vector$8.normalize();

			normals.setXYZ( i, _vector$8.x, _vector$8.y, _vector$8.z );

		}

	}

	toNonIndexed() {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				if ( attribute.isInterleavedBufferAttribute ) {

					index = indices[ i ] * attribute.data.stride + attribute.offset;

				} else {

					index = indices[ i ] * itemSize;

				}

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		// for simplicity the code assumes attributes are not shared across geometries, see #15811

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			data.data.attributes[ key ] = attribute.toJSON( data.data );

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				array.push( attribute.toJSON( data.data ) );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	}

	clone() {

		 return new this.constructor().copy( this );

	}

	copy( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		// geometry generator parameters

		if ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

const _inverseMatrix$2 = /*@__PURE__*/ new Matrix4();
const _ray$2 = /*@__PURE__*/ new Ray();
const _sphere$3 = /*@__PURE__*/ new Sphere();

const _vA$1 = /*@__PURE__*/ new Vector3();
const _vB$1 = /*@__PURE__*/ new Vector3();
const _vC$1 = /*@__PURE__*/ new Vector3();

const _tempA = /*@__PURE__*/ new Vector3();
const _tempB = /*@__PURE__*/ new Vector3();
const _tempC = /*@__PURE__*/ new Vector3();

const _morphA = /*@__PURE__*/ new Vector3();
const _morphB = /*@__PURE__*/ new Vector3();
const _morphC = /*@__PURE__*/ new Vector3();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

const _intersectionPoint = /*@__PURE__*/ new Vector3();
const _intersectionPointWorld = /*@__PURE__*/ new Vector3();

class Mesh extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		super();

		this.isMesh = true;

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray$2.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		const index = geometry.index;
		const position = geometry.attributes.position;
		const morphPosition = geometry.morphAttributes.position;
		const morphTargetsRelative = geometry.morphTargetsRelative;
		const uv = geometry.attributes.uv;
		const uv2 = geometry.attributes.uv2;
		const groups = geometry.groups;
		const drawRange = geometry.drawRange;

		if ( index !== null ) {

			// indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( index.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = index.getX( j );
						const b = index.getX( j + 1 );
						const c = index.getX( j + 2 );

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = index.getX( i );
					const b = index.getX( i + 1 );
					const c = index.getX( i + 2 );

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		} else if ( position !== undefined ) {

			// non-indexed buffer geometry

			if ( Array.isArray( material ) ) {

				for ( let i = 0, il = groups.length; i < il; i ++ ) {

					const group = groups[ i ];
					const groupMaterial = material[ group.materialIndex ];

					const start = Math.max( group.start, drawRange.start );
					const end = Math.min( position.count, Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) ) );

					for ( let j = start, jl = end; j < jl; j += 3 ) {

						const a = j;
						const b = j + 1;
						const c = j + 2;

						intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
							intersection.face.materialIndex = group.materialIndex;
							intersects.push( intersection );

						}

					}

				}

			} else {

				const start = Math.max( 0, drawRange.start );
				const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

				for ( let i = start, il = end; i < il; i += 3 ) {

					const a = i;
					const b = i + 1;
					const c = i + 2;

					intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

					if ( intersection ) {

						intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
						intersects.push( intersection );

					}

				}

			}

		}

	}

}

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA$1.fromBufferAttribute( uv, a );
			_uvB$1.fromBufferAttribute( uv, b );
			_uvC$1.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		if ( uv2 ) {

			_uvA$1.fromBufferAttribute( uv2, a );
			_uvB$1.fromBufferAttribute( uv2, b );
			_uvC$1.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() );

		}

		const face = {
			a: a,
			b: b,
			c: c,
			normal: new Vector3(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

	static fromJSON( data ) {

		return new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

function cloneUniformsGroups( src ) {

	const dst = [];

	for ( let u = 0; u < src.length; u ++ ) {

		dst.push( src[ u ].clone() );

	}

	return dst;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

class ShaderMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isShaderMaterial = true;

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};
		this.uniformsGroups = [];

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	copy( source ) {

		super.copy( source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );
		this.uniformsGroups = cloneUniformsGroups( source.uniformsGroups );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.fog = source.fog;
		this.lights = source.lights;
		this.clipping = source.clipping;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	}

}

class Camera extends Object3D {

	constructor() {

		super();

		this.isCamera = true;

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	}

	getWorldDirection( target ) {

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	updateWorldMatrix( updateParents, updateChildren ) {

		super.updateWorldMatrix( updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class PerspectiveCamera extends Camera {

	constructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		super();

		this.isPerspectiveCamera = true;

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	}

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	}

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength() {

		const vExtentSlope = Math.tan( DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	}

	getEffectiveFOV() {

		return RAD2DEG * 2 * Math.atan(
			Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom );

	}

	getFilmWidth() {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	}

	getFilmHeight() {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	}

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const near = this.near;
		let top = near * Math.tan( DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

}

const _vector1 = /*@__PURE__*/ new Vector3();
const _vector2 = /*@__PURE__*/ new Vector3();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane {

	constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

		this.isPlane = true;

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return null;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return null;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _sphere$2 = /*@__PURE__*/ new Sphere();
const _vector$7 = /*@__PURE__*/ new Vector3();

class Frustum {

	constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSprite( sprite ) {

		_sphere$2.center.set( 0, 0, 0 );
		_sphere$2.radius = 0.7071067811865476;
		_sphere$2.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$2 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();

		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new PlaneGeometry( data.width, data.height, data.widthSegments, data.heightSegments );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif";

var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif";

var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 = R12;\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normal_pars_fragment = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_pars_vertex = "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif";

var normal_vertex = "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif";

var output_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmission_fragment = "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif";

var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

const vertex$g = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

const fragment$g = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

const fragment$f = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

const fragment$e = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

const vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

const fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

const vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

const fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

const vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$9 = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$9 = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

const fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

const fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}";

const vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}";

const fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

const vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

const fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

const vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

const fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	alphatest_pars_fragment: alphatest_pars_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	iridescence_fragment: iridescence_fragment,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphcolor_vertex: morphcolor_vertex,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normal_pars_fragment: normal_pars_fragment,
	normal_pars_vertex: normal_pars_vertex,
	normal_vertex: normal_vertex,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	iridescence_pars_fragment: iridescence_pars_fragment,
	output_fragment: output_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmission_fragment: transmission_fragment,
	transmission_pars_fragment: transmission_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_vert: vertex$g,
	background_frag: fragment$g,
	cube_vert: vertex$f,
	cube_frag: fragment$f,
	depth_vert: vertex$e,
	depth_frag: fragment$e,
	distanceRGBA_vert: vertex$d,
	distanceRGBA_frag: fragment$d,
	equirect_vert: vertex$c,
	equirect_frag: fragment$c,
	linedashed_vert: vertex$b,
	linedashed_frag: fragment$b,
	meshbasic_vert: vertex$a,
	meshbasic_frag: fragment$a,
	meshlambert_vert: vertex$9,
	meshlambert_frag: fragment$9,
	meshmatcap_vert: vertex$8,
	meshmatcap_frag: fragment$8,
	meshnormal_vert: vertex$7,
	meshnormal_frag: fragment$7,
	meshphong_vert: vertex$6,
	meshphong_frag: fragment$6,
	meshphysical_vert: vertex$5,
	meshphysical_frag: fragment$5,
	meshtoon_vert: vertex$4,
	meshtoon_frag: fragment$4,
	points_vert: vertex$3,
	points_frag: fragment$3,
	shadow_vert: vertex$2,
	shadow_frag: fragment$2,
	sprite_vert: vertex$1,
	sprite_frag: fragment$1
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() },
		uv2Transform: { value: /*@__PURE__*/ new Matrix3() },

		alphaMap: { value: null },
		alphaTest: { value: 0 }

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 }, // basic, lambert, phong
		ior: { value: 1.5 }, // physical
		refractionRatio: { value: 0.98 } // basic, lambert, phong

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: /*@__PURE__*/ new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	},

	sprite: {

		diffuse: { value: /*@__PURE__*/ new Color( 0xffffff ) },
		opacity: { value: 1.0 },
		center: { value: /*@__PURE__*/ new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		alphaTest: { value: 0 },
		uvTransform: { value: /*@__PURE__*/ new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				specular: { value: /*@__PURE__*/ new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: /*@__PURE__*/ new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.meshnormal_vert,
		fragmentShader: ShaderChunk.meshnormal_frag

	},

	sprite: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: /*@__PURE__*/ new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},

	cube: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: /*@__PURE__*/ new Vector3() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: /*@__PURE__*/ mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: /*@__PURE__*/ new Color( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: /*@__PURE__*/ mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: /*@__PURE__*/ new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			iridescence: { value: 0 },
			iridescenceMap: { value: null },
			iridescenceIOR: { value: 1.3 },
			iridescenceThicknessMinimum: { value: 100 },
			iridescenceThicknessMaximum: { value: 400 },
			iridescenceThicknessMap: { value: null },
			sheen: { value: 0 },
			sheenColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			sheenColorMap: { value: null },
			sheenRoughness: { value: 1 },
			sheenRoughnessMap: { value: null },
			transmission: { value: 0 },
			transmissionMap: { value: null },
			transmissionSamplerSize: { value: /*@__PURE__*/ new Vector2() },
			transmissionSamplerMap: { value: null },
			thickness: { value: 0 },
			thicknessMap: { value: null },
			attenuationDistance: { value: 0 },
			attenuationColor: { value: /*@__PURE__*/ new Color( 0x000000 ) },
			specularIntensity: { value: 1 },
			specularIntensityMap: { value: null },
			specularColor: { value: /*@__PURE__*/ new Color( 1, 1, 1 ) },
			specularColorMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

class OrthographicCamera extends Camera {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.isOrthographicCamera = true;

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

class Group extends Object3D {

	constructor() {

		super();

		this.isGroup = true;

		this.type = 'Group';

	}

}

class InterleavedBuffer {

	constructor( array, stride ) {

		this.isInterleavedBuffer = true;

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = generateUUID();

	}

	onUploadCallback() {}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

	setUsage( value ) {

		this.usage = value;

		return this;

	}

	copy( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	}

	copyAt( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	}

	set( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	}

	clone( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new this.constructor( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	}

	onUpload( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

	toJSON( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.from( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

}

const _vector$6 = /*@__PURE__*/ new Vector3();

class InterleavedBufferAttribute {

	constructor( interleavedBuffer, itemSize, offset, normalized = false ) {

		this.isInterleavedBufferAttribute = true;

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	get count() {

		return this.data.count;

	}

	get array() {

		return this.data.array;

	}

	set needsUpdate( value ) {

		this.data.needsUpdate = value;

	}

	applyMatrix4( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	applyNormalMatrix( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.applyNormalMatrix( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	transformDirection( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$6.fromBufferAttribute( this, i );

			_vector$6.transformDirection( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	}

	setX( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	}

	setY( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	}

	setZ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	}

	setW( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	}

	getX( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	}

	getY( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	}

	getZ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	}

	getW( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	}

	setXY( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	}

	setXYZ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	}

	setXYZW( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

	clone( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	}

	toJSON( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interleaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

}

const _basePosition = /*@__PURE__*/ new Vector3();

const _skinIndex = /*@__PURE__*/ new Vector4();
const _skinWeight = /*@__PURE__*/ new Vector4();

const _vector$5 = /*@__PURE__*/ new Vector3();
const _matrix = /*@__PURE__*/ new Matrix4();

class SkinnedMesh extends Mesh {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isSkinnedMesh = true;

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	}

	bind( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	}

	pose() {

		this.skeleton.pose();

	}

	normalizeSkinWeights() {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.fromBufferAttribute( skinWeight, i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	}

	boneTransform( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.copy( target ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$5.copy( _basePosition ).applyMatrix4( _matrix ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

}

class Bone extends Object3D {

	constructor() {

		super();

		this.isBone = true;

		this.type = 'Bone';

	}

}

class DataTexture extends Texture {

	constructor( data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.isDataTexture = true;

		this.image = { data: data, width: width, height: height };

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

	}

}

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	computeBoneTexture() {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

		let size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = ceilPowerOfTwo( size );
		size = Math.max( size, 4 );

		const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
		boneMatrices.set( this.boneMatrices ); // copy current values

		const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
		boneTexture.needsUpdate = true;

		this.boneMatrices = boneMatrices;
		this.boneTexture = boneTexture;
		this.boneTextureSize = size;

		return this;

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isLineBasicMaterial = true;

		this.type = 'LineBasicMaterial';

		this.color = new Color( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.fog = source.fog;

		return this;

	}

}

const _start$1 = /*@__PURE__*/ new Vector3();
const _end$1 = /*@__PURE__*/ new Vector3();
const _inverseMatrix$1 = /*@__PURE__*/ new Matrix4();
const _ray$1 = /*@__PURE__*/ new Ray();
const _sphere$1 = /*@__PURE__*/ new Sphere();

class Line extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		super();

		this.isLine = true;

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [ 0 ];

			for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

				_start$1.fromBufferAttribute( positionAttribute, i - 1 );
				_end$1.fromBufferAttribute( positionAttribute, i );

				lineDistances[ i ] = lineDistances[ i - 1 ];
				lineDistances[ i ] += _start$1.distanceTo( _end$1 );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere );
		_sphere$1.applyMatrix4( matrixWorld );
		_sphere$1.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3();
		const vEnd = new Vector3();
		const interSegment = new Vector3();
		const interRay = new Vector3();
		const step = this.isLineSegments ? 2 : 1;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				const a = index.getX( i );
				const b = index.getX( i + 1 );

				vStart.fromBufferAttribute( positionAttribute, a );
				vEnd.fromBufferAttribute( positionAttribute, b );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end - 1; i < l; i += step ) {

				vStart.fromBufferAttribute( positionAttribute, i );
				vEnd.fromBufferAttribute( positionAttribute, i + 1 );

				const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

				if ( distSq > localThresholdSq ) continue;

				interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

				const distance = raycaster.ray.origin.distanceTo( interRay );

				if ( distance < raycaster.near || distance > raycaster.far ) continue;

				intersects.push( {

					distance: distance,
					// What do we want? intersection point on the ray or on the segment??
					// point: raycaster.ray.at( distance ),
					point: interSegment.clone().applyMatrix4( this.matrixWorld ),
					index: i,
					face: null,
					faceIndex: null,
					object: this

				} );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

const _start$2 = /*@__PURE__*/ new Vector3();
const _end$2 = /*@__PURE__*/ new Vector3();

class LineSegments extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineSegments = true;

		this.type = 'LineSegments';

	}

	computeLineDistances() {

		const geometry = this.geometry;

		// we assume non-indexed geometry

		if ( geometry.index === null ) {

			const positionAttribute = geometry.attributes.position;
			const lineDistances = [];

			for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

				_start$2.fromBufferAttribute( positionAttribute, i );
				_end$2.fromBufferAttribute( positionAttribute, i + 1 );

				lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
				lineDistances[ i + 1 ] = lineDistances[ i ] + _start$2.distanceTo( _end$2 );

			}

			geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

		} else {

			console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

		}

		return this;

	}

}

class LineLoop extends Line {

	constructor( geometry, material ) {

		super( geometry, material );

		this.isLineLoop = true;

		this.type = 'LineLoop';

	}

}

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isPointsMaterial = true;

		this.type = 'PointsMaterial';

		this.color = new Color( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.fog = source.fog;

		return this;

	}

}

const _inverseMatrix = /*@__PURE__*/ new Matrix4();
const _ray$3 = /*@__PURE__*/ new Ray();
const _sphere$4 = /*@__PURE__*/ new Sphere();
const _position$2 = /*@__PURE__*/ new Vector3();

class Points extends Object3D {

	constructor( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		super();

		this.isPoints = true;

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	}

	raycast( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;
		const drawRange = geometry.drawRange;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$4.copy( geometry.boundingSphere );
		_sphere$4.applyMatrix4( matrixWorld );
		_sphere$4.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$4 ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray$3.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const index = geometry.index;
		const attributes = geometry.attributes;
		const positionAttribute = attributes.position;

		if ( index !== null ) {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, il = end; i < il; i ++ ) {

				const a = index.getX( i );

				_position$2.fromBufferAttribute( positionAttribute, a );

				testPoint( _position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		} else {

			const start = Math.max( 0, drawRange.start );
			const end = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );

			for ( let i = start, l = end; i < l; i ++ ) {

				_position$2.fromBufferAttribute( positionAttribute, i );

				testPoint( _position$2, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

			}

		}

	}

	updateMorphTargets() {

		const geometry = this.geometry;

		const morphAttributes = geometry.morphAttributes;
		const keys = Object.keys( morphAttributes );

		if ( keys.length > 0 ) {

			const morphAttribute = morphAttributes[ keys[ 0 ] ];

			if ( morphAttribute !== undefined ) {

				this.morphTargetInfluences = [];
				this.morphTargetDictionary = {};

				for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

					const name = morphAttribute[ m ].name || String( m );

					this.morphTargetInfluences.push( 0 );
					this.morphTargetDictionary[ name ] = m;

				}

			}

		}

	}

}

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray$3.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3();

		_ray$3.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3();
			const vertex = new Vector3();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

	static fromJSON( data ) {

		return new CylinderGeometry( data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength );

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices = [], indices = [], radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3();
			const b = new Vector3();
			const c = new Vector3();

			const centroid = new Vector3();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

	static fromJSON( data ) {

		return new PolyhedronGeometry( data.vertices, data.indices, data.radius, data.details );

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

	static fromJSON( data ) {

		return new OctahedronGeometry( data.radius, data.detail );

	}

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();

		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3();
		const normal = new Vector3();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();

		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3();
		const vertex = new Vector3();
		const normal = new Vector3();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	static fromJSON( data ) {

		return new TorusGeometry( data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc );

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry = null ) {

		super();

		this.type = 'WireframeGeometry';

		this.parameters = {
			geometry: geometry
		};

		if ( geometry !== null ) {

			// buffer

			const vertices = [];
			const edges = new Set();

			// helper variables

			const start = new Vector3();
			const end = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all edges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const groupStart = group.start;
					const groupCount = group.count;

					for ( let i = groupStart, l = ( groupStart + groupCount ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const index1 = indices.getX( i + j );
							const index2 = indices.getX( i + ( j + 1 ) % 3 );

							start.fromBufferAttribute( position, index1 );
							end.fromBufferAttribute( position, index2 );

							if ( isUniqueEdge( start, end, edges ) === true ) {

								vertices.push( start.x, start.y, start.z );
								vertices.push( end.x, end.y, end.z );

							}

						}

					}

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						const index2 = 3 * i + ( ( j + 1 ) % 3 );

						start.fromBufferAttribute( position, index1 );
						end.fromBufferAttribute( position, index2 );

						if ( isUniqueEdge( start, end, edges ) === true ) {

							vertices.push( start.x, start.y, start.z );
							vertices.push( end.x, end.y, end.z );

						}

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

}

function isUniqueEdge( start, end, edges ) {

	const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
	const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

	if ( edges.has( hash1 ) === true || edges.has( hash2 ) === true ) {

		return false;

	} else {

		edges.add( hash1 );
		edges.add( hash2 );
		return true;

	}

}

class MeshStandardMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshStandardMaterial = true;

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.flatShading = false;

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.flatShading = source.flatShading;

		this.fog = source.fog;

		return this;

	}

}

class MeshPhysicalMaterial extends MeshStandardMaterial {

	constructor( parameters ) {

		super();

		this.isMeshPhysicalMaterial = true;

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.ior = 1.5;

		Object.defineProperty( this, 'reflectivity', {
			get: function () {

				return ( clamp( 2.5 * ( this.ior - 1 ) / ( this.ior + 1 ), 0, 1 ) );

			},
			set: function ( reflectivity ) {

				this.ior = ( 1 + 0.4 * reflectivity ) / ( 1 - 0.4 * reflectivity );

			}
		} );

		this.iridescenceMap = null;
		this.iridescenceIOR = 1.3;
		this.iridescenceThicknessRange = [ 100, 400 ];
		this.iridescenceThicknessMap = null;

		this.sheenColor = new Color( 0x000000 );
		this.sheenColorMap = null;
		this.sheenRoughness = 1.0;
		this.sheenRoughnessMap = null;

		this.transmissionMap = null;

		this.thickness = 0;
		this.thicknessMap = null;
		this.attenuationDistance = 0.0;
		this.attenuationColor = new Color( 1, 1, 1 );

		this.specularIntensity = 1.0;
		this.specularIntensityMap = null;
		this.specularColor = new Color( 1, 1, 1 );
		this.specularColorMap = null;

		this._sheen = 0.0;
		this._clearcoat = 0;
		this._iridescence = 0;
		this._transmission = 0;

		this.setValues( parameters );

	}

	get sheen() {

		return this._sheen;

	}

	set sheen( value ) {

		if ( this._sheen > 0 !== value > 0 ) {

			this.version ++;

		}

		this._sheen = value;

	}

	get clearcoat() {

		return this._clearcoat;

	}

	set clearcoat( value ) {

		if ( this._clearcoat > 0 !== value > 0 ) {

			this.version ++;

		}

		this._clearcoat = value;

	}

	get iridescence() {

		return this._iridescence;

	}

	set iridescence( value ) {

		if ( this._iridescence > 0 !== value > 0 ) {

			this.version ++;

		}

		this._iridescence = value;

	}

	get transmission() {

		return this._transmission;

	}

	set transmission( value ) {

		if ( this._transmission > 0 !== value > 0 ) {

			this.version ++;

		}

		this._transmission = value;

	}

	copy( source ) {

		super.copy( source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.ior = source.ior;

		this.iridescence = source.iridescence;
		this.iridescenceMap = source.iridescenceMap;
		this.iridescenceIOR = source.iridescenceIOR;
		this.iridescenceThicknessRange = [ ...source.iridescenceThicknessRange ];
		this.iridescenceThicknessMap = source.iridescenceThicknessMap;

		this.sheen = source.sheen;
		this.sheenColor.copy( source.sheenColor );
		this.sheenColorMap = source.sheenColorMap;
		this.sheenRoughness = source.sheenRoughness;
		this.sheenRoughnessMap = source.sheenRoughnessMap;

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		this.thickness = source.thickness;
		this.thicknessMap = source.thicknessMap;
		this.attenuationDistance = source.attenuationDistance;
		this.attenuationColor.copy( source.attenuationColor );

		this.specularIntensity = source.specularIntensity;
		this.specularIntensityMap = source.specularIntensityMap;
		this.specularColor.copy( source.specularColor );
		this.specularColorMap = source.specularColorMap;

		return this;

	}

}

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.isMeshLambertMaterial = true;

		this.type = 'MeshLambertMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.fog = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.fog = source.fog;

		return this;

	}

}

// same as Array.prototype.slice, but also works on typed arrays
function arraySlice( array, from, to ) {

	if ( isTypedArray( array ) ) {

		// in ios9 array.subarray(from, undefined) will return empty array
		// but array.subarray(from) or array.subarray(from, len) is correct
		return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

	}

	return array.slice( from, to );

}

// converts an array to a specific type
function convertArray( array, type, forceClone ) {

	if ( ! array || // let 'undefined' and 'null' pass
		! forceClone && array.constructor === type ) return array;

	if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

		return new type( array ); // create typed array

	}

	return Array.prototype.slice.call( array ); // create Array

}

function isTypedArray( object ) {

	return ArrayBuffer.isView( object ) &&
		! ( object instanceof DataView );

}

// returns an array by which times and values can be sorted
function getKeyframeOrder( times ) {

	function compareTime( i, j ) {

		return times[ i ] - times[ j ];

	}

	const n = times.length;
	const result = new Array( n );
	for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

	result.sort( compareTime );

	return result;

}

// uses the array previously returned by 'getKeyframeOrder' to sort data
function sortedArray( values, stride, order ) {

	const nValues = values.length;
	const result = new values.constructor( nValues );

	for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

		const srcOffset = order[ i ] * stride;

		for ( let j = 0; j !== stride; ++ j ) {

			result[ dstOffset ++ ] = values[ srcOffset + j ];

		}

	}

	return result;

}

// function for parsing AOS keyframe formats
function flattenJSON( jsonKeys, times, values, valuePropertyName ) {

	let i = 1, key = jsonKeys[ 0 ];

	while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

		key = jsonKeys[ i ++ ];

	}

	if ( key === undefined ) return; // no data

	let value = key[ valuePropertyName ];
	if ( value === undefined ) return; // no data

	if ( Array.isArray( value ) ) {

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push.apply( values, value ); // push all elements

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else if ( value.toArray !== undefined ) {

		// ...assume THREE.Math-ish

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				value.toArray( values, values.length );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	} else {

		// otherwise push as-is

		do {

			value = key[ valuePropertyName ];

			if ( value !== undefined ) {

				times.push( key.time );
				values.push( value );

			}

			key = jsonKeys[ i ++ ];

		} while ( key !== undefined );

	}

}

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

class Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

		this.settings = null;
		this.DefaultSettings_ = {};

	}

	evaluate( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.copySampleValue_( i1 - 1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.copySampleValue_( 0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.copySampleValue_( 0 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.copySampleValue_( i1 - 1 );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	}

	getSettings_() {

		return this.settings || this.DefaultSettings_;

	}

	copySampleValue_( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	// Template methods for derived classes:

	interpolate_( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	}

	intervalChanged_( /* i1, t0, t1 */ ) {

		// empty

	}

}

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

class CubicInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

		this.DefaultSettings_ = {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		};

	}

	intervalChanged_( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

}

class LinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

}

/**
 *
 * Interpolant that evaluates to the sample value at the position preceding
 * the parameter.
 */

class DiscreteInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

}

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = convertArray( times, this.TimeBufferType );
		this.values = convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': convertArray( track.times, Array ),
				'values': convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = arraySlice( times, from, to );
			this.values = arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = arraySlice( this.times ),
			values = arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = arraySlice( times, 0, writeIndex );
			this.values = arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = arraySlice( this.times, 0 );
		const values = arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

class QuaternionLinearInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

}

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = getKeyframeOrder( times );
			times = sortedArray( times, 1, order );
			values = sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * fps;

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

class LoadingManager {

	constructor( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

}

const DefaultLoadingManager = /*@__PURE__*/ new LoadingManager();

class Loader {

	constructor( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	load( /* url, onLoad, onProgress, onError */ ) {}

	loadAsync( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	}

	parse( /* data */ ) {}

	setCrossOrigin( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	}

	setWithCredentials( value ) {

		this.withCredentials = value;
		return this;

	}

	setPath( path ) {

		this.path = path;
		return this;

	}

	setResourcePath( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	}

	setRequestHeader( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

}

const loading = {};

class HttpError extends Error {

	constructor( message, response ) {

		super( message );
		this.response = response;

	}

}

class FileLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			this.manager.itemStart( url );

			setTimeout( () => {

				if ( onLoad ) onLoad( cached );

				this.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Initialise array for duplicate requests
		loading[ url ] = [];

		loading[ url ].push( {
			onLoad: onLoad,
			onProgress: onProgress,
			onError: onError,
		} );

		// create request
		const req = new Request( url, {
			headers: new Headers( this.requestHeader ),
			credentials: this.withCredentials ? 'include' : 'same-origin',
			// An abort controller could be added within a future PR
		} );

		// record states ( avoid data race )
		const mimeType = this.mimeType;
		const responseType = this.responseType;

		// start the fetch
		fetch( req )
			.then( response => {

				if ( response.status === 200 || response.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( response.status === 0 ) {

						console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					}

					// Workaround: Checking if response.body === undefined for Alipay browser #23548

					if ( typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined ) {

						return response;

					}

					const callbacks = loading[ url ];
					const reader = response.body.getReader();
					const contentLength = response.headers.get( 'Content-Length' );
					const total = contentLength ? parseInt( contentLength ) : 0;
					const lengthComputable = total !== 0;
					let loaded = 0;

					// periodically read data into the new stream tracking while download progress
					const stream = new ReadableStream( {
						start( controller ) {

							readData();

							function readData() {

								reader.read().then( ( { done, value } ) => {

									if ( done ) {

										controller.close();

									} else {

										loaded += value.byteLength;

										const event = new ProgressEvent( 'progress', { lengthComputable, loaded, total } );
										for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

											const callback = callbacks[ i ];
											if ( callback.onProgress ) callback.onProgress( event );

										}

										controller.enqueue( value );
										readData();

									}

								} );

							}

						}

					} );

					return new Response( stream );

				} else {

					throw new HttpError( `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response );

				}

			} )
			.then( response => {

				switch ( responseType ) {

					case 'arraybuffer':

						return response.arrayBuffer();

					case 'blob':

						return response.blob();

					case 'document':

						return response.text()
							.then( text => {

								const parser = new DOMParser();
								return parser.parseFromString( text, mimeType );

							} );

					case 'json':

						return response.json();

					default:

						if ( mimeType === undefined ) {

							return response.text();

						} else {

							// sniff encoding
							const re = /charset="?([^;"\s]*)"?/i;
							const exec = re.exec( mimeType );
							const label = exec && exec[ 1 ] ? exec[ 1 ].toLowerCase() : undefined;
							const decoder = new TextDecoder( label );
							return response.arrayBuffer().then( ab => decoder.decode( ab ) );

						}

				}

			} )
			.then( data => {

				// Add to cache only on HTTP success, so that we do not cache
				// error response bodies as proper responses to requests.
				Cache.add( url, data );

				const callbacks = loading[ url ];
				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onLoad ) callback.onLoad( data );

				}

			} )
			.catch( err => {

				// Abort errors and other errors are handled the same

				const callbacks = loading[ url ];

				if ( callbacks === undefined ) {

					// When onLoad was called and url was deleted in `loading`
					this.manager.itemError( url );
					throw err;

				}

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( err );

				}

				this.manager.itemError( url );

			} )
			.finally( () => {

				this.manager.itemEnd( url );

			} );

		this.manager.itemStart( url );

	}

	setResponseType( value ) {

		this.responseType = value;
		return this;

	}

	setMimeType( value ) {

		this.mimeType = value;
		return this;

	}

}

class ImageLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = createElementNS( 'img' );

		function onImageLoad() {

			removeEventListeners();

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			removeEventListeners();

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		function removeEventListeners() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.slice( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class TextureLoader extends Loader {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

}

class Light extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.isLight = true;

		this.type = 'Light';

		this.color = new Color( color );
		this.intensity = intensity;

	}

	dispose() {

		// Empty here in base class; some subclasses override.

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
const _lookTarget$1 = /*@__PURE__*/ new Vector3();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;
		this.blurSamples = 8;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget$1 );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix$1.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	dispose() {

		if ( this.map ) {

			this.map.dispose();

		}

		if ( this.mapPass ) {

			this.mapPass.dispose();

		}

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.isSpotLightShadow = true;

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

	copy( source ) {

		super.copy( source );

		this.focus = source.focus;

		return this;

	}

}

class SpotLight extends Light {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.isSpotLight = true;

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / Math.PI;

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3();
const _lookTarget = /*@__PURE__*/ new Vector3();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this.isPointLightShadow = true;

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		const far = light.distance || camera.far;

		if ( far !== camera.far ) {

			camera.far = far;
			camera.updateProjectionMatrix();

		}

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld );

		_lookTarget.copy( camera.position );
		_lookTarget.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

	}

}

class PointLight extends Light {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.isPointLight = true;

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// compute the light's luminous power (in lumens) from its intensity (in candela)
		// for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// set the light's intensity (in candela) from the desired luminous power (in lumens)
		this.intensity = power / ( 4 * Math.PI );

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		this.isDirectionalLightShadow = true;

	}

}

class DirectionalLight extends Light {

	constructor( color, intensity ) {

		super( color, intensity );

		this.isDirectionalLight = true;

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	dispose() {

		this.shadow.dispose();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

class LoaderUtils {

	static decodeText( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	}

	static extractUrlBase( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.slice( 0, index + 1 );

	}

	static resolveURL( url, path ) {

		// Invalid URL
		if ( typeof url !== 'string' || url === '' ) return '';

		// Host Relative URL
		if ( /^https?:\/\//i.test( path ) && /^\//.test( url ) ) {

			path = path.replace( /(^https?:\/\/[^\/]+).*/i, '$1' );

		}

		// Absolute URL http://,https://,//
		if ( /^(https?:)?\/\//i.test( url ) ) return url;

		// Data URI
		if ( /^data:.*,.*$/i.test( url ) ) return url;

		// Blob URL
		if ( /^blob:.*$/i.test( url ) ) return url;

		// Relative URL
		return path + url;

	}

}

class InstancedBufferGeometry extends BufferGeometry {

	constructor() {

		super();

		this.isInstancedBufferGeometry = true;

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	copy( source ) {

		super.copy( source );

		this.instanceCount = source.instanceCount;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const data = super.toJSON( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

}

class ImageBitmapLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.isImageBitmapLoader = true;

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		this.options = { premultiplyAlpha: 'none' };

	}

	setOptions( options ) {

		this.options = options;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /*@__PURE__*/ /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

class Composite {

	constructor( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	getValue( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	}

	setValue( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	}

	bind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	}

	unbind() {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

}

// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
class PropertyBinding {

	constructor( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

		// initial state of these methods that calls 'bind'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}


	static create( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	}

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	static sanitizeNodeName( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	}

	static parseTrackName( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( matches === null ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	}

	static findNode( root, nodeName ) {

		if ( nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

	// these are used to "bind" a nonexistent property
	_getValue_unavailable() {}
	_setValue_unavailable() {}

	// Getters

	_getValue_direct( buffer, offset ) {

		buffer[ offset ] = this.targetObject[ this.propertyName ];

	}

	_getValue_array( buffer, offset ) {

		const source = this.resolvedProperty;

		for ( let i = 0, n = source.length; i !== n; ++ i ) {

			buffer[ offset ++ ] = source[ i ];

		}

	}

	_getValue_arrayElement( buffer, offset ) {

		buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

	}

	_getValue_toArray( buffer, offset ) {

		this.resolvedProperty.toArray( buffer, offset );

	}

	// Direct

	_setValue_direct( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];

	}

	_setValue_direct_setNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.targetObject[ this.propertyName ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// EntireArray

	_setValue_array( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

	}

	_setValue_array_setNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.needsUpdate = true;

	}

	_setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

		const dest = this.resolvedProperty;

		for ( let i = 0, n = dest.length; i !== n; ++ i ) {

			dest[ i ] = buffer[ offset ++ ];

		}

		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// ArrayElement

	_setValue_arrayElement( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

	}

	_setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.needsUpdate = true;

	}

	_setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	// HasToFromArray

	_setValue_fromArray( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );

	}

	_setValue_fromArray_setNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.needsUpdate = true;

	}

	_setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

		this.resolvedProperty.fromArray( buffer, offset );
		this.targetObject.matrixWorldNeedsUpdate = true;

	}

	_getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

	}

	_setValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	}

	// create getter / setter pair for a property in the scene graph
	bind() {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( ! targetObject.geometry.morphAttributes ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
					return;

				}

				if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

					propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	}

	unbind() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

}

PropertyBinding.Composite = Composite;

PropertyBinding.prototype.BindingType = {
	Direct: 0,
	EntireArray: 1,
	ArrayElement: 2,
	HasFromToArray: 3
};

PropertyBinding.prototype.Versioning = {
	None: 0,
	NeedsUpdate: 1,
	MatrixWorldNeedsUpdate: 2
};

PropertyBinding.prototype.GetterByBindingType = [

	PropertyBinding.prototype._getValue_direct,
	PropertyBinding.prototype._getValue_array,
	PropertyBinding.prototype._getValue_arrayElement,
	PropertyBinding.prototype._getValue_toArray,

];

PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [

	[
		// Direct
		PropertyBinding.prototype._setValue_direct,
		PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
		PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,

	], [

		// EntireArray

		PropertyBinding.prototype._setValue_array,
		PropertyBinding.prototype._setValue_array_setNeedsUpdate,
		PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,

	], [

		// ArrayElement
		PropertyBinding.prototype._setValue_arrayElement,
		PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
		PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,

	], [

		// HasToFromArray
		PropertyBinding.prototype._setValue_fromArray,
		PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
		PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,

	]

];

class InstancedInterleavedBuffer extends InterleavedBuffer {

	constructor( array, stride, meshPerAttribute = 1 ) {

		super( array, stride );

		this.isInstancedInterleavedBuffer = true;

		this.meshPerAttribute = meshPerAttribute;

	}

	copy( source ) {

		super.copy( source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	}

	clone( data ) {

		const ib = super.clone( data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	}

	toJSON( data ) {

		const json = super.toJSON( data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

}

class Raycaster {

	constructor( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

	}

	set( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	}

	setFromCamera( coords, camera ) {

		if ( camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	}

	intersectObject( object, recursive = true, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	}

	intersectObjects( objects, recursive = true, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be between EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _startP = /*@__PURE__*/ new Vector3();
const _startEnd = /*@__PURE__*/ new Vector3();

class Line3 {

	constructor( start = new Vector3(), end = new Vector3() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}

const _raycaster = new Raycaster();

const _tempVector = new Vector3();
const _tempVector2 = new Vector3();
const _tempQuaternion = new Quaternion();
const _unit = {
	X: new Vector3( 1, 0, 0 ),
	Y: new Vector3( 0, 1, 0 ),
	Z: new Vector3( 0, 0, 1 )
};

const _changeEvent = { type: 'change' };
const _mouseDownEvent = { type: 'mouseDown' };
const _mouseUpEvent = { type: 'mouseUp', mode: null };
const _objectChangeEvent = { type: 'objectChange' };

class TransformControls extends Object3D {

	constructor( camera, domElement ) {

		super();

		if ( domElement === undefined ) {

			console.warn( 'THREE.TransformControls: The second parameter "domElement" is now mandatory.' );
			domElement = document;

		}

		this.isTransformControls = true;

		this.visible = false;
		this.domElement = domElement;
		this.domElement.style.touchAction = 'none'; // disable touch scroll

		const _gizmo = new TransformControlsGizmo();
		this._gizmo = _gizmo;
		this.add( _gizmo );

		const _plane = new TransformControlsPlane();
		this._plane = _plane;
		this.add( _plane );

		const scope = this;

		// Defined getter, setter and store for a property
		function defineProperty( propName, defaultValue ) {

			let propValue = defaultValue;

			Object.defineProperty( scope, propName, {

				get: function () {

					return propValue !== undefined ? propValue : defaultValue;

				},

				set: function ( value ) {

					if ( propValue !== value ) {

						propValue = value;
						_plane[ propName ] = value;
						_gizmo[ propName ] = value;

						scope.dispatchEvent( { type: propName + '-changed', value: value } );
						scope.dispatchEvent( _changeEvent );

					}

				}

			} );

			scope[ propName ] = defaultValue;
			_plane[ propName ] = defaultValue;
			_gizmo[ propName ] = defaultValue;

		}

		// Define properties with getters/setter
		// Setting the defined property will automatically trigger change event
		// Defined properties are passed down to gizmo and plane

		defineProperty( 'camera', camera );
		defineProperty( 'object', undefined );
		defineProperty( 'enabled', true );
		defineProperty( 'axis', null );
		defineProperty( 'mode', 'translate' );
		defineProperty( 'translationSnap', null );
		defineProperty( 'rotationSnap', null );
		defineProperty( 'scaleSnap', null );
		defineProperty( 'space', 'world' );
		defineProperty( 'size', 1 );
		defineProperty( 'dragging', false );
		defineProperty( 'showX', true );
		defineProperty( 'showY', true );
		defineProperty( 'showZ', true );

		// Reusable utility variables

		const worldPosition = new Vector3();
		const worldPositionStart = new Vector3();
		const worldQuaternion = new Quaternion();
		const worldQuaternionStart = new Quaternion();
		const cameraPosition = new Vector3();
		const cameraQuaternion = new Quaternion();
		const pointStart = new Vector3();
		const pointEnd = new Vector3();
		const rotationAxis = new Vector3();
		const rotationAngle = 0;
		const eye = new Vector3();

		// TODO: remove properties unused in plane and gizmo

		defineProperty( 'worldPosition', worldPosition );
		defineProperty( 'worldPositionStart', worldPositionStart );
		defineProperty( 'worldQuaternion', worldQuaternion );
		defineProperty( 'worldQuaternionStart', worldQuaternionStart );
		defineProperty( 'cameraPosition', cameraPosition );
		defineProperty( 'cameraQuaternion', cameraQuaternion );
		defineProperty( 'pointStart', pointStart );
		defineProperty( 'pointEnd', pointEnd );
		defineProperty( 'rotationAxis', rotationAxis );
		defineProperty( 'rotationAngle', rotationAngle );
		defineProperty( 'eye', eye );

		this._offset = new Vector3();
		this._startNorm = new Vector3();
		this._endNorm = new Vector3();
		this._cameraScale = new Vector3();

		this._parentPosition = new Vector3();
		this._parentQuaternion = new Quaternion();
		this._parentQuaternionInv = new Quaternion();
		this._parentScale = new Vector3();

		this._worldScaleStart = new Vector3();
		this._worldQuaternionInv = new Quaternion();
		this._worldScale = new Vector3();

		this._positionStart = new Vector3();
		this._quaternionStart = new Quaternion();
		this._scaleStart = new Vector3();

		this._getPointer = getPointer.bind( this );
		this._onPointerDown = onPointerDown.bind( this );
		this._onPointerHover = onPointerHover.bind( this );
		this._onPointerMove = onPointerMove.bind( this );
		this._onPointerUp = onPointerUp.bind( this );

		this.domElement.addEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.addEventListener( 'pointermove', this._onPointerHover );
		this.domElement.addEventListener( 'pointerup', this._onPointerUp );

	}

	// updateMatrixWorld  updates key transformation variables
	updateMatrixWorld() {

		if ( this.object !== undefined ) {

			this.object.updateMatrixWorld();

			if ( this.object.parent === null ) {

				console.error( 'TransformControls: The attached 3D object must be a part of the scene graph.' );

			} else {

				this.object.parent.matrixWorld.decompose( this._parentPosition, this._parentQuaternion, this._parentScale );

			}

			this.object.matrixWorld.decompose( this.worldPosition, this.worldQuaternion, this._worldScale );

			this._parentQuaternionInv.copy( this._parentQuaternion ).invert();
			this._worldQuaternionInv.copy( this.worldQuaternion ).invert();

		}

		this.camera.updateMatrixWorld();
		this.camera.matrixWorld.decompose( this.cameraPosition, this.cameraQuaternion, this._cameraScale );

		if ( this.camera.isOrthographicCamera ) {

			this.camera.getWorldDirection( this.eye );

		} else {

			this.eye.copy( this.cameraPosition ).sub( this.worldPosition ).normalize();

		}

		super.updateMatrixWorld( this );

	}

	pointerHover( pointer ) {

		if ( this.object === undefined || this.dragging === true ) return;

		_raycaster.setFromCamera( pointer, this.camera );

		const intersect = intersectObjectWithRay( this._gizmo.picker[ this.mode ], _raycaster );

		if ( intersect ) {

			this.axis = intersect.object.name;

		} else {

			this.axis = null;

		}

	}

	pointerDown( pointer ) {

		if ( this.object === undefined || this.dragging === true || pointer.button !== 0 ) return;

		if ( this.axis !== null ) {

			_raycaster.setFromCamera( pointer, this.camera );

			const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );

			if ( planeIntersect ) {

				this.object.updateMatrixWorld();
				this.object.parent.updateMatrixWorld();

				this._positionStart.copy( this.object.position );
				this._quaternionStart.copy( this.object.quaternion );
				this._scaleStart.copy( this.object.scale );

				this.object.matrixWorld.decompose( this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart );

				this.pointStart.copy( planeIntersect.point ).sub( this.worldPositionStart );

			}

			this.dragging = true;
			_mouseDownEvent.mode = this.mode;
			this.dispatchEvent( _mouseDownEvent );

		}

	}

	pointerMove( pointer ) {

		const axis = this.axis;
		const mode = this.mode;
		const object = this.object;
		let space = this.space;

		if ( mode === 'scale' ) {

			space = 'local';

		} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {

			space = 'world';

		}

		if ( object === undefined || axis === null || this.dragging === false || pointer.button !== - 1 ) return;

		_raycaster.setFromCamera( pointer, this.camera );

		const planeIntersect = intersectObjectWithRay( this._plane, _raycaster, true );

		if ( ! planeIntersect ) return;

		this.pointEnd.copy( planeIntersect.point ).sub( this.worldPositionStart );

		if ( mode === 'translate' ) {

			// Apply translate

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._worldQuaternionInv );

			}

			if ( axis.indexOf( 'X' ) === - 1 ) this._offset.x = 0;
			if ( axis.indexOf( 'Y' ) === - 1 ) this._offset.y = 0;
			if ( axis.indexOf( 'Z' ) === - 1 ) this._offset.z = 0;

			if ( space === 'local' && axis !== 'XYZ' ) {

				this._offset.applyQuaternion( this._quaternionStart ).divide( this._parentScale );

			} else {

				this._offset.applyQuaternion( this._parentQuaternionInv ).divide( this._parentScale );

			}

			object.position.copy( this._offset ).add( this._positionStart );

			// Apply translation snap

			if ( this.translationSnap ) {

				if ( space === 'local' ) {

					object.position.applyQuaternion( _tempQuaternion.copy( this._quaternionStart ).invert() );

					if ( axis.search( 'X' ) !== - 1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== - 1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== - 1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					object.position.applyQuaternion( this._quaternionStart );

				}

				if ( space === 'world' ) {

					if ( object.parent ) {

						object.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

					if ( axis.search( 'X' ) !== - 1 ) {

						object.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Y' ) !== - 1 ) {

						object.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;

					}

					if ( axis.search( 'Z' ) !== - 1 ) {

						object.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;

					}

					if ( object.parent ) {

						object.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );

					}

				}

			}

		} else if ( mode === 'scale' ) {

			if ( axis.search( 'XYZ' ) !== - 1 ) {

				let d = this.pointEnd.length() / this.pointStart.length();

				if ( this.pointEnd.dot( this.pointStart ) < 0 ) d *= - 1;

				_tempVector2.set( d, d, d );

			} else {

				_tempVector.copy( this.pointStart );
				_tempVector2.copy( this.pointEnd );

				_tempVector.applyQuaternion( this._worldQuaternionInv );
				_tempVector2.applyQuaternion( this._worldQuaternionInv );

				_tempVector2.divide( _tempVector );

				if ( axis.search( 'X' ) === - 1 ) {

					_tempVector2.x = 1;

				}

				if ( axis.search( 'Y' ) === - 1 ) {

					_tempVector2.y = 1;

				}

				if ( axis.search( 'Z' ) === - 1 ) {

					_tempVector2.z = 1;

				}

			}

			// Apply scale

			object.scale.copy( this._scaleStart ).multiply( _tempVector2 );

			if ( this.scaleSnap ) {

				if ( axis.search( 'X' ) !== - 1 ) {

					object.scale.x = Math.round( object.scale.x / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Y' ) !== - 1 ) {

					object.scale.y = Math.round( object.scale.y / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

				if ( axis.search( 'Z' ) !== - 1 ) {

					object.scale.z = Math.round( object.scale.z / this.scaleSnap ) * this.scaleSnap || this.scaleSnap;

				}

			}

		} else if ( mode === 'rotate' ) {

			this._offset.copy( this.pointEnd ).sub( this.pointStart );

			const ROTATION_SPEED = 20 / this.worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );

			if ( axis === 'E' ) {

				this.rotationAxis.copy( this.eye );
				this.rotationAngle = this.pointEnd.angleTo( this.pointStart );

				this._startNorm.copy( this.pointStart ).normalize();
				this._endNorm.copy( this.pointEnd ).normalize();

				this.rotationAngle *= ( this._endNorm.cross( this._startNorm ).dot( this.eye ) < 0 ? 1 : - 1 );

			} else if ( axis === 'XYZE' ) {

				this.rotationAxis.copy( this._offset ).cross( this.eye ).normalize();
				this.rotationAngle = this._offset.dot( _tempVector.copy( this.rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;

			} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {

				this.rotationAxis.copy( _unit[ axis ] );

				_tempVector.copy( _unit[ axis ] );

				if ( space === 'local' ) {

					_tempVector.applyQuaternion( this.worldQuaternion );

				}

				this.rotationAngle = this._offset.dot( _tempVector.cross( this.eye ).normalize() ) * ROTATION_SPEED;

			}

			// Apply rotation snap

			if ( this.rotationSnap ) this.rotationAngle = Math.round( this.rotationAngle / this.rotationSnap ) * this.rotationSnap;

			// Apply rotate
			if ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {

				object.quaternion.copy( this._quaternionStart );
				object.quaternion.multiply( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) ).normalize();

			} else {

				this.rotationAxis.applyQuaternion( this._parentQuaternionInv );
				object.quaternion.copy( _tempQuaternion.setFromAxisAngle( this.rotationAxis, this.rotationAngle ) );
				object.quaternion.multiply( this._quaternionStart ).normalize();

			}

		}

		this.dispatchEvent( _changeEvent );
		this.dispatchEvent( _objectChangeEvent );

	}

	pointerUp( pointer ) {

		if ( pointer.button !== 0 ) return;

		if ( this.dragging && ( this.axis !== null ) ) {

			_mouseUpEvent.mode = this.mode;
			this.dispatchEvent( _mouseUpEvent );

		}

		this.dragging = false;
		this.axis = null;

	}

	dispose() {

		this.domElement.removeEventListener( 'pointerdown', this._onPointerDown );
		this.domElement.removeEventListener( 'pointermove', this._onPointerHover );
		this.domElement.removeEventListener( 'pointermove', this._onPointerMove );
		this.domElement.removeEventListener( 'pointerup', this._onPointerUp );

		this.traverse( function ( child ) {

			if ( child.geometry ) child.geometry.dispose();
			if ( child.material ) child.material.dispose();

		} );

	}

	// Set current object
	attach( object ) {

		this.object = object;
		this.visible = true;

		return this;

	}

	// Detach from object
	detach() {

		this.object = undefined;
		this.visible = false;
		this.axis = null;

		return this;

	}

	reset() {

		if ( ! this.enabled ) return;

		if ( this.dragging ) {

			this.object.position.copy( this._positionStart );
			this.object.quaternion.copy( this._quaternionStart );
			this.object.scale.copy( this._scaleStart );

			this.dispatchEvent( _changeEvent );
			this.dispatchEvent( _objectChangeEvent );

			this.pointStart.copy( this.pointEnd );

		}

	}

	getRaycaster() {

		return _raycaster;

	}

	// TODO: deprecate

	getMode() {

		return this.mode;

	}

	setMode( mode ) {

		this.mode = mode;

	}

	setTranslationSnap( translationSnap ) {

		this.translationSnap = translationSnap;

	}

	setRotationSnap( rotationSnap ) {

		this.rotationSnap = rotationSnap;

	}

	setScaleSnap( scaleSnap ) {

		this.scaleSnap = scaleSnap;

	}

	setSize( size ) {

		this.size = size;

	}

	setSpace( space ) {

		this.space = space;

	}

	update() {

		console.warn( 'THREE.TransformControls: update function has no more functionality and therefore has been deprecated.' );

	}

}

// mouse / touch event handlers

function getPointer( event ) {

	if ( this.domElement.ownerDocument.pointerLockElement ) {

		return {
			x: 0,
			y: 0,
			button: event.button
		};

	} else {

		const rect = this.domElement.getBoundingClientRect();

		return {
			x: ( event.clientX - rect.left ) / rect.width * 2 - 1,
			y: - ( event.clientY - rect.top ) / rect.height * 2 + 1,
			button: event.button
		};

	}

}

function onPointerHover( event ) {

	if ( ! this.enabled ) return;

	switch ( event.pointerType ) {

		case 'mouse':
		case 'pen':
			this.pointerHover( this._getPointer( event ) );
			break;

	}

}

function onPointerDown( event ) {

	if ( ! this.enabled ) return;

	if ( ! document.pointerLockElement ) {

		this.domElement.setPointerCapture( event.pointerId );

	}

	this.domElement.addEventListener( 'pointermove', this._onPointerMove );

	this.pointerHover( this._getPointer( event ) );
	this.pointerDown( this._getPointer( event ) );

}

function onPointerMove( event ) {

	if ( ! this.enabled ) return;

	this.pointerMove( this._getPointer( event ) );

}

function onPointerUp( event ) {

	if ( ! this.enabled ) return;

	this.domElement.releasePointerCapture( event.pointerId );

	this.domElement.removeEventListener( 'pointermove', this._onPointerMove );

	this.pointerUp( this._getPointer( event ) );

}

function intersectObjectWithRay( object, raycaster, includeInvisible ) {

	const allIntersections = raycaster.intersectObject( object, true );

	for ( let i = 0; i < allIntersections.length; i ++ ) {

		if ( allIntersections[ i ].object.visible || includeInvisible ) {

			return allIntersections[ i ];

		}

	}

	return false;

}

//

// Reusable utility variables

const _tempEuler = new Euler();
const _alignVector = new Vector3( 0, 1, 0 );
const _zeroVector = new Vector3( 0, 0, 0 );
const _lookAtMatrix = new Matrix4();
const _tempQuaternion2 = new Quaternion();
const _identityQuaternion = new Quaternion();
const _dirVector = new Vector3();
const _tempMatrix = new Matrix4();

const _unitX = new Vector3( 1, 0, 0 );
const _unitY = new Vector3( 0, 1, 0 );
const _unitZ = new Vector3( 0, 0, 1 );

const _v1 = new Vector3();
const _v2 = new Vector3();
const _v3 = new Vector3();

class TransformControlsGizmo extends Object3D {

	constructor() {

		super();

		this.isTransformControlsGizmo = true;

		this.type = 'TransformControlsGizmo';

		// shared materials

		const gizmoMaterial = new MeshBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		const gizmoLineMaterial = new LineBasicMaterial( {
			depthTest: false,
			depthWrite: false,
			fog: false,
			toneMapped: false,
			transparent: true
		} );

		// Make unique material for each axis/color

		const matInvisible = gizmoMaterial.clone();
		matInvisible.opacity = 0.15;

		const matHelper = gizmoLineMaterial.clone();
		matHelper.opacity = 0.5;

		const matRed = gizmoMaterial.clone();
		matRed.color.setHex( 0xff0000 );

		const matGreen = gizmoMaterial.clone();
		matGreen.color.setHex( 0x00ff00 );

		const matBlue = gizmoMaterial.clone();
		matBlue.color.setHex( 0x0000ff );

		const matRedTransparent = gizmoMaterial.clone();
		matRedTransparent.color.setHex( 0xff0000 );
		matRedTransparent.opacity = 0.5;

		const matGreenTransparent = gizmoMaterial.clone();
		matGreenTransparent.color.setHex( 0x00ff00 );
		matGreenTransparent.opacity = 0.5;

		const matBlueTransparent = gizmoMaterial.clone();
		matBlueTransparent.color.setHex( 0x0000ff );
		matBlueTransparent.opacity = 0.5;

		const matWhiteTransparent = gizmoMaterial.clone();
		matWhiteTransparent.opacity = 0.25;

		const matYellowTransparent = gizmoMaterial.clone();
		matYellowTransparent.color.setHex( 0xffff00 );
		matYellowTransparent.opacity = 0.25;

		const matYellow = gizmoMaterial.clone();
		matYellow.color.setHex( 0xffff00 );

		const matGray = gizmoMaterial.clone();
		matGray.color.setHex( 0x787878 );

		// reusable geometry

		const arrowGeometry = new CylinderGeometry( 0, 0.04, 0.1, 12 );
		arrowGeometry.translate( 0, 0.05, 0 );

		const scaleHandleGeometry = new BoxGeometry( 0.08, 0.08, 0.08 );
		scaleHandleGeometry.translate( 0, 0.04, 0 );

		const lineGeometry = new BufferGeometry();
		lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0,	1, 0, 0 ], 3 ) );

		const lineGeometry2 = new CylinderGeometry( 0.0075, 0.0075, 0.5, 3 );
		lineGeometry2.translate( 0, 0.25, 0 );

		function CircleGeometry( radius, arc ) {

			const geometry = new TorusGeometry( radius, 0.0075, 3, 64, arc * Math.PI * 2 );
			geometry.rotateY( Math.PI / 2 );
			geometry.rotateX( Math.PI / 2 );
			return geometry;

		}

		// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position

		function TranslateHelperGeometry() {

			const geometry = new BufferGeometry();

			geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );

			return geometry;

		}

		// Gizmo definitions - custom hierarchy definitions for setupGizmo() function

		const gizmoTranslate = {
			X: [
				[ new Mesh( arrowGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( arrowGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( arrowGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( arrowGeometry, matGreen ), [ 0, - 0.5, 0 ], [ Math.PI, 0, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ]
			],
			Z: [
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( arrowGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), null, [ Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent.clone() ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const pickerTranslate = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new OctahedronGeometry( 0.2, 0 ), matInvisible ) ]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			]
		};

		const helperTranslate = {
			START: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			END: [
				[ new Mesh( new OctahedronGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]
			],
			DELTA: [
				[ new Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]
			],
			X: [
				[ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const gizmoRotate = {
			XYZE: [
				[ new Mesh( CircleGeometry( 0.5, 1 ), matGray ), null, [ 0, Math.PI / 2, 0 ]]
			],
			X: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matRed ) ]
			],
			Y: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matGreen ), null, [ 0, 0, - Math.PI / 2 ]]
			],
			Z: [
				[ new Mesh( CircleGeometry( 0.5, 0.5 ), matBlue ), null, [ 0, Math.PI / 2, 0 ]]
			],
			E: [
				[ new Mesh( CircleGeometry( 0.75, 1 ), matYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]]
			]
		};

		const helperRotate = {
			AXIS: [
				[ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		const pickerRotate = {
			XYZE: [
				[ new Mesh( new SphereGeometry( 0.25, 10, 8 ), matInvisible ) ]
			],
			X: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
			],
			Z: [
				[ new Mesh( new TorusGeometry( 0.5, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
			],
			E: [
				[ new Mesh( new TorusGeometry( 0.75, 0.1, 2, 24 ), matInvisible ) ]
			]
		};

		const gizmoScale = {
			X: [
				[ new Mesh( scaleHandleGeometry, matRed ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( lineGeometry2, matRed ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( scaleHandleGeometry, matRed ), [ - 0.5, 0, 0 ], [ 0, 0, Math.PI / 2 ]],
			],
			Y: [
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.5, 0 ]],
				[ new Mesh( lineGeometry2, matGreen ) ],
				[ new Mesh( scaleHandleGeometry, matGreen ), [ 0, - 0.5, 0 ], [ 0, 0, Math.PI ]],
			],
			Z: [
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( lineGeometry2, matBlue ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, - 0.5 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matBlueTransparent ), [ 0.15, 0.15, 0 ]]
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matRedTransparent ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]]
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.15, 0.15, 0.01 ), matGreenTransparent ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.1, 0.1, 0.1 ), matWhiteTransparent.clone() ) ],
			]
		};

		const pickerScale = {
			X: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0.3, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ - 0.3, 0, 0 ], [ 0, 0, Math.PI / 2 ]]
			],
			Y: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0.3, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, - 0.3, 0 ], [ 0, 0, Math.PI ]]
			],
			Z: [
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, 0.3 ], [ Math.PI / 2, 0, 0 ]],
				[ new Mesh( new CylinderGeometry( 0.2, 0, 0.6, 4 ), matInvisible ), [ 0, 0, - 0.3 ], [ - Math.PI / 2, 0, 0 ]]
			],
			XY: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0.15, 0 ]],
			],
			YZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],
			],
			XZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.01 ), matInvisible ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],
			],
			XYZ: [
				[ new Mesh( new BoxGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 0 ]],
			]
		};

		const helperScale = {
			X: [
				[ new Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]
			],
			Y: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]
			],
			Z: [
				[ new Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]
			]
		};

		// Creates an Object3D with gizmos described in custom hierarchy definition.

		function setupGizmo( gizmoMap ) {

			const gizmo = new Object3D();

			for ( const name in gizmoMap ) {

				for ( let i = gizmoMap[ name ].length; i --; ) {

					const object = gizmoMap[ name ][ i ][ 0 ].clone();
					const position = gizmoMap[ name ][ i ][ 1 ];
					const rotation = gizmoMap[ name ][ i ][ 2 ];
					const scale = gizmoMap[ name ][ i ][ 3 ];
					const tag = gizmoMap[ name ][ i ][ 4 ];

					// name and tag properties are essential for picking and updating logic.
					object.name = name;
					object.tag = tag;

					if ( position ) {

						object.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );

					}

					if ( rotation ) {

						object.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );

					}

					if ( scale ) {

						object.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );

					}

					object.updateMatrix();

					const tempGeometry = object.geometry.clone();
					tempGeometry.applyMatrix4( object.matrix );
					object.geometry = tempGeometry;
					object.renderOrder = Infinity;

					object.position.set( 0, 0, 0 );
					object.rotation.set( 0, 0, 0 );
					object.scale.set( 1, 1, 1 );

					gizmo.add( object );

				}

			}

			return gizmo;

		}

		// Gizmo creation

		this.gizmo = {};
		this.picker = {};
		this.helper = {};

		this.add( this.gizmo[ 'translate' ] = setupGizmo( gizmoTranslate ) );
		this.add( this.gizmo[ 'rotate' ] = setupGizmo( gizmoRotate ) );
		this.add( this.gizmo[ 'scale' ] = setupGizmo( gizmoScale ) );
		this.add( this.picker[ 'translate' ] = setupGizmo( pickerTranslate ) );
		this.add( this.picker[ 'rotate' ] = setupGizmo( pickerRotate ) );
		this.add( this.picker[ 'scale' ] = setupGizmo( pickerScale ) );
		this.add( this.helper[ 'translate' ] = setupGizmo( helperTranslate ) );
		this.add( this.helper[ 'rotate' ] = setupGizmo( helperRotate ) );
		this.add( this.helper[ 'scale' ] = setupGizmo( helperScale ) );

		// Pickers should be hidden always

		this.picker[ 'translate' ].visible = false;
		this.picker[ 'rotate' ].visible = false;
		this.picker[ 'scale' ].visible = false;

	}

	// updateMatrixWorld will update transformations and appearance of individual handles

	updateMatrixWorld( force ) {

		const space = ( this.mode === 'scale' ) ? 'local' : this.space; // scale always oriented to local rotation

		const quaternion = ( space === 'local' ) ? this.worldQuaternion : _identityQuaternion;

		// Show only gizmos for current transform mode

		this.gizmo[ 'translate' ].visible = this.mode === 'translate';
		this.gizmo[ 'rotate' ].visible = this.mode === 'rotate';
		this.gizmo[ 'scale' ].visible = this.mode === 'scale';

		this.helper[ 'translate' ].visible = this.mode === 'translate';
		this.helper[ 'rotate' ].visible = this.mode === 'rotate';
		this.helper[ 'scale' ].visible = this.mode === 'scale';


		let handles = [];
		handles = handles.concat( this.picker[ this.mode ].children );
		handles = handles.concat( this.gizmo[ this.mode ].children );
		handles = handles.concat( this.helper[ this.mode ].children );

		for ( let i = 0; i < handles.length; i ++ ) {

			const handle = handles[ i ];

			// hide aligned to camera

			handle.visible = true;
			handle.rotation.set( 0, 0, 0 );
			handle.position.copy( this.worldPosition );

			let factor;

			if ( this.camera.isOrthographicCamera ) {

				factor = ( this.camera.top - this.camera.bottom ) / this.camera.zoom;

			} else {

				factor = this.worldPosition.distanceTo( this.cameraPosition ) * Math.min( 1.9 * Math.tan( Math.PI * this.camera.fov / 360 ) / this.camera.zoom, 7 );

			}

			handle.scale.set( 1, 1, 1 ).multiplyScalar( factor * this.size / 4 );

			// TODO: simplify helpers and consider decoupling from gizmo

			if ( handle.tag === 'helper' ) {

				handle.visible = false;

				if ( handle.name === 'AXIS' ) {

					handle.position.copy( this.worldPositionStart );
					handle.visible = !! this.axis;

					if ( this.axis === 'X' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Y' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, 0, Math.PI / 2 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'Z' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						handle.quaternion.copy( quaternion ).multiply( _tempQuaternion );

						if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {

							handle.visible = false;

						}

					}

					if ( this.axis === 'XYZE' ) {

						_tempQuaternion.setFromEuler( _tempEuler.set( 0, Math.PI / 2, 0 ) );
						_alignVector.copy( this.rotationAxis );
						handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( _zeroVector, _alignVector, _unitY ) );
						handle.quaternion.multiply( _tempQuaternion );
						handle.visible = this.dragging;

					}

					if ( this.axis === 'E' ) {

						handle.visible = false;

					}


				} else if ( handle.name === 'START' ) {

					handle.position.copy( this.worldPositionStart );
					handle.visible = this.dragging;

				} else if ( handle.name === 'END' ) {

					handle.position.copy( this.worldPosition );
					handle.visible = this.dragging;

				} else if ( handle.name === 'DELTA' ) {

					handle.position.copy( this.worldPositionStart );
					handle.quaternion.copy( this.worldQuaternionStart );
					_tempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 );
					_tempVector.applyQuaternion( this.worldQuaternionStart.clone().invert() );
					handle.scale.copy( _tempVector );
					handle.visible = this.dragging;

				} else {

					handle.quaternion.copy( quaternion );

					if ( this.dragging ) {

						handle.position.copy( this.worldPositionStart );

					} else {

						handle.position.copy( this.worldPosition );

					}

					if ( this.axis ) {

						handle.visible = this.axis.search( handle.name ) !== - 1;

					}

				}

				// If updating helper, skip rest of the loop
				continue;

			}

			// Align handles to current local or world rotation

			handle.quaternion.copy( quaternion );

			if ( this.mode === 'translate' || this.mode === 'scale' ) {

				// Hide translate and scale axis facing the camera

				const AXIS_HIDE_THRESHOLD = 0.99;
				const PLANE_HIDE_THRESHOLD = 0.2;

				if ( handle.name === 'X' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Y' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'Z' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XY' ) {

					if ( Math.abs( _alignVector.copy( _unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'YZ' ) {

					if ( Math.abs( _alignVector.copy( _unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

				if ( handle.name === 'XZ' ) {

					if ( Math.abs( _alignVector.copy( _unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_THRESHOLD ) {

						handle.scale.set( 1e-10, 1e-10, 1e-10 );
						handle.visible = false;

					}

				}

			} else if ( this.mode === 'rotate' ) {

				// Align handles to current local or world rotation

				_tempQuaternion2.copy( quaternion );
				_alignVector.copy( this.eye ).applyQuaternion( _tempQuaternion.copy( quaternion ).invert() );

				if ( handle.name.search( 'E' ) !== - 1 ) {

					handle.quaternion.setFromRotationMatrix( _lookAtMatrix.lookAt( this.eye, _zeroVector, _unitY ) );

				}

				if ( handle.name === 'X' ) {

					_tempQuaternion.setFromAxisAngle( _unitX, Math.atan2( - _alignVector.y, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Y' ) {

					_tempQuaternion.setFromAxisAngle( _unitY, Math.atan2( _alignVector.x, _alignVector.z ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

				if ( handle.name === 'Z' ) {

					_tempQuaternion.setFromAxisAngle( _unitZ, Math.atan2( _alignVector.y, _alignVector.x ) );
					_tempQuaternion.multiplyQuaternions( _tempQuaternion2, _tempQuaternion );
					handle.quaternion.copy( _tempQuaternion );

				}

			}

			// Hide disabled axes
			handle.visible = handle.visible && ( handle.name.indexOf( 'X' ) === - 1 || this.showX );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Y' ) === - 1 || this.showY );
			handle.visible = handle.visible && ( handle.name.indexOf( 'Z' ) === - 1 || this.showZ );
			handle.visible = handle.visible && ( handle.name.indexOf( 'E' ) === - 1 || ( this.showX && this.showY && this.showZ ) );

			// highlight selected axis

			handle.material._color = handle.material._color || handle.material.color.clone();
			handle.material._opacity = handle.material._opacity || handle.material.opacity;

			handle.material.color.copy( handle.material._color );
			handle.material.opacity = handle.material._opacity;

			if ( this.enabled && this.axis ) {

				if ( handle.name === this.axis ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				} else if ( this.axis.split( '' ).some( function ( a ) {

					return handle.name === a;

				} ) ) {

					handle.material.color.setHex( 0xffff00 );
					handle.material.opacity = 1.0;

				}

			}

		}

		super.updateMatrixWorld( force );

	}

}

//

class TransformControlsPlane extends Mesh {

	constructor() {

		super(
			new PlaneGeometry( 100000, 100000, 2, 2 ),
			new MeshBasicMaterial( { visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false } )
		);

		this.isTransformControlsPlane = true;

		this.type = 'TransformControlsPlane';

	}

	updateMatrixWorld( force ) {

		let space = this.space;

		this.position.copy( this.worldPosition );

		if ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation

		_v1.copy( _unitX ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v2.copy( _unitY ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );
		_v3.copy( _unitZ ).applyQuaternion( space === 'local' ? this.worldQuaternion : _identityQuaternion );

		// Align the plane for current transform mode, axis and space.

		_alignVector.copy( _v2 );

		switch ( this.mode ) {

			case 'translate':
			case 'scale':
				switch ( this.axis ) {

					case 'X':
						_alignVector.copy( this.eye ).cross( _v1 );
						_dirVector.copy( _v1 ).cross( _alignVector );
						break;
					case 'Y':
						_alignVector.copy( this.eye ).cross( _v2 );
						_dirVector.copy( _v2 ).cross( _alignVector );
						break;
					case 'Z':
						_alignVector.copy( this.eye ).cross( _v3 );
						_dirVector.copy( _v3 ).cross( _alignVector );
						break;
					case 'XY':
						_dirVector.copy( _v3 );
						break;
					case 'YZ':
						_dirVector.copy( _v1 );
						break;
					case 'XZ':
						_alignVector.copy( _v3 );
						_dirVector.copy( _v2 );
						break;
					case 'XYZ':
					case 'E':
						_dirVector.set( 0, 0, 0 );
						break;

				}

				break;
			case 'rotate':
			default:
				// special case for rotate
				_dirVector.set( 0, 0, 0 );

		}

		if ( _dirVector.length() === 0 ) {

			// If in rotate mode, make the plane parallel to camera
			this.quaternion.copy( this.cameraQuaternion );

		} else {

			_tempMatrix.lookAt( _tempVector.set( 0, 0, 0 ), _dirVector, _alignVector );

			this.quaternion.setFromRotationMatrix( _tempMatrix );

		}

		super.updateMatrixWorld( force );

	}

}

const _box$1 = new Box3();
const _vector = new Vector3();

class LineSegmentsGeometry extends InstancedBufferGeometry {

	constructor() {

		super();

		this.isLineSegmentsGeometry = true;

		this.type = 'LineSegmentsGeometry';

		const positions = [ - 1, 2, 0, 1, 2, 0, - 1, 1, 0, 1, 1, 0, - 1, 0, 0, 1, 0, 0, - 1, - 1, 0, 1, - 1, 0 ];
		const uvs = [ - 1, 2, 1, 2, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 2, 1, - 2 ];
		const index = [ 0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5 ];

		this.setIndex( index );
		this.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	applyMatrix4( matrix ) {

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined ) {

			start.applyMatrix4( matrix );

			end.applyMatrix4( matrix );

			start.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	}

	setPositions( array ) {

		let lineSegments;

		if ( array instanceof Float32Array ) {

			lineSegments = array;

		} else if ( Array.isArray( array ) ) {

			lineSegments = new Float32Array( array );

		}

		const instanceBuffer = new InstancedInterleavedBuffer( lineSegments, 6, 1 ); // xyz, xyz

		this.setAttribute( 'instanceStart', new InterleavedBufferAttribute( instanceBuffer, 3, 0 ) ); // xyz
		this.setAttribute( 'instanceEnd', new InterleavedBufferAttribute( instanceBuffer, 3, 3 ) ); // xyz

		//

		this.computeBoundingBox();
		this.computeBoundingSphere();

		return this;

	}

	setColors( array ) {

		let colors;

		if ( array instanceof Float32Array ) {

			colors = array;

		} else if ( Array.isArray( array ) ) {

			colors = new Float32Array( array );

		}

		const instanceColorBuffer = new InstancedInterleavedBuffer( colors, 6, 1 ); // rgb, rgb

		this.setAttribute( 'instanceColorStart', new InterleavedBufferAttribute( instanceColorBuffer, 3, 0 ) ); // rgb
		this.setAttribute( 'instanceColorEnd', new InterleavedBufferAttribute( instanceColorBuffer, 3, 3 ) ); // rgb

		return this;

	}

	fromWireframeGeometry( geometry ) {

		this.setPositions( geometry.attributes.position.array );

		return this;

	}

	fromEdgesGeometry( geometry ) {

		this.setPositions( geometry.attributes.position.array );

		return this;

	}

	fromMesh( mesh ) {

		this.fromWireframeGeometry( new WireframeGeometry( mesh.geometry ) );

		// set colors, maybe

		return this;

	}

	fromLineSegments( lineSegments ) {

		const geometry = lineSegments.geometry;

		this.setPositions( geometry.attributes.position.array ); // assumes non-indexed

		// set colors, maybe

		return this;

	}

	computeBoundingBox() {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			this.boundingBox.setFromBufferAttribute( start );

			_box$1.setFromBufferAttribute( end );

			this.boundingBox.union( _box$1 );

		}

	}

	computeBoundingSphere() {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		if ( this.boundingBox === null ) {

			this.computeBoundingBox();

		}

		const start = this.attributes.instanceStart;
		const end = this.attributes.instanceEnd;

		if ( start !== undefined && end !== undefined ) {

			const center = this.boundingSphere.center;

			this.boundingBox.getCenter( center );

			let maxRadiusSq = 0;

			for ( let i = 0, il = start.count; i < il; i ++ ) {

				_vector.fromBufferAttribute( start, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

				_vector.fromBufferAttribute( end, i );
				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this );

			}

		}

	}

	toJSON() {

		// todo

	}

	applyMatrix( matrix ) {

		console.warn( 'THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4().' );

		return this.applyMatrix4( matrix );

	}

}

/**
 * parameters = {
 *  color: <hex>,
 *  linewidth: <float>,
 *  dashed: <boolean>,
 *  dashScale: <float>,
 *  dashSize: <float>,
 *  dashOffset: <float>,
 *  gapSize: <float>,
 *  resolution: <Vector2>, // to be set by renderer
 * }
 */


UniformsLib.line = {

	worldUnits: { value: 1 },
	linewidth: { value: 1 },
	resolution: { value: new Vector2( 1, 1 ) },
	dashOffset: { value: 0 },
	dashScale: { value: 1 },
	dashSize: { value: 1 },
	gapSize: { value: 1 } // todo FIX - maybe change to totalSize

};

ShaderLib[ 'line' ] = {

	uniforms: UniformsUtils.merge( [
		UniformsLib.common,
		UniformsLib.fog,
		UniformsLib.line
	] ),

	vertexShader:
	/* glsl */`
		#include <common>
		#include <color_pars_vertex>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>
		#include <clipping_planes_pars_vertex>

		uniform float linewidth;
		uniform vec2 resolution;

		attribute vec3 instanceStart;
		attribute vec3 instanceEnd;

		attribute vec3 instanceColorStart;
		attribute vec3 instanceColorEnd;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#ifdef USE_DASH

			uniform float dashScale;
			attribute float instanceDistanceStart;
			attribute float instanceDistanceEnd;
			varying float vLineDistance;

		#endif

		void trimSegment( const in vec4 start, inout vec4 end ) {

			// trim end segment so it terminates between the camera plane and the near plane

			// conservative estimate of the near plane
			float a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column
			float b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column
			float nearEstimate = - 0.5 * b / a;

			float alpha = ( nearEstimate - start.z ) / ( end.z - start.z );

			end.xyz = mix( start.xyz, end.xyz, alpha );

		}

		void main() {

			#ifdef USE_COLOR

				vColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;

			#endif

			#ifdef USE_DASH

				vLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;
				vUv = uv;

			#endif

			float aspect = resolution.x / resolution.y;

			// camera space
			vec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );
			vec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );

			#ifdef WORLD_UNITS

				worldStart = start.xyz;
				worldEnd = end.xyz;

			#else

				vUv = uv;

			#endif

			// special case for perspective projection, and segments that terminate either in, or behind, the camera plane
			// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
			// but we need to perform ndc-space calculations in the shader, so we must address this issue directly
			// perhaps there is a more elegant solution -- WestLangley

			bool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column

			if ( perspective ) {

				if ( start.z < 0.0 && end.z >= 0.0 ) {

					trimSegment( start, end );

				} else if ( end.z < 0.0 && start.z >= 0.0 ) {

					trimSegment( end, start );

				}

			}

			// clip space
			vec4 clipStart = projectionMatrix * start;
			vec4 clipEnd = projectionMatrix * end;

			// ndc space
			vec3 ndcStart = clipStart.xyz / clipStart.w;
			vec3 ndcEnd = clipEnd.xyz / clipEnd.w;

			// direction
			vec2 dir = ndcEnd.xy - ndcStart.xy;

			// account for clip-space aspect ratio
			dir.x *= aspect;
			dir = normalize( dir );

			#ifdef WORLD_UNITS

				// get the offset direction as perpendicular to the view vector
				vec3 worldDir = normalize( end.xyz - start.xyz );
				vec3 offset;
				if ( position.y < 0.5 ) {

					offset = normalize( cross( start.xyz, worldDir ) );

				} else {

					offset = normalize( cross( end.xyz, worldDir ) );

				}

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				float forwardOffset = dot( worldDir, vec3( 0.0, 0.0, 1.0 ) );

				// don't extend the line if we're rendering dashes because we
				// won't be rendering the endcaps
				#ifndef USE_DASH

					// extend the line bounds to encompass  endcaps
					start.xyz += - worldDir * linewidth * 0.5;
					end.xyz += worldDir * linewidth * 0.5;

					// shift the position of the quad so it hugs the forward edge of the line
					offset.xy -= dir * forwardOffset;
					offset.z += 0.5;

				#endif

				// endcaps
				if ( position.y > 1.0 || position.y < 0.0 ) {

					offset.xy += dir * 2.0 * forwardOffset;

				}

				// adjust for linewidth
				offset *= linewidth * 0.5;

				// set the world position
				worldPos = ( position.y < 0.5 ) ? start : end;
				worldPos.xyz += offset;

				// project the worldpos
				vec4 clip = projectionMatrix * worldPos;

				// shift the depth of the projected points so the line
				// segments overlap neatly
				vec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;
				clip.z = clipPose.z * clip.w;

			#else

				vec2 offset = vec2( dir.y, - dir.x );
				// undo aspect ratio adjustment
				dir.x /= aspect;
				offset.x /= aspect;

				// sign flip
				if ( position.x < 0.0 ) offset *= - 1.0;

				// endcaps
				if ( position.y < 0.0 ) {

					offset += - dir;

				} else if ( position.y > 1.0 ) {

					offset += dir;

				}

				// adjust for linewidth
				offset *= linewidth;

				// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
				offset /= resolution.y;

				// select end
				vec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;

				// back to clip space
				offset *= clip.w;

				clip.xy += offset;

			#endif

			gl_Position = clip;

			vec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation

			#include <logdepthbuf_vertex>
			#include <clipping_planes_vertex>
			#include <fog_vertex>

		}
		`,

	fragmentShader:
	/* glsl */`
		uniform vec3 diffuse;
		uniform float opacity;
		uniform float linewidth;

		#ifdef USE_DASH

			uniform float dashOffset;
			uniform float dashSize;
			uniform float gapSize;

		#endif

		varying float vLineDistance;

		#ifdef WORLD_UNITS

			varying vec4 worldPos;
			varying vec3 worldStart;
			varying vec3 worldEnd;

			#ifdef USE_DASH

				varying vec2 vUv;

			#endif

		#else

			varying vec2 vUv;

		#endif

		#include <common>
		#include <color_pars_fragment>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>
		#include <clipping_planes_pars_fragment>

		vec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {

			float mua;
			float mub;

			vec3 p13 = p1 - p3;
			vec3 p43 = p4 - p3;

			vec3 p21 = p2 - p1;

			float d1343 = dot( p13, p43 );
			float d4321 = dot( p43, p21 );
			float d1321 = dot( p13, p21 );
			float d4343 = dot( p43, p43 );
			float d2121 = dot( p21, p21 );

			float denom = d2121 * d4343 - d4321 * d4321;

			float numer = d1343 * d4321 - d1321 * d4343;

			mua = numer / denom;
			mua = clamp( mua, 0.0, 1.0 );
			mub = ( d1343 + d4321 * ( mua ) ) / d4343;
			mub = clamp( mub, 0.0, 1.0 );

			return vec2( mua, mub );

		}

		void main() {

			#include <clipping_planes_fragment>

			#ifdef USE_DASH

				if ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps

				if ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX

			#endif

			float alpha = opacity;

			#ifdef WORLD_UNITS

				// Find the closest points on the view ray and the line segment
				vec3 rayEnd = normalize( worldPos.xyz ) * 1e5;
				vec3 lineDir = worldEnd - worldStart;
				vec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );

				vec3 p1 = worldStart + lineDir * params.x;
				vec3 p2 = rayEnd * params.y;
				vec3 delta = p1 - p2;
				float len = length( delta );
				float norm = len / linewidth;

				#ifndef USE_DASH

					#ifdef USE_ALPHA_TO_COVERAGE

						float dnorm = fwidth( norm );
						alpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );

					#else

						if ( norm > 0.5 ) {

							discard;

						}

					#endif

				#endif

			#else

				#ifdef USE_ALPHA_TO_COVERAGE

					// artifacts appear on some hardware if a derivative is taken within a conditional
					float a = vUv.x;
					float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
					float len2 = a * a + b * b;
					float dlen = fwidth( len2 );

					if ( abs( vUv.y ) > 1.0 ) {

						alpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );

					}

				#else

					if ( abs( vUv.y ) > 1.0 ) {

						float a = vUv.x;
						float b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;
						float len2 = a * a + b * b;

						if ( len2 > 1.0 ) discard;

					}

				#endif

			#endif

			vec4 diffuseColor = vec4( diffuse, alpha );

			#include <logdepthbuf_fragment>
			#include <color_fragment>

			gl_FragColor = vec4( diffuseColor.rgb, alpha );

			#include <tonemapping_fragment>
			#include <encodings_fragment>
			#include <fog_fragment>
			#include <premultiplied_alpha_fragment>

		}
		`
};

class LineMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( {

			type: 'LineMaterial',

			uniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),

			vertexShader: ShaderLib[ 'line' ].vertexShader,
			fragmentShader: ShaderLib[ 'line' ].fragmentShader,

			clipping: true // required for clipping support

		} );

		this.isLineMaterial = true;

		Object.defineProperties( this, {

			color: {

				enumerable: true,

				get: function () {

					return this.uniforms.diffuse.value;

				},

				set: function ( value ) {

					this.uniforms.diffuse.value = value;

				}

			},

			worldUnits: {

				enumerable: true,

				get: function () {

					return 'WORLD_UNITS' in this.defines;

				},

				set: function ( value ) {

					if ( value === true ) {

						this.defines.WORLD_UNITS = '';

					} else {

						delete this.defines.WORLD_UNITS;

					}

				}

			},

			linewidth: {

				enumerable: true,

				get: function () {

					return this.uniforms.linewidth.value;

				},

				set: function ( value ) {

					this.uniforms.linewidth.value = value;

				}

			},

			dashed: {

				enumerable: true,

				get: function () {

					return Boolean( 'USE_DASH' in this.defines );

				},

				set( value ) {

					if ( Boolean( value ) !== Boolean( 'USE_DASH' in this.defines ) ) {

						this.needsUpdate = true;

					}

					if ( value === true ) {

						this.defines.USE_DASH = '';

					} else {

						delete this.defines.USE_DASH;

					}

				}

			},

			dashScale: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashScale.value;

				},

				set: function ( value ) {

					this.uniforms.dashScale.value = value;

				}

			},

			dashSize: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashSize.value;

				},

				set: function ( value ) {

					this.uniforms.dashSize.value = value;

				}

			},

			dashOffset: {

				enumerable: true,

				get: function () {

					return this.uniforms.dashOffset.value;

				},

				set: function ( value ) {

					this.uniforms.dashOffset.value = value;

				}

			},

			gapSize: {

				enumerable: true,

				get: function () {

					return this.uniforms.gapSize.value;

				},

				set: function ( value ) {

					this.uniforms.gapSize.value = value;

				}

			},

			opacity: {

				enumerable: true,

				get: function () {

					return this.uniforms.opacity.value;

				},

				set: function ( value ) {

					this.uniforms.opacity.value = value;

				}

			},

			resolution: {

				enumerable: true,

				get: function () {

					return this.uniforms.resolution.value;

				},

				set: function ( value ) {

					this.uniforms.resolution.value.copy( value );

				}

			},

			alphaToCoverage: {

				enumerable: true,

				get: function () {

					return Boolean( 'USE_ALPHA_TO_COVERAGE' in this.defines );

				},

				set: function ( value ) {

					if ( Boolean( value ) !== Boolean( 'USE_ALPHA_TO_COVERAGE' in this.defines ) ) {

						this.needsUpdate = true;

					}

					if ( value === true ) {

						this.defines.USE_ALPHA_TO_COVERAGE = '';
						this.extensions.derivatives = true;

					} else {

						delete this.defines.USE_ALPHA_TO_COVERAGE;
						this.extensions.derivatives = false;

					}

				}

			}

		} );

		this.setValues( parameters );

	}

}

const _start = new Vector3();
const _end = new Vector3();

const _start4 = new Vector4();
const _end4 = new Vector4();

const _ssOrigin = new Vector4();
const _ssOrigin3 = new Vector3();
const _mvMatrix = new Matrix4();
const _line = new Line3();
const _closestPoint = new Vector3();

const _box = new Box3();
const _sphere = new Sphere();
const _clipToWorldVector = new Vector4();

let _ray, _instanceStart, _instanceEnd, _lineWidth;

// Returns the margin required to expand by in world space given the distance from the camera,
// line width, resolution, and camera projection
function getWorldSpaceHalfWidth( camera, distance, resolution ) {

	// transform into clip space, adjust the x and y values by the pixel width offset, then
	// transform back into world space to get world offset. Note clip space is [-1, 1] so full
	// width does not need to be halved.
	_clipToWorldVector.set( 0, 0, - distance, 1.0 ).applyMatrix4( camera.projectionMatrix );
	_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );
	_clipToWorldVector.x = _lineWidth / resolution.width;
	_clipToWorldVector.y = _lineWidth / resolution.height;
	_clipToWorldVector.applyMatrix4( camera.projectionMatrixInverse );
	_clipToWorldVector.multiplyScalar( 1.0 / _clipToWorldVector.w );

	return Math.abs( Math.max( _clipToWorldVector.x, _clipToWorldVector.y ) );

}

function raycastWorldUnits( lineSegments, intersects ) {

	for ( let i = 0, l = _instanceStart.count; i < l; i ++ ) {

		_line.start.fromBufferAttribute( _instanceStart, i );
		_line.end.fromBufferAttribute( _instanceEnd, i );

		const pointOnLine = new Vector3();
		const point = new Vector3();

		_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );
		const isInside = point.distanceTo( pointOnLine ) < _lineWidth * 0.5;

		if ( isInside ) {

			intersects.push( {
				point,
				pointOnLine,
				distance: _ray.origin.distanceTo( point ),
				object: lineSegments,
				face: null,
				faceIndex: i,
				uv: null,
				uv2: null,
			} );

		}

	}

}

function raycastScreenSpace( lineSegments, camera, intersects ) {

	const projectionMatrix = camera.projectionMatrix;
	const material = lineSegments.material;
	const resolution = material.resolution;
	const matrixWorld = lineSegments.matrixWorld;

	const geometry = lineSegments.geometry;
	const instanceStart = geometry.attributes.instanceStart;
	const instanceEnd = geometry.attributes.instanceEnd;

	const near = - camera.near;

	//

	// pick a point 1 unit out along the ray to avoid the ray origin
	// sitting at the camera origin which will cause "w" to be 0 when
	// applying the projection matrix.
	_ray.at( 1, _ssOrigin );

	// ndc space [ - 1.0, 1.0 ]
	_ssOrigin.w = 1;
	_ssOrigin.applyMatrix4( camera.matrixWorldInverse );
	_ssOrigin.applyMatrix4( projectionMatrix );
	_ssOrigin.multiplyScalar( 1 / _ssOrigin.w );

	// screen space
	_ssOrigin.x *= resolution.x / 2;
	_ssOrigin.y *= resolution.y / 2;
	_ssOrigin.z = 0;

	_ssOrigin3.copy( _ssOrigin );

	_mvMatrix.multiplyMatrices( camera.matrixWorldInverse, matrixWorld );

	for ( let i = 0, l = instanceStart.count; i < l; i ++ ) {

		_start4.fromBufferAttribute( instanceStart, i );
		_end4.fromBufferAttribute( instanceEnd, i );

		_start4.w = 1;
		_end4.w = 1;

		// camera space
		_start4.applyMatrix4( _mvMatrix );
		_end4.applyMatrix4( _mvMatrix );

		// skip the segment if it's entirely behind the camera
		const isBehindCameraNear = _start4.z > near && _end4.z > near;
		if ( isBehindCameraNear ) {

			continue;

		}

		// trim the segment if it extends behind camera near
		if ( _start4.z > near ) {

			const deltaDist = _start4.z - _end4.z;
			const t = ( _start4.z - near ) / deltaDist;
			_start4.lerp( _end4, t );

		} else if ( _end4.z > near ) {

			const deltaDist = _end4.z - _start4.z;
			const t = ( _end4.z - near ) / deltaDist;
			_end4.lerp( _start4, t );

		}

		// clip space
		_start4.applyMatrix4( projectionMatrix );
		_end4.applyMatrix4( projectionMatrix );

		// ndc space [ - 1.0, 1.0 ]
		_start4.multiplyScalar( 1 / _start4.w );
		_end4.multiplyScalar( 1 / _end4.w );

		// screen space
		_start4.x *= resolution.x / 2;
		_start4.y *= resolution.y / 2;

		_end4.x *= resolution.x / 2;
		_end4.y *= resolution.y / 2;

		// create 2d segment
		_line.start.copy( _start4 );
		_line.start.z = 0;

		_line.end.copy( _end4 );
		_line.end.z = 0;

		// get closest point on ray to segment
		const param = _line.closestPointToPointParameter( _ssOrigin3, true );
		_line.at( param, _closestPoint );

		// check if the intersection point is within clip space
		const zPos = MathUtils.lerp( _start4.z, _end4.z, param );
		const isInClipSpace = zPos >= - 1 && zPos <= 1;

		const isInside = _ssOrigin3.distanceTo( _closestPoint ) < _lineWidth * 0.5;

		if ( isInClipSpace && isInside ) {

			_line.start.fromBufferAttribute( instanceStart, i );
			_line.end.fromBufferAttribute( instanceEnd, i );

			_line.start.applyMatrix4( matrixWorld );
			_line.end.applyMatrix4( matrixWorld );

			const pointOnLine = new Vector3();
			const point = new Vector3();

			_ray.distanceSqToSegment( _line.start, _line.end, point, pointOnLine );

			intersects.push( {
				point: point,
				pointOnLine: pointOnLine,
				distance: _ray.origin.distanceTo( point ),
				object: lineSegments,
				face: null,
				faceIndex: i,
				uv: null,
				uv2: null,
			} );

		}

	}

}

class LineSegments2 extends Mesh {

	constructor( geometry = new LineSegmentsGeometry(), material = new LineMaterial( { color: Math.random() * 0xffffff } ) ) {

		super( geometry, material );

		this.isLineSegments2 = true;

		this.type = 'LineSegments2';

	}

	// for backwards-compatibility, but could be a method of LineSegmentsGeometry...

	computeLineDistances() {

		const geometry = this.geometry;

		const instanceStart = geometry.attributes.instanceStart;
		const instanceEnd = geometry.attributes.instanceEnd;
		const lineDistances = new Float32Array( 2 * instanceStart.count );

		for ( let i = 0, j = 0, l = instanceStart.count; i < l; i ++, j += 2 ) {

			_start.fromBufferAttribute( instanceStart, i );
			_end.fromBufferAttribute( instanceEnd, i );

			lineDistances[ j ] = ( j === 0 ) ? 0 : lineDistances[ j - 1 ];
			lineDistances[ j + 1 ] = lineDistances[ j ] + _start.distanceTo( _end );

		}

		const instanceDistanceBuffer = new InstancedInterleavedBuffer( lineDistances, 2, 1 ); // d0, d1

		geometry.setAttribute( 'instanceDistanceStart', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 0 ) ); // d0
		geometry.setAttribute( 'instanceDistanceEnd', new InterleavedBufferAttribute( instanceDistanceBuffer, 1, 1 ) ); // d1

		return this;

	}

	raycast( raycaster, intersects ) {

		const worldUnits = this.material.worldUnits;
		const camera = raycaster.camera;

		if ( camera === null && ! worldUnits ) {

			console.error( 'LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.' );

		}

		const threshold = ( raycaster.params.Line2 !== undefined ) ? raycaster.params.Line2.threshold || 0 : 0;

		_ray = raycaster.ray;

		const matrixWorld = this.matrixWorld;
		const geometry = this.geometry;
		const material = this.material;

		_lineWidth = material.linewidth + threshold;

		_instanceStart = geometry.attributes.instanceStart;
		_instanceEnd = geometry.attributes.instanceEnd;

		// check if we intersect the sphere bounds
		if ( geometry.boundingSphere === null ) {

			geometry.computeBoundingSphere();

		}

		_sphere.copy( geometry.boundingSphere ).applyMatrix4( matrixWorld );

		// increase the sphere bounds by the worst case line screen space width
		let sphereMargin;
		if ( worldUnits ) {

			sphereMargin = _lineWidth * 0.5;

		} else {

			const distanceToSphere = Math.max( camera.near, _sphere.distanceToPoint( _ray.origin ) );
			sphereMargin = getWorldSpaceHalfWidth( camera, distanceToSphere, material.resolution );

		}

		_sphere.radius += sphereMargin;

		if ( _ray.intersectsSphere( _sphere ) === false ) {

			return;

		}

		// check if we intersect the box bounds
		if ( geometry.boundingBox === null ) {

			geometry.computeBoundingBox();

		}

		_box.copy( geometry.boundingBox ).applyMatrix4( matrixWorld );

		// increase the box bounds by the worst case line width
		let boxMargin;
		if ( worldUnits ) {

			boxMargin = _lineWidth * 0.5;

		} else {

			const distanceToBox = Math.max( camera.near, _box.distanceToPoint( _ray.origin ) );
			boxMargin = getWorldSpaceHalfWidth( camera, distanceToBox, material.resolution );

		}

		_box.expandByScalar( boxMargin );

		if ( _ray.intersectsBox( _box ) === false ) {

			return;

		}

		if ( worldUnits ) {

			raycastWorldUnits( this, intersects );

		} else {

			raycastScreenSpace( this, camera, intersects );

		}

	}

}

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __require = (x) => {
  if (typeof require !== "undefined")
    return require(x);
  throw new Error('Dynamic require of "' + x + '" is not supported');
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// dist/web-ifc-mt.js
var require_web_ifc_mt = __commonJS({
  "dist/web-ifc-mt.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        function GROWABLE_HEAP_I8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP8;
        }
        function GROWABLE_HEAP_U8() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU8;
        }
        function GROWABLE_HEAP_I16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP16;
        }
        function GROWABLE_HEAP_U16() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU16;
        }
        function GROWABLE_HEAP_I32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAP32;
        }
        function GROWABLE_HEAP_U32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPU32;
        }
        function GROWABLE_HEAP_F32() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF32;
        }
        function GROWABLE_HEAP_F64() {
          if (wasmMemory.buffer != buffer) {
            updateGlobalBufferAndViews(wasmMemory.buffer);
          }
          return HEAPF64;
        }
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var ENVIRONMENT_IS_PTHREAD = Module["ENVIRONMENT_IS_PTHREAD"] || false;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          readAsync = function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
          var nodeWorkerThreads;
          try {
            nodeWorkerThreads = __require("worker_threads");
          } catch (e) {
            console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');
            throw e;
          }
          global.Worker = nodeWorkerThreads.Worker;
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          if (ENVIRONMENT_IS_NODE) {
            read_ = function shell_read(filename, binary) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary2(filename) {
              var ret = read_(filename, true);
              if (!ret.buffer) {
                ret = new Uint8Array(ret);
              }
              assert(ret.buffer);
              return ret;
            };
            readAsync = function readAsync2(filename, onload, onerror) {
              if (!nodeFS)
                nodeFS = __require("fs");
              if (!nodePath)
                nodePath = __require("path");
              filename = nodePath["normalize"](filename);
              nodeFS["readFile"](filename, function(err2, data) {
                if (err2)
                  onerror(err2);
                else
                  onload(data.buffer);
              });
            };
          } else {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        } else ;
        if (ENVIRONMENT_IS_NODE) {
          if (typeof performance === "undefined") {
            global.performance = __require("perf_hooks").performance;
          }
        }
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function alignMemory(size, factor) {
          if (!factor)
            factor = STACK_ALIGN;
          return Math.ceil(size / factor) * factor;
        }
        function warnOnce(text) {
          if (!warnOnce.shown)
            warnOnce.shown = {};
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            err(text);
          }
        }
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var wasmModule;
        var ABORT = false;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        function TextDecoderWrapper(encoding) {
          var textDecoder = new TextDecoder(encoding);
          this.decode = function(data) {
            if (data.buffer instanceof SharedArrayBuffer) {
              data = new Uint8Array(data);
            }
            return textDecoder.decode.call(textDecoder, data);
          };
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(GROWABLE_HEAP_U8(), ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, GROWABLE_HEAP_U8(), outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoderWrapper("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && GROWABLE_HEAP_U16()[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(GROWABLE_HEAP_U8().subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = GROWABLE_HEAP_I16()[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            GROWABLE_HEAP_I16()[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          GROWABLE_HEAP_I16()[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = GROWABLE_HEAP_I32()[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            GROWABLE_HEAP_I32()[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          GROWABLE_HEAP_I32()[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        function writeArrayToMemory(array, buffer2) {
          GROWABLE_HEAP_I8().set(array, buffer2 >>> 0);
        }
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            GROWABLE_HEAP_I8()[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            GROWABLE_HEAP_I8()[buffer2 >>> 0] = 0;
        }
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        if (ENVIRONMENT_IS_PTHREAD) {
          buffer = Module["buffer"];
        }
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (ENVIRONMENT_IS_PTHREAD) {
          wasmMemory = Module["wasmMemory"];
          buffer = Module["buffer"];
        } else {
          if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
          } else {
            wasmMemory = new WebAssembly.Memory({ "initial": INITIAL_MEMORY / 65536, "maximum": 4294967296 / 65536, "shared": true });
            if (!(wasmMemory.buffer instanceof SharedArrayBuffer)) {
              err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");
              if (ENVIRONMENT_IS_NODE) {
                console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)");
              }
              throw Error("bad memory");
            }
          }
        }
        if (wasmMemory) {
          buffer = wasmMemory.buffer;
        }
        INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (ENVIRONMENT_IS_PTHREAD)
            return;
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          if (ENVIRONMENT_IS_PTHREAD)
            console.error("Pthread aborting at " + new Error().stack);
          what += "";
          err(what);
          ABORT = true;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc-mt.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmTable = Module["asm"]["ta"];
            addOnInit(Module["asm"]["oa"]);
            PThread.tlsInitFunctions.push(Module["asm"]["sa"]);
            wasmModule = module2;
            if (!ENVIRONMENT_IS_PTHREAD) {
              var numWorkersToLoad = PThread.unusedWorkers.length;
              PThread.unusedWorkers.forEach(function(w) {
                PThread.loadWasmModuleToWorker(w, function() {
                  if (!--numWorkersToLoad)
                    removeRunDependency();
                });
              });
            }
          }
          if (!ENVIRONMENT_IS_PTHREAD) {
            addRunDependency();
          }
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"], result["module"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        var ASM_CONSTS = { 44848: function() {
          throw "Canceled!";
        }, 44866: function($0, $1) {
          setTimeout(function() {
            __emscripten_do_dispatch_to_thread($0, $1);
          }, 0);
        } };
        function initPthreadsJS() {
          PThread.initRuntime();
        }
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function _emscripten_futex_wake(addr, count) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true || count < 0)
            return -28;
          if (count == 0)
            return 0;
          if (count >= 2147483647)
            count = Infinity;
          var mainThreadWaitAddress = Atomics.load(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2);
          var mainThreadWoken = 0;
          if (mainThreadWaitAddress == addr) {
            var loadedAddr = Atomics.compareExchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, mainThreadWaitAddress, 0);
            if (loadedAddr == mainThreadWaitAddress) {
              --count;
              mainThreadWoken = 1;
              if (count <= 0)
                return 1;
            }
          }
          var ret = Atomics.notify(GROWABLE_HEAP_I32(), addr >> 2, count);
          if (ret >= 0)
            return ret + mainThreadWoken;
          throw "Atomics.notify returned an unexpected value " + ret;
        }
        Module["_emscripten_futex_wake"] = _emscripten_futex_wake;
        function killThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! killThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in killThread!";
          GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.terminate();
          PThread.freeThreadData(pthread);
          PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(pthread.worker), 1);
          pthread.worker.pthread = void 0;
        }
        function cancelThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cancelThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cancelThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          pthread.worker.postMessage({ "cmd": "cancel" });
        }
        function cleanupThread(pthread_ptr) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! cleanupThread() can only ever be called from main application thread!";
          if (!pthread_ptr)
            throw "Internal Error! Null pthread_ptr in cleanupThread!";
          var pthread = PThread.pthreads[pthread_ptr];
          if (pthread) {
            GROWABLE_HEAP_I32()[pthread_ptr + 12 >>> 2] = 0;
            var worker = pthread.worker;
            PThread.returnWorkerToPool(worker);
          }
        }
        var PThread = { unusedWorkers: [], runningWorkers: [], tlsInitFunctions: [], initMainThreadBlock: function() {
          var pthreadPoolSize = navigator.hardwareConcurrency;
          for (var i = 0; i < pthreadPoolSize; ++i) {
            PThread.allocateUnusedWorker();
          }
        }, initRuntime: function() {
          var tb = _malloc(228);
          for (var i = 0; i < 228 / 4; ++i)
            GROWABLE_HEAP_U32()[tb / 4 + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[tb + 12 >>> 2] = tb;
          var headPtr = tb + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var tlsMemory = _malloc(512);
          for (var i = 0; i < 128; ++i)
            GROWABLE_HEAP_U32()[tlsMemory / 4 + i >>> 0] = 0;
          Atomics.store(GROWABLE_HEAP_U32(), tb + 100 >> 2, tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 40 >> 2, tb);
          __emscripten_thread_init(tb, !ENVIRONMENT_IS_WORKER, 1);
          _emscripten_register_main_browser_thread_id(tb);
        }, initWorker: function() {
        }, pthreads: {}, threadExitHandlers: [], runExitHandlers: function() {
          while (PThread.threadExitHandlers.length > 0) {
            PThread.threadExitHandlers.pop()();
          }
          ___pthread_tsd_run_dtors();
        }, runExitHandlersAndDeinitThread: function(tb, exitCode) {
          Atomics.store(GROWABLE_HEAP_U32(), tb + 56 >> 2, 1);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 60 >> 2, 0);
          PThread.runExitHandlers();
          Atomics.store(GROWABLE_HEAP_U32(), tb + 4 >> 2, exitCode);
          Atomics.store(GROWABLE_HEAP_U32(), tb + 0 >> 2, 1);
          _emscripten_futex_wake(tb + 0, 2147483647);
          __emscripten_thread_init(0, 0, 0);
        }, setExitStatus: function(status) {
        }, threadExit: function(exitCode) {
          var tb = _pthread_self();
          if (tb) {
            PThread.runExitHandlersAndDeinitThread(tb, exitCode);
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exit" });
            }
          }
        }, threadCancel: function() {
          PThread.runExitHandlersAndDeinitThread(_pthread_self(), -1);
          postMessage({ "cmd": "cancelDone" });
        }, terminateAllThreads: function() {
          for (var t in PThread.pthreads) {
            var pthread = PThread.pthreads[t];
            if (pthread && pthread.worker) {
              PThread.returnWorkerToPool(pthread.worker);
            }
          }
          PThread.pthreads = {};
          for (var i = 0; i < PThread.unusedWorkers.length; ++i) {
            var worker = PThread.unusedWorkers[i];
            worker.terminate();
          }
          PThread.unusedWorkers = [];
          for (var i = 0; i < PThread.runningWorkers.length; ++i) {
            var worker = PThread.runningWorkers[i];
            var pthread = worker.pthread;
            PThread.freeThreadData(pthread);
            worker.terminate();
          }
          PThread.runningWorkers = [];
        }, freeThreadData: function(pthread) {
          if (!pthread)
            return;
          if (pthread.threadInfoStruct) {
            var tlsMemory = GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2];
            GROWABLE_HEAP_I32()[pthread.threadInfoStruct + 100 >>> 2] = 0;
            _free(tlsMemory);
            _free(pthread.threadInfoStruct);
          }
          pthread.threadInfoStruct = 0;
          if (pthread.allocatedOwnStack && pthread.stackBase)
            _free(pthread.stackBase);
          pthread.stackBase = 0;
          if (pthread.worker)
            pthread.worker.pthread = null;
        }, returnWorkerToPool: function(worker) {
          PThread.runWithoutMainThreadQueuedCalls(function() {
            delete PThread.pthreads[worker.pthread.threadInfoStruct];
            PThread.unusedWorkers.push(worker);
            PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker), 1);
            PThread.freeThreadData(worker.pthread);
            worker.pthread = void 0;
          });
        }, runWithoutMainThreadQueuedCalls: function(func) {
          GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 0;
          try {
            func();
          } finally {
            GROWABLE_HEAP_I32()[__emscripten_allow_main_runtime_queued_calls >>> 2] = 1;
          }
        }, receiveObjectTransfer: function(data) {
        }, threadInit: function() {
          for (var i in PThread.tlsInitFunctions) {
            PThread.tlsInitFunctions[i]();
          }
        }, loadWasmModuleToWorker: function(worker, onFinishedLoading) {
          worker.onmessage = function(e) {
            var d = e["data"];
            var cmd = d["cmd"];
            if (worker.pthread)
              PThread.currentProxiedOperationCallerThread = worker.pthread.threadInfoStruct;
            if (d["targetThread"] && d["targetThread"] != _pthread_self()) {
              var thread = PThread.pthreads[d.targetThread];
              if (thread) {
                thread.worker.postMessage(e.data, d["transferList"]);
              } else {
                console.error('Internal error! Worker sent a message "' + cmd + '" to target pthread ' + d["targetThread"] + ", but that thread no longer exists!");
              }
              PThread.currentProxiedOperationCallerThread = void 0;
              return;
            }
            if (cmd === "processQueuedMainThreadWork") {
              _emscripten_main_thread_process_queued_calls();
            } else if (cmd === "spawnThread") {
              spawnThread(e.data);
            } else if (cmd === "cleanupThread") {
              cleanupThread(d["thread"]);
            } else if (cmd === "killThread") {
              killThread(d["thread"]);
            } else if (cmd === "cancelThread") {
              cancelThread(d["thread"]);
            } else if (cmd === "loaded") {
              worker.loaded = true;
              if (onFinishedLoading)
                onFinishedLoading(worker);
              if (worker.runPthread) {
                worker.runPthread();
                delete worker.runPthread;
              }
            } else if (cmd === "print") {
              out("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "printErr") {
              err("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "alert") {
              alert("Thread " + d["threadId"] + ": " + d["text"]);
            } else if (cmd === "exit") {
              var detached = worker.pthread && Atomics.load(GROWABLE_HEAP_U32(), worker.pthread.threadInfoStruct + 64 >> 2);
              if (detached) {
                PThread.returnWorkerToPool(worker);
              }
            } else if (cmd === "exitProcess") {
              try {
                exit(d["returnCode"]);
              } catch (e2) {
                if (e2 instanceof ExitStatus)
                  return;
                throw e2;
              }
            } else if (cmd === "cancelDone") {
              PThread.returnWorkerToPool(worker);
            } else if (cmd === "objectTransfer") {
              PThread.receiveObjectTransfer(e.data);
            } else if (e.data.target === "setimmediate") {
              worker.postMessage(e.data);
            } else {
              err("worker sent an unknown command " + cmd);
            }
            PThread.currentProxiedOperationCallerThread = void 0;
          };
          worker.onerror = function(e) {
            err("pthread sent an error! " + e.filename + ":" + e.lineno + ": " + e.message);
          };
          if (ENVIRONMENT_IS_NODE) {
            worker.on("message", function(data) {
              worker.onmessage({ data });
            });
            worker.on("error", function(data) {
              worker.onerror(data);
            });
            worker.on("exit", function(data) {
            });
          }
          worker.postMessage({ "cmd": "load", "urlOrBlob": Module["mainScriptUrlOrBlob"] || _scriptDir, "wasmMemory": wasmMemory, "wasmModule": wasmModule });
        }, allocateUnusedWorker: function() {
          var pthreadMainJs = locateFile("web-ifc-mt.worker.js");
          PThread.unusedWorkers.push(new Worker(pthreadMainJs));
        }, getNewWorker: function() {
          if (PThread.unusedWorkers.length == 0) {
            PThread.allocateUnusedWorker();
            PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0]);
          }
          return PThread.unusedWorkers.pop();
        }, busySpinWait: function(msecs) {
          var t = performance.now() + msecs;
          while (performance.now() < t) {
          }
        } };
        function establishStackSpace(stackTop, stackMax) {
          _emscripten_stack_set_limits(stackTop, stackMax);
          stackRestore(stackTop);
        }
        Module["establishStackSpace"] = establishStackSpace;
        function invokeEntryPoint(ptr, arg) {
          return wasmTable.get(ptr)(arg);
        }
        Module["invokeEntryPoint"] = invokeEntryPoint;
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          };
        } else if (ENVIRONMENT_IS_PTHREAD) {
          _emscripten_get_now = function() {
            return performance.now() - Module["__performance_now_clock_drift"];
          };
        } else
          _emscripten_get_now = function() {
            return performance.now();
          };
        var _emscripten_get_now_is_monotonic = true;
        function setErrNo(value) {
          GROWABLE_HEAP_I32()[___errno_location() >>> 2] = value;
          return value;
        }
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          GROWABLE_HEAP_I32()[tp >>> 2] = now / 1e3 | 0;
          GROWABLE_HEAP_I32()[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        function _atexit(func, arg) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(1, 1, func, arg);
        }
        function ___cxa_thread_atexit(routine, arg) {
          PThread.threadExitHandlers.push(function() {
            wasmTable.get(routine)(arg);
          });
        }
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return GROWABLE_HEAP_I32()[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            GROWABLE_HEAP_I32()[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return GROWABLE_HEAP_I8()[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            Atomics.add(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
          };
          this.release_ref = function() {
            var prev = Atomics.sub(GROWABLE_HEAP_I32(), this.ptr + 0 >> 2, 1);
            return prev === 1;
          };
        }
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          throw ptr;
        }
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function zeroMemory(address, size) {
          GROWABLE_HEAP_U8().fill(0, address, address + size);
        }
        function mmapAlloc(size) {
          size = alignMemory(size, 65536);
          var ptr = _memalign(65536, size);
          if (!ptr)
            return 0;
          zeroMemory(ptr, size);
          return ptr;
        }
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === GROWABLE_HEAP_I8().buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            GROWABLE_HEAP_I8().set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency();
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency();
        }
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          FS.open("/dev/stdin", 0);
          FS.open("/dev/stdout", 1);
          FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          };
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          };
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            };
          });
          stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          };
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency();
            }
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency();
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          addRunDependency();
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          };
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              };
              putRequest.onerror = function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              };
              getRequest.onerror = function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          GROWABLE_HEAP_I32()[buf >>> 2] = stat.dev;
          GROWABLE_HEAP_I32()[buf + 4 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 8 >>> 2] = stat.ino;
          GROWABLE_HEAP_I32()[buf + 12 >>> 2] = stat.mode;
          GROWABLE_HEAP_I32()[buf + 16 >>> 2] = stat.nlink;
          GROWABLE_HEAP_I32()[buf + 20 >>> 2] = stat.uid;
          GROWABLE_HEAP_I32()[buf + 24 >>> 2] = stat.gid;
          GROWABLE_HEAP_I32()[buf + 28 >>> 2] = stat.rdev;
          GROWABLE_HEAP_I32()[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 40 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 44 >>> 2] = tempI64[1];
          GROWABLE_HEAP_I32()[buf + 48 >>> 2] = 4096;
          GROWABLE_HEAP_I32()[buf + 52 >>> 2] = stat.blocks;
          GROWABLE_HEAP_I32()[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 60 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 68 >>> 2] = 0;
          GROWABLE_HEAP_I32()[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          GROWABLE_HEAP_I32()[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[buf + 80 >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = GROWABLE_HEAP_U8().slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = GROWABLE_HEAP_I8()[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          GROWABLE_HEAP_I8()[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = GROWABLE_HEAP_I32()[iov + i * 8 >>> 2];
            var len = GROWABLE_HEAP_I32()[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, GROWABLE_HEAP_I8(), ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = GROWABLE_HEAP_I32()[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(2, 1, fd, cmd, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                GROWABLE_HEAP_I16()[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_ioctl(fd, op, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(3, 1, fd, op, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                GROWABLE_HEAP_I32()[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_open(path, flags, varargs) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(4, 1, path, flags, varargs);
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](GROWABLE_HEAP_U32()[pointer >>> 2]);
        }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (GROWABLE_HEAP_U8()[c >>> 0]) {
            ret += embind_charCodes[GROWABLE_HEAP_U8()[c++ >>> 0]];
          }
          return ret;
        }
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = GROWABLE_HEAP_I8();
            } else if (size === 2) {
              heap = GROWABLE_HEAP_I16();
            } else if (size === 4) {
              heap = GROWABLE_HEAP_I32();
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = function(handle2) {
              return handle2;
            };
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          };
          detachFinalizer = function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          };
          return attachFinalizer(handle);
        }
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        function ClassHandle() {
        }
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(GROWABLE_HEAP_I32()[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              };
              return [];
            });
            return [];
          });
        }
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I8() : GROWABLE_HEAP_U8();
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I16() : GROWABLE_HEAP_U16();
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? GROWABLE_HEAP_I32() : GROWABLE_HEAP_U32();
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F32()[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](GROWABLE_HEAP_F64()[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? function readS8FromPointer(pointer) {
                return GROWABLE_HEAP_I8()[pointer >>> 0];
              } : function readU8FromPointer(pointer) {
                return GROWABLE_HEAP_U8()[pointer >>> 0];
              };
            case 1:
              return signed ? function readS16FromPointer(pointer) {
                return GROWABLE_HEAP_I16()[pointer >>> 1];
              } : function readU16FromPointer(pointer) {
                return GROWABLE_HEAP_U16()[pointer >>> 1];
              };
            case 2:
              return signed ? function readS32FromPointer(pointer) {
                return GROWABLE_HEAP_I32()[pointer >>> 2];
              } : function readU32FromPointer(pointer) {
                return GROWABLE_HEAP_U32()[pointer >>> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = function(value) {
            return value;
          };
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = function(value) {
              return value << bitshift >>> bitshift;
            };
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = GROWABLE_HEAP_U32();
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || GROWABLE_HEAP_U8()[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(GROWABLE_HEAP_U8()[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = function() {
                return lengthBytesUTF8(value);
              };
            } else {
              getLength = function() {
                return value.length;
              };
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  GROWABLE_HEAP_U8()[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = function() {
              return GROWABLE_HEAP_U16();
            };
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = function() {
              return GROWABLE_HEAP_U32();
            };
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = GROWABLE_HEAP_U32()[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            GROWABLE_HEAP_U32()[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        function __emscripten_notify_thread_queue(targetThreadId, mainThreadId) {
          if (targetThreadId == mainThreadId) {
            postMessage({ "cmd": "processQueuedMainThreadWork" });
          } else if (ENVIRONMENT_IS_PTHREAD) {
            postMessage({ "targetThread": targetThreadId, "cmd": "processThreadQueue" });
          } else {
            var pthread = PThread.pthreads[targetThreadId];
            var worker = pthread && pthread.worker;
            if (!worker) {
              return;
            }
            worker.postMessage({ "cmd": "processThreadQueue" });
          }
          return 1;
        }
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          GROWABLE_HEAP_I32()[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(GROWABLE_HEAP_I32()[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        function __emval_new_array() {
          return __emval_register([]);
        }
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        function __emval_new_object() {
          return __emval_register({});
        }
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        function _abort() {
          abort();
        }
        var readAsmConstArgsArray = [];
        function readAsmConstArgs(sigPtr, buf) {
          readAsmConstArgsArray.length = 0;
          var ch;
          buf >>= 2;
          while (ch = GROWABLE_HEAP_U8()[sigPtr++ >>> 0]) {
            var double = ch < 105;
            if (double && buf & 1)
              buf++;
            readAsmConstArgsArray.push(double ? GROWABLE_HEAP_F64()[buf++ >>> 1] : GROWABLE_HEAP_I32()[buf >>> 0]);
            ++buf;
          }
          return readAsmConstArgsArray;
        }
        function _emscripten_asm_const_int(code, sigPtr, argbuf) {
          var args = readAsmConstArgs(sigPtr, argbuf);
          return ASM_CONSTS[code].apply(null, args);
        }
        function _emscripten_check_blocking_allowed() {
          if (ENVIRONMENT_IS_NODE)
            return;
          if (ENVIRONMENT_IS_WORKER)
            return;
          warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread");
        }
        function _emscripten_conditional_set_current_thread_status(expectedStatus, newStatus) {
        }
        function _emscripten_futex_wait(addr, val, timeout) {
          if (addr <= 0 || addr > GROWABLE_HEAP_I8().length || addr & true)
            return -28;
          if (!ENVIRONMENT_IS_WEB) {
            var ret = Atomics.wait(GROWABLE_HEAP_I32(), addr >> 2, val, timeout);
            if (ret === "timed-out")
              return -73;
            if (ret === "not-equal")
              return -6;
            if (ret === "ok")
              return 0;
            throw "Atomics.wait returned an unexpected value " + ret;
          } else {
            if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
              return -6;
            }
            var tNow = performance.now();
            var tEnd = tNow + timeout;
            var lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            while (1) {
              tNow = performance.now();
              if (tNow > tEnd) {
                lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
                return -73;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, 0);
              if (lastAddr == 0) {
                break;
              }
              _emscripten_main_thread_process_queued_calls();
              if (Atomics.load(GROWABLE_HEAP_I32(), addr >> 2) != val) {
                return -6;
              }
              lastAddr = Atomics.exchange(GROWABLE_HEAP_I32(), __emscripten_main_thread_futex >> 2, addr);
            }
            return 0;
          }
        }
        function _emscripten_memcpy_big(dest, src, num) {
          GROWABLE_HEAP_U8().copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        function _emscripten_proxy_to_main_thread_js(index, sync) {
          var numCallArgs = arguments.length - 2;
          var stack = stackSave();
          var serializedNumCallArgs = numCallArgs;
          var args = stackAlloc(serializedNumCallArgs * 8);
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            var arg = arguments[2 + i];
            GROWABLE_HEAP_F64()[b + i >>> 0] = arg;
          }
          var ret = _emscripten_run_in_main_runtime_thread_js(index, serializedNumCallArgs, args, sync);
          stackRestore(stack);
          return ret;
        }
        var _emscripten_receive_on_main_thread_js_callArgs = [];
        function _emscripten_receive_on_main_thread_js(index, numCallArgs, args) {
          _emscripten_receive_on_main_thread_js_callArgs.length = numCallArgs;
          var b = args >> 3;
          for (var i = 0; i < numCallArgs; i++) {
            _emscripten_receive_on_main_thread_js_callArgs[i] = GROWABLE_HEAP_F64()[b + i >>> 0];
          }
          var isEmAsmConst = index < 0;
          var func = !isEmAsmConst ? proxiedFunctionTable[index] : ASM_CONSTS[-index - 1];
          return func.apply(null, _emscripten_receive_on_main_thread_js_callArgs);
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = GROWABLE_HEAP_U8().length;
          requestedSize = requestedSize >>> 0;
          if (requestedSize <= oldSize) {
            return false;
          }
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var JSEvents = { inEventHandler: 0, removeAllEventListeners: function() {
          for (var i = JSEvents.eventHandlers.length - 1; i >= 0; --i) {
            JSEvents._removeHandler(i);
          }
          JSEvents.eventHandlers = [];
          JSEvents.deferredCalls = [];
        }, registerRemoveEventListeners: function() {
          if (!JSEvents.removeEventListenersRegistered) {
            JSEvents.removeEventListenersRegistered = true;
          }
        }, deferredCalls: [], deferCall: function(targetFunction, precedence, argsList) {
          function arraysHaveEqualContent(arrA, arrB) {
            if (arrA.length != arrB.length)
              return false;
            for (var i2 in arrA) {
              if (arrA[i2] != arrB[i2])
                return false;
            }
            return true;
          }
          for (var i in JSEvents.deferredCalls) {
            var call = JSEvents.deferredCalls[i];
            if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
              return;
            }
          }
          JSEvents.deferredCalls.push({ targetFunction, precedence, argsList });
          JSEvents.deferredCalls.sort(function(x, y) {
            return x.precedence < y.precedence;
          });
        }, removeDeferredCalls: function(targetFunction) {
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
              JSEvents.deferredCalls.splice(i, 1);
              --i;
            }
          }
        }, canPerformEventHandlerRequests: function() {
          return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
        }, runDeferredCalls: function() {
          if (!JSEvents.canPerformEventHandlerRequests()) {
            return;
          }
          for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
            var call = JSEvents.deferredCalls[i];
            JSEvents.deferredCalls.splice(i, 1);
            --i;
            call.targetFunction.apply(null, call.argsList);
          }
        }, eventHandlers: [], removeAllHandlersOnTarget: function(target, eventTypeString) {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == target && (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
              JSEvents._removeHandler(i--);
            }
          }
        }, _removeHandler: function(i) {
          var h = JSEvents.eventHandlers[i];
          h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
          JSEvents.eventHandlers.splice(i, 1);
        }, registerOrRemoveHandler: function(eventHandler) {
          var jsEventHandler = function jsEventHandler2(event) {
            ++JSEvents.inEventHandler;
            JSEvents.currentEventHandler = eventHandler;
            JSEvents.runDeferredCalls();
            eventHandler.handlerFunc(event);
            JSEvents.runDeferredCalls();
            --JSEvents.inEventHandler;
          };
          if (eventHandler.callbackfunc) {
            eventHandler.eventListenerFunc = jsEventHandler;
            eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
            JSEvents.eventHandlers.push(eventHandler);
            JSEvents.registerRemoveEventListeners();
          } else {
            for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
              if (JSEvents.eventHandlers[i].target == eventHandler.target && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
                JSEvents._removeHandler(i--);
              }
            }
          }
        }, queueEventHandlerOnThread_iiii: function(targetThread, eventHandlerFunc, eventTypeId, eventData, userData) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          GROWABLE_HEAP_I32()[varargs >>> 2] = eventTypeId;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = eventData;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = userData;
          __emscripten_call_on_thread(0, targetThread, 637534208, eventHandlerFunc, eventData, varargs);
          stackRestore(stackTop);
        }, getTargetThreadForEventCallback: function(targetThread) {
          switch (targetThread) {
            case 1:
              return 0;
            case 2:
              return PThread.currentProxiedOperationCallerThread;
            default:
              return targetThread;
          }
        }, getNodeNameForTarget: function(target) {
          if (!target)
            return "";
          if (target == window)
            return "#window";
          if (target == screen)
            return "#screen";
          return target && target.nodeName ? target.nodeName : "";
        }, fullscreenEnabled: function() {
          return document.fullscreenEnabled || document.webkitFullscreenEnabled;
        } };
        function stringToNewUTF8(jsString) {
          var length = lengthBytesUTF8(jsString) + 1;
          var cString = _malloc(length);
          stringToUTF8(jsString, cString, length);
          return cString;
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height) {
          var stackTop = stackSave();
          var varargs = stackAlloc(12);
          var targetCanvasPtr = 0;
          if (targetCanvas) {
            targetCanvasPtr = stringToNewUTF8(targetCanvas);
          }
          GROWABLE_HEAP_I32()[varargs >>> 2] = targetCanvasPtr;
          GROWABLE_HEAP_I32()[varargs + 4 >>> 2] = width;
          GROWABLE_HEAP_I32()[varargs + 8 >>> 2] = height;
          __emscripten_call_on_thread(0, targetThread, 657457152, 0, targetCanvasPtr, varargs);
          stackRestore(stackTop);
        }
        function _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, targetCanvas, width, height) {
          targetCanvas = targetCanvas ? UTF8ToString(targetCanvas) : "";
          _emscripten_set_offscreencanvas_size_on_target_thread_js(targetThread, targetCanvas, width, height);
        }
        function maybeCStringToJsString(cString) {
          return cString > 2 ? UTF8ToString(cString) : cString;
        }
        var specialHTMLTargets = [0, typeof document !== "undefined" ? document : 0, typeof window !== "undefined" ? window : 0];
        function findEventTarget(target) {
          target = maybeCStringToJsString(target);
          var domElement = specialHTMLTargets[target] || (typeof document !== "undefined" ? document.querySelector(target) : void 0);
          return domElement;
        }
        function findCanvasEventTarget(target) {
          return findEventTarget(target);
        }
        function _emscripten_set_canvas_element_size_calling_thread(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (!canvas)
            return -4;
          if (canvas.canvasSharedPtr) {
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr >>> 2] = width;
            GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 4 >>> 2] = height;
          }
          if (canvas.offscreenCanvas || !canvas.controlTransferredOffscreen) {
            if (canvas.offscreenCanvas)
              canvas = canvas.offscreenCanvas;
            var autoResizeViewport = false;
            if (canvas.GLctxObject && canvas.GLctxObject.GLctx) {
              var prevViewport = canvas.GLctxObject.GLctx.getParameter(2978);
              autoResizeViewport = prevViewport[0] === 0 && prevViewport[1] === 0 && prevViewport[2] === canvas.width && prevViewport[3] === canvas.height;
            }
            canvas.width = width;
            canvas.height = height;
            if (autoResizeViewport) {
              canvas.GLctxObject.GLctx.viewport(0, 0, width, height);
            }
          } else if (canvas.canvasSharedPtr) {
            var targetThread = GROWABLE_HEAP_I32()[canvas.canvasSharedPtr + 8 >>> 2];
            _emscripten_set_offscreencanvas_size_on_target_thread(targetThread, target, width, height);
            return 1;
          } else {
            return -4;
          }
          return 0;
        }
        function _emscripten_set_canvas_element_size_main_thread(target, width, height) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(5, 1, target, width, height);
          return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
        }
        function _emscripten_set_canvas_element_size(target, width, height) {
          var canvas = findCanvasEventTarget(target);
          if (canvas) {
            return _emscripten_set_canvas_element_size_calling_thread(target, width, height);
          } else {
            return _emscripten_set_canvas_element_size_main_thread(target, width, height);
          }
        }
        function _emscripten_set_current_thread_status(newStatus) {
        }
        function __webgl_enable_ANGLE_instanced_arrays(ctx) {
          var ext = ctx.getExtension("ANGLE_instanced_arrays");
          if (ext) {
            ctx["vertexAttribDivisor"] = function(index, divisor) {
              ext["vertexAttribDivisorANGLE"](index, divisor);
            };
            ctx["drawArraysInstanced"] = function(mode, first, count, primcount) {
              ext["drawArraysInstancedANGLE"](mode, first, count, primcount);
            };
            ctx["drawElementsInstanced"] = function(mode, count, type, indices, primcount) {
              ext["drawElementsInstancedANGLE"](mode, count, type, indices, primcount);
            };
            return 1;
          }
        }
        function __webgl_enable_OES_vertex_array_object(ctx) {
          var ext = ctx.getExtension("OES_vertex_array_object");
          if (ext) {
            ctx["createVertexArray"] = function() {
              return ext["createVertexArrayOES"]();
            };
            ctx["deleteVertexArray"] = function(vao) {
              ext["deleteVertexArrayOES"](vao);
            };
            ctx["bindVertexArray"] = function(vao) {
              ext["bindVertexArrayOES"](vao);
            };
            ctx["isVertexArray"] = function(vao) {
              return ext["isVertexArrayOES"](vao);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_draw_buffers(ctx) {
          var ext = ctx.getExtension("WEBGL_draw_buffers");
          if (ext) {
            ctx["drawBuffers"] = function(n, bufs) {
              ext["drawBuffersWEBGL"](n, bufs);
            };
            return 1;
          }
        }
        function __webgl_enable_WEBGL_multi_draw(ctx) {
          return !!(ctx.multiDrawWebgl = ctx.getExtension("WEBGL_multi_draw"));
        }
        var GL = { counter: 1, buffers: [], programs: [], framebuffers: [], renderbuffers: [], textures: [], shaders: [], vaos: [], contexts: {}, offscreenCanvases: {}, queries: [], stringCache: {}, unpackAlignment: 4, recordError: function recordError(errorCode) {
          if (!GL.lastError) {
            GL.lastError = errorCode;
          }
        }, getNewId: function(table) {
          var ret = GL.counter++;
          for (var i = table.length; i < ret; i++) {
            table[i] = null;
          }
          return ret;
        }, getSource: function(shader, count, string, length) {
          var source = "";
          for (var i = 0; i < count; ++i) {
            var len = length ? GROWABLE_HEAP_I32()[length + i * 4 >>> 2] : -1;
            source += UTF8ToString(GROWABLE_HEAP_I32()[string + i * 4 >>> 2], len < 0 ? void 0 : len);
          }
          return source;
        }, createContext: function(canvas, webGLContextAttributes) {
          if (!canvas.getContextSafariWebGL2Fixed) {
            canvas.getContextSafariWebGL2Fixed = canvas.getContext;
            canvas.getContext = function(ver, attrs) {
              var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
              return ver == "webgl" == gl instanceof WebGLRenderingContext ? gl : null;
            };
          }
          var ctx = canvas.getContext("webgl", webGLContextAttributes);
          if (!ctx)
            return 0;
          var handle = GL.registerContext(ctx, webGLContextAttributes);
          return handle;
        }, registerContext: function(ctx, webGLContextAttributes) {
          var handle = _malloc(8);
          GROWABLE_HEAP_I32()[handle + 4 >>> 2] = _pthread_self();
          var context = { handle, attributes: webGLContextAttributes, version: webGLContextAttributes.majorVersion, GLctx: ctx };
          if (ctx.canvas)
            ctx.canvas.GLctxObject = context;
          GL.contexts[handle] = context;
          if (typeof webGLContextAttributes.enableExtensionsByDefault === "undefined" || webGLContextAttributes.enableExtensionsByDefault) {
            GL.initExtensions(context);
          }
          return handle;
        }, makeContextCurrent: function(contextHandle) {
          GL.currentContext = GL.contexts[contextHandle];
          Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx;
          return !(contextHandle && !GLctx);
        }, getContext: function(contextHandle) {
          return GL.contexts[contextHandle];
        }, deleteContext: function(contextHandle) {
          if (GL.currentContext === GL.contexts[contextHandle])
            GL.currentContext = null;
          if (typeof JSEvents === "object")
            JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);
          if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas)
            GL.contexts[contextHandle].GLctx.canvas.GLctxObject = void 0;
          _free(GL.contexts[contextHandle].handle);
          GL.contexts[contextHandle] = null;
        }, initExtensions: function(context) {
          if (!context)
            context = GL.currentContext;
          if (context.initExtensionsDone)
            return;
          context.initExtensionsDone = true;
          var GLctx2 = context.GLctx;
          __webgl_enable_ANGLE_instanced_arrays(GLctx2);
          __webgl_enable_OES_vertex_array_object(GLctx2);
          __webgl_enable_WEBGL_draw_buffers(GLctx2);
          {
            GLctx2.disjointTimerQueryExt = GLctx2.getExtension("EXT_disjoint_timer_query");
          }
          __webgl_enable_WEBGL_multi_draw(GLctx2);
          var exts = GLctx2.getSupportedExtensions() || [];
          exts.forEach(function(ext) {
            if (!ext.includes("lose_context") && !ext.includes("debug")) {
              GLctx2.getExtension(ext);
            }
          });
        } };
        var __emscripten_webgl_power_preferences = ["default", "low-power", "high-performance"];
        function _emscripten_webgl_do_create_context(target, attributes) {
          var a = attributes >> 2;
          var powerPreference = GROWABLE_HEAP_I32()[a + (24 >> 2) >>> 0];
          var contextAttributes = { "alpha": !!GROWABLE_HEAP_I32()[a + (0 >> 2) >>> 0], "depth": !!GROWABLE_HEAP_I32()[a + (4 >> 2) >>> 0], "stencil": !!GROWABLE_HEAP_I32()[a + (8 >> 2) >>> 0], "antialias": !!GROWABLE_HEAP_I32()[a + (12 >> 2) >>> 0], "premultipliedAlpha": !!GROWABLE_HEAP_I32()[a + (16 >> 2) >>> 0], "preserveDrawingBuffer": !!GROWABLE_HEAP_I32()[a + (20 >> 2) >>> 0], "powerPreference": __emscripten_webgl_power_preferences[powerPreference], "failIfMajorPerformanceCaveat": !!GROWABLE_HEAP_I32()[a + (28 >> 2) >>> 0], majorVersion: GROWABLE_HEAP_I32()[a + (32 >> 2) >>> 0], minorVersion: GROWABLE_HEAP_I32()[a + (36 >> 2) >>> 0], enableExtensionsByDefault: GROWABLE_HEAP_I32()[a + (40 >> 2) >>> 0], explicitSwapControl: GROWABLE_HEAP_I32()[a + (44 >> 2) >>> 0], proxyContextToMainThread: GROWABLE_HEAP_I32()[a + (48 >> 2) >>> 0], renderViaOffscreenBackBuffer: GROWABLE_HEAP_I32()[a + (52 >> 2) >>> 0] };
          var canvas = findCanvasEventTarget(target);
          if (!canvas) {
            return 0;
          }
          if (contextAttributes.explicitSwapControl) {
            return 0;
          }
          var contextHandle = GL.createContext(canvas, contextAttributes);
          return contextHandle;
        }
        function _emscripten_webgl_create_context(a0, a1) {
          return _emscripten_webgl_do_create_context(a0, a1);
        }
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        function _environ_get(__environ, environ_buf) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(6, 1, __environ, environ_buf);
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              GROWABLE_HEAP_I32()[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(7, 1, penviron_count, penviron_buf_size);
          try {
            var strings = getEnvStrings();
            GROWABLE_HEAP_I32()[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            GROWABLE_HEAP_I32()[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_close(fd) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(8, 1, fd);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_read(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(9, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(10, 1, fd, offset_low, offset_high, whence, newOffset);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], GROWABLE_HEAP_I32()[newOffset >>> 2] = tempI64[0], GROWABLE_HEAP_I32()[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          if (ENVIRONMENT_IS_PTHREAD)
            return _emscripten_proxy_to_main_thread_js(11, 1, fd, iov, iovcnt, pnum);
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            GROWABLE_HEAP_I32()[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function spawnThread(threadParams) {
          if (ENVIRONMENT_IS_PTHREAD)
            throw "Internal Error! spawnThread() can only ever be called from main application thread!";
          var worker = PThread.getNewWorker();
          if (!worker) {
            return 6;
          }
          if (worker.pthread !== void 0)
            throw "Internal error!";
          if (!threadParams.pthread_ptr)
            throw "Internal error, no pthread ptr!";
          PThread.runningWorkers.push(worker);
          var tlsMemory = _malloc(128 * 4);
          for (var i = 0; i < 128; ++i) {
            GROWABLE_HEAP_I32()[tlsMemory + i * 4 >>> 2] = 0;
          }
          var stackHigh = threadParams.stackBase + threadParams.stackSize;
          var pthread = PThread.pthreads[threadParams.pthread_ptr] = { worker, stackBase: threadParams.stackBase, stackSize: threadParams.stackSize, allocatedOwnStack: threadParams.allocatedOwnStack, threadInfoStruct: threadParams.pthread_ptr };
          var tis = pthread.threadInfoStruct >> 2;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (64 >> 2), threadParams.detached);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (100 >> 2), tlsMemory);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (40 >> 2), pthread.threadInfoStruct);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (80 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (76 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 >> 2), threadParams.stackSize);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 8 >> 2), stackHigh);
          Atomics.store(GROWABLE_HEAP_U32(), tis + (104 + 12 >> 2), threadParams.detached);
          var global_libc = _emscripten_get_global_libc();
          var global_locale = global_libc + 40;
          Atomics.store(GROWABLE_HEAP_U32(), tis + (172 >> 2), global_locale);
          worker.pthread = pthread;
          var msg = { "cmd": "run", "start_routine": threadParams.startRoutine, "arg": threadParams.arg, "threadInfoStruct": threadParams.pthread_ptr, "stackBase": threadParams.stackBase, "stackSize": threadParams.stackSize };
          worker.runPthread = function() {
            msg.time = performance.now();
            worker.postMessage(msg, threadParams.transferList);
          };
          if (worker.loaded) {
            worker.runPthread();
            delete worker.runPthread;
          }
          return 0;
        }
        function _pthread_create(pthread_ptr, attr, start_routine, arg) {
          if (typeof SharedArrayBuffer === "undefined") {
            err("Current environment does not support SharedArrayBuffer, pthreads are not available!");
            return 6;
          }
          if (!pthread_ptr) {
            err("pthread_create called with a null thread pointer!");
            return 28;
          }
          var transferList = [];
          var error = 0;
          if (ENVIRONMENT_IS_PTHREAD && (transferList.length === 0 || error)) {
            return _emscripten_sync_run_in_main_thread_4(687865856, pthread_ptr, attr, start_routine, arg);
          }
          var stackSize = 0;
          var stackBase = 0;
          var detached = 0;
          if (attr && attr != -1) {
            stackSize = GROWABLE_HEAP_I32()[attr >>> 2];
            stackSize += 81920;
            stackBase = GROWABLE_HEAP_I32()[attr + 8 >>> 2];
            detached = GROWABLE_HEAP_I32()[attr + 12 >>> 2] !== 0;
          } else {
            stackSize = 2097152;
          }
          var allocatedOwnStack = stackBase == 0;
          if (allocatedOwnStack) {
            stackBase = _memalign(16, stackSize);
          } else {
            stackBase -= stackSize;
            assert(stackBase > 0);
          }
          var threadInfoStruct = _malloc(228);
          for (var i = 0; i < 228 >> 2; ++i)
            GROWABLE_HEAP_U32()[(threadInfoStruct >> 2) + i >>> 0] = 0;
          GROWABLE_HEAP_I32()[pthread_ptr >>> 2] = threadInfoStruct;
          GROWABLE_HEAP_I32()[threadInfoStruct + 12 >>> 2] = threadInfoStruct;
          var headPtr = threadInfoStruct + 152;
          GROWABLE_HEAP_I32()[headPtr >>> 2] = headPtr;
          var threadParams = { stackBase, stackSize, allocatedOwnStack, detached, startRoutine: start_routine, pthread_ptr: threadInfoStruct, arg, transferList };
          if (ENVIRONMENT_IS_PTHREAD) {
            threadParams.cmd = "spawnThread";
            postMessage(threadParams, transferList);
            return 0;
          }
          return spawnThread(threadParams);
        }
        function _setTempRet0(val) {
        }
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        function _strftime(s, maxsize, format, tm) {
          var tm_zone = GROWABLE_HEAP_I32()[tm + 40 >>> 2];
          var date = { tm_sec: GROWABLE_HEAP_I32()[tm >>> 2], tm_min: GROWABLE_HEAP_I32()[tm + 4 >>> 2], tm_hour: GROWABLE_HEAP_I32()[tm + 8 >>> 2], tm_mday: GROWABLE_HEAP_I32()[tm + 12 >>> 2], tm_mon: GROWABLE_HEAP_I32()[tm + 16 >>> 2], tm_year: GROWABLE_HEAP_I32()[tm + 20 >>> 2], tm_wday: GROWABLE_HEAP_I32()[tm + 24 >>> 2], tm_yday: GROWABLE_HEAP_I32()[tm + 28 >>> 2], tm_isdst: GROWABLE_HEAP_I32()[tm + 32 >>> 2], tm_gmtoff: GROWABLE_HEAP_I32()[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        function _strftime_l(s, maxsize, format, tm) {
          return _strftime(s, maxsize, format, tm);
        }
        if (!ENVIRONMENT_IS_PTHREAD)
          PThread.initMainThreadBlock();
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        var GLctx;
        var proxiedFunctionTable = [null, _atexit, ___sys_fcntl64, ___sys_ioctl, ___sys_open, _emscripten_set_canvas_element_size_main_thread, _environ_get, _environ_sizes_get, _fd_close, _fd_read, _fd_seek, _fd_write];
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var asmLibraryArg = { "l": ___assert_fail, "B": ___cxa_allocate_exception, "ka": ___cxa_thread_atexit, "A": ___cxa_throw, "D": ___sys_fcntl64, "V": ___sys_ioctl, "W": ___sys_open, "ma": __embind_finalize_value_array, "s": __embind_finalize_value_object, "O": __embind_register_bigint, "ia": __embind_register_bool, "v": __embind_register_class, "u": __embind_register_class_constructor, "c": __embind_register_class_function, "ha": __embind_register_emval, "la": __embind_register_enum, "y": __embind_register_enum_value, "J": __embind_register_float, "f": __embind_register_function, "p": __embind_register_integer, "k": __embind_register_memory_view, "K": __embind_register_std_string, "z": __embind_register_std_wstring, "na": __embind_register_value_array, "h": __embind_register_value_array_element, "t": __embind_register_value_object, "e": __embind_register_value_object_field, "ja": __embind_register_void, "ea": __emscripten_notify_thread_queue, "n": __emval_as, "L": __emval_call, "b": __emval_decref, "U": __emval_get_global, "o": __emval_get_property, "j": __emval_incref, "ca": __emval_instanceof, "M": __emval_is_number, "C": __emval_new_array, "g": __emval_new_cstring, "w": __emval_new_object, "m": __emval_run_destructors, "i": __emval_set_property, "d": __emval_take_value, "I": _abort, "T": _clock_gettime, "G": _emscripten_asm_const_int, "_": _emscripten_check_blocking_allowed, "F": _emscripten_conditional_set_current_thread_status, "r": _emscripten_futex_wait, "q": _emscripten_futex_wake, "x": _emscripten_get_now, "R": _emscripten_memcpy_big, "$": _emscripten_receive_on_main_thread_js, "S": _emscripten_resize_heap, "aa": _emscripten_set_canvas_element_size, "E": _emscripten_set_current_thread_status, "ba": _emscripten_webgl_create_context, "Y": _environ_get, "Z": _environ_sizes_get, "H": _fd_close, "ga": _fd_read, "N": _fd_seek, "fa": _fd_write, "Q": initPthreadsJS, "a": wasmMemory || Module["wasmMemory"], "da": _pthread_create, "P": _setTempRet0, "X": _strftime_l };
        createWasm();
        Module["___wasm_call_ctors"] = function() {
          return (Module["___wasm_call_ctors"] = Module["asm"]["oa"]).apply(null, arguments);
        };
        Module["_main"] = function() {
          return (Module["_main"] = Module["asm"]["pa"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["qa"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["ra"]).apply(null, arguments);
        };
        Module["_emscripten_tls_init"] = function() {
          return (Module["_emscripten_tls_init"] = Module["asm"]["sa"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ua"]).apply(null, arguments);
        };
        Module["___embind_register_native_and_builtin_types"] = function() {
          return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["va"]).apply(null, arguments);
        };
        Module["_emscripten_current_thread_process_queued_calls"] = function() {
          return (Module["_emscripten_current_thread_process_queued_calls"] = Module["asm"]["wa"]).apply(null, arguments);
        };
        var _emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = function() {
          return (_emscripten_register_main_browser_thread_id = Module["_emscripten_register_main_browser_thread_id"] = Module["asm"]["xa"]).apply(null, arguments);
        };
        var __emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = function() {
          return (__emscripten_do_dispatch_to_thread = Module["__emscripten_do_dispatch_to_thread"] = Module["asm"]["ya"]).apply(null, arguments);
        };
        var _emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = function() {
          return (_emscripten_sync_run_in_main_thread_4 = Module["_emscripten_sync_run_in_main_thread_4"] = Module["asm"]["za"]).apply(null, arguments);
        };
        var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
          return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["Aa"]).apply(null, arguments);
        };
        var _emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = function() {
          return (_emscripten_run_in_main_runtime_thread_js = Module["_emscripten_run_in_main_runtime_thread_js"] = Module["asm"]["Ba"]).apply(null, arguments);
        };
        var __emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = function() {
          return (__emscripten_call_on_thread = Module["__emscripten_call_on_thread"] = Module["asm"]["Ca"]).apply(null, arguments);
        };
        var __emscripten_thread_init = Module["__emscripten_thread_init"] = function() {
          return (__emscripten_thread_init = Module["__emscripten_thread_init"] = Module["asm"]["Da"]).apply(null, arguments);
        };
        var _emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = function() {
          return (_emscripten_get_global_libc = Module["_emscripten_get_global_libc"] = Module["asm"]["Ea"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["Fa"]).apply(null, arguments);
        };
        var _pthread_self = Module["_pthread_self"] = function() {
          return (_pthread_self = Module["_pthread_self"] = Module["asm"]["Ga"]).apply(null, arguments);
        };
        var ___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = function() {
          return (___pthread_tsd_run_dtors = Module["___pthread_tsd_run_dtors"] = Module["asm"]["Ha"]).apply(null, arguments);
        };
        var stackSave = Module["stackSave"] = function() {
          return (stackSave = Module["stackSave"] = Module["asm"]["Ia"]).apply(null, arguments);
        };
        var stackRestore = Module["stackRestore"] = function() {
          return (stackRestore = Module["stackRestore"] = Module["asm"]["Ja"]).apply(null, arguments);
        };
        var stackAlloc = Module["stackAlloc"] = function() {
          return (stackAlloc = Module["stackAlloc"] = Module["asm"]["Ka"]).apply(null, arguments);
        };
        var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
          return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["La"]).apply(null, arguments);
        };
        var _memalign = Module["_memalign"] = function() {
          return (_memalign = Module["_memalign"] = Module["asm"]["Ma"]).apply(null, arguments);
        };
        Module["dynCall_jiji"] = function() {
          return (Module["dynCall_jiji"] = Module["asm"]["Na"]).apply(null, arguments);
        };
        Module["dynCall_viijii"] = function() {
          return (Module["dynCall_viijii"] = Module["asm"]["Oa"]).apply(null, arguments);
        };
        Module["dynCall_iiiiij"] = function() {
          return (Module["dynCall_iiiiij"] = Module["asm"]["Pa"]).apply(null, arguments);
        };
        Module["dynCall_iiiiijj"] = function() {
          return (Module["dynCall_iiiiijj"] = Module["asm"]["Qa"]).apply(null, arguments);
        };
        Module["dynCall_iiiiiijj"] = function() {
          return (Module["dynCall_iiiiiijj"] = Module["asm"]["Ra"]).apply(null, arguments);
        };
        var __emscripten_allow_main_runtime_queued_calls = Module["__emscripten_allow_main_runtime_queued_calls"] = 44840;
        var __emscripten_main_thread_futex = Module["__emscripten_main_thread_futex"] = 48292;
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["keepRuntimeAlive"] = keepRuntimeAlive;
        Module["FS"] = FS;
        Module["PThread"] = PThread;
        Module["PThread"] = PThread;
        Module["wasmMemory"] = wasmMemory;
        Module["ExitStatus"] = ExitStatus;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
          }
        }
        function run(args) {
          if (runDependencies > 0) {
            return;
          }
          if (ENVIRONMENT_IS_PTHREAD) {
            readyPromiseResolve(Module);
            initRuntime();
            postMessage({ "cmd": "loaded" });
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        function exit(status, implicit) {
          if (!implicit) {
            if (ENVIRONMENT_IS_PTHREAD) {
              postMessage({ "cmd": "exitProcess", "returnCode": status });
              throw new ExitStatus(status);
            }
          }
          if (keepRuntimeAlive()) ; else {
            PThread.terminateAllThreads();
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        if (ENVIRONMENT_IS_PTHREAD) {
          noExitRuntime = false;
          PThread.initWorker();
        }
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});

// dist/web-ifc.js
var require_web_ifc = __commonJS({
  "dist/web-ifc.js"(exports, module) {
    var WebIFCWasm2 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(WebIFCWasm3) {
        WebIFCWasm3 = WebIFCWasm3 || {};
        var Module = typeof WebIFCWasm3 !== "undefined" ? WebIFCWasm3 : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function(resolve, reject) {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
          if (Module.hasOwnProperty(key)) {
            moduleOverrides[key] = Module[key];
          }
        }
        var thisProgram = "./this.program";
        var quit_ = function(status, toThrow) {
          throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" && typeof process.versions === "object" && typeof process.versions.node === "string";
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var read_, readAsync, readBinary;
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = __require("path").dirname(scriptDirectory) + "/";
          } else {
            scriptDirectory = __dirname + "/";
          }
          read_ = function shell_read(filename, binary) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            return nodeFS["readFileSync"](filename, binary ? null : "utf8");
          };
          readBinary = function readBinary2(filename) {
            var ret = read_(filename, true);
            if (!ret.buffer) {
              ret = new Uint8Array(ret);
            }
            assert(ret.buffer);
            return ret;
          };
          readAsync = function readAsync2(filename, onload, onerror) {
            if (!nodeFS)
              nodeFS = __require("fs");
            if (!nodePath)
              nodePath = __require("path");
            filename = nodePath["normalize"](filename);
            nodeFS["readFile"](filename, function(err2, data) {
              if (err2)
                onerror(err2);
              else
                onload(data.buffer);
            });
          };
          if (process["argv"].length > 1) {
            thisProgram = process["argv"][1].replace(/\\/g, "/");
          }
          process["argv"].slice(2);
          process["on"]("uncaughtException", function(ex) {
            if (!(ex instanceof ExitStatus)) {
              throw ex;
            }
          });
          process["on"]("unhandledRejection", abort);
          quit_ = function(status, toThrow) {
            if (keepRuntimeAlive()) {
              process["exitCode"] = status;
              throw toThrow;
            }
            process["exit"](status);
          };
          Module["inspect"] = function() {
            return "[Emscripten Module object]";
          };
        } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
          if (ENVIRONMENT_IS_WORKER) {
            scriptDirectory = self.location.href;
          } else if (typeof document !== "undefined" && document.currentScript) {
            scriptDirectory = document.currentScript.src;
          }
          if (_scriptDir) {
            scriptDirectory = _scriptDir;
          }
          if (scriptDirectory.indexOf("blob:") !== 0) {
            scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1);
          } else {
            scriptDirectory = "";
          }
          {
            read_ = function(url) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.send(null);
              return xhr.responseText;
            };
            if (ENVIRONMENT_IS_WORKER) {
              readBinary = function(url) {
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, false);
                xhr.responseType = "arraybuffer";
                xhr.send(null);
                return new Uint8Array(xhr.response);
              };
            }
            readAsync = function(url, onload, onerror) {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, true);
              xhr.responseType = "arraybuffer";
              xhr.onload = function() {
                if (xhr.status == 200 || xhr.status == 0 && xhr.response) {
                  onload(xhr.response);
                  return;
                }
                onerror();
              };
              xhr.onerror = onerror;
              xhr.send(null);
            };
          }
        } else ;
        var out = Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
          if (moduleOverrides.hasOwnProperty(key)) {
            Module[key] = moduleOverrides[key];
          }
        }
        moduleOverrides = null;
        if (Module["arguments"])
          Module["arguments"];
        if (Module["thisProgram"])
          thisProgram = Module["thisProgram"];
        if (Module["quit"])
          quit_ = Module["quit"];
        var wasmBinary;
        if (Module["wasmBinary"])
          wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
          abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed: " + text);
          }
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : void 0;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
          idx >>>= 0;
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heap[endPtr >>> 0] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
            return UTF8Decoder.decode(heap.subarray(idx >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            while (idx < endPtr) {
              var u0 = heap[idx++ >>> 0];
              if (!(u0 & 128)) {
                str += String.fromCharCode(u0);
                continue;
              }
              var u1 = heap[idx++ >>> 0] & 63;
              if ((u0 & 224) == 192) {
                str += String.fromCharCode((u0 & 31) << 6 | u1);
                continue;
              }
              var u2 = heap[idx++ >>> 0] & 63;
              if ((u0 & 240) == 224) {
                u0 = (u0 & 15) << 12 | u1 << 6 | u2;
              } else {
                u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heap[idx++ >>> 0] & 63;
              }
              if (u0 < 65536) {
                str += String.fromCharCode(u0);
              } else {
                var ch = u0 - 65536;
                str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
              }
            }
          }
          return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
          ptr >>>= 0;
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
          outIdx >>>= 0;
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++ >>> 0] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 192 | u >> 6;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 224 | u >> 12;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              heap[outIdx++ >>> 0] = 240 | u >> 18;
              heap[outIdx++ >>> 0] = 128 | u >> 12 & 63;
              heap[outIdx++ >>> 0] = 128 | u >> 6 & 63;
              heap[outIdx++ >>> 0] = 128 | u & 63;
            }
          }
          heap[outIdx >>> 0] = 0;
          return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343)
              u = 65536 + ((u & 1023) << 10) | str.charCodeAt(++i) & 1023;
            if (u <= 127)
              ++len;
            else if (u <= 2047)
              len += 2;
            else if (u <= 65535)
              len += 3;
            else
              len += 4;
          }
          return len;
        }
        var UTF16Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-16le") : void 0;
        function UTF16ToString(ptr, maxBytesToRead) {
          var endPtr = ptr;
          var idx = endPtr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          while (!(idx >= maxIdx) && HEAPU16[idx >>> 0])
            ++idx;
          endPtr = idx << 1;
          if (endPtr - ptr > 32 && UTF16Decoder) {
            return UTF16Decoder.decode(HEAPU8.subarray(ptr >>> 0, endPtr >>> 0));
          } else {
            var str = "";
            for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
              var codeUnit = HEAP16[ptr + i * 2 >>> 1];
              if (codeUnit == 0)
                break;
              str += String.fromCharCode(codeUnit);
            }
            return str;
          }
        }
        function stringToUTF16(str, outPtr, maxBytesToWrite) {
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >>> 1] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >>> 1] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF16(str) {
          return str.length * 2;
        }
        function UTF32ToString(ptr, maxBytesToRead) {
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >>> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        }
        function stringToUTF32(str, outPtr, maxBytesToWrite) {
          outPtr >>>= 0;
          if (maxBytesToWrite === void 0) {
            maxBytesToWrite = 2147483647;
          }
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >>> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >>> 2] = 0;
          return outPtr - startPtr;
        }
        function lengthBytesUTF32(str) {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        }
        function writeArrayToMemory(array, buffer2) {
          HEAP8.set(array, buffer2 >>> 0);
        }
        function writeAsciiToMemory(str, buffer2, dontAddNull) {
          for (var i = 0; i < str.length; ++i) {
            HEAP8[buffer2++ >>> 0] = str.charCodeAt(i);
          }
          if (!dontAddNull)
            HEAP8[buffer2 >>> 0] = 0;
        }
        function alignUp(x, multiple) {
          if (x % multiple > 0) {
            x += multiple - x % multiple;
          }
          return x;
        }
        var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
        function updateGlobalBufferAndViews(buf) {
          buffer = buf;
          Module["HEAP8"] = HEAP8 = new Int8Array(buf);
          Module["HEAP16"] = HEAP16 = new Int16Array(buf);
          Module["HEAP32"] = HEAP32 = new Int32Array(buf);
          Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
          Module["HEAPU16"] = HEAPU16 = new Uint16Array(buf);
          Module["HEAPU32"] = HEAPU32 = new Uint32Array(buf);
          Module["HEAPF32"] = HEAPF32 = new Float32Array(buf);
          Module["HEAPF64"] = HEAPF64 = new Float64Array(buf);
        }
        Module["INITIAL_MEMORY"] || 16777216;
        var wasmTable;
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
          return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
          if (!Module["noFSInit"] && !FS.init.initialized)
            FS.init();
          FS.ignorePermissions = false;
          callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
          callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
          __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
          __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
          __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        function getUniqueRunDependency(id) {
          return id;
        }
        function addRunDependency(id) {
          runDependencies++;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
        }
        function removeRunDependency(id) {
          runDependencies--;
          if (Module["monitorRunDependencies"]) {
            Module["monitorRunDependencies"](runDependencies);
          }
          if (runDependencies == 0) {
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        function abort(what) {
          if (Module["onAbort"]) {
            Module["onAbort"](what);
          }
          what += "";
          err(what);
          ABORT = true;
          what = "abort(" + what + "). Build with -s ASSERTIONS=1 for more info.";
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
          return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
          return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "web-ifc.wasm";
        if (!isDataURI(wasmBinaryFile)) {
          wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
          try {
            if (file == wasmBinaryFile && wasmBinary) {
              return new Uint8Array(wasmBinary);
            }
            if (readBinary) {
              return readBinary(file);
            } else {
              throw "both async and sync fetching of the wasm failed";
            }
          } catch (err2) {
            abort(err2);
          }
        }
        function getBinaryPromise() {
          if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
            if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                if (!response["ok"]) {
                  throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
                }
                return response["arrayBuffer"]();
              }).catch(function() {
                return getBinary(wasmBinaryFile);
              });
            } else {
              if (readAsync) {
                return new Promise(function(resolve, reject) {
                  readAsync(wasmBinaryFile, function(response) {
                    resolve(new Uint8Array(response));
                  }, reject);
                });
              }
            }
          }
          return Promise.resolve().then(function() {
            return getBinary(wasmBinaryFile);
          });
        }
        function createWasm() {
          var info = { "a": asmLibraryArg };
          function receiveInstance(instance, module2) {
            var exports3 = instance.exports;
            Module["asm"] = exports3;
            wasmMemory = Module["asm"]["$"];
            updateGlobalBufferAndViews(wasmMemory.buffer);
            wasmTable = Module["asm"]["ha"];
            addOnInit(Module["asm"]["aa"]);
            removeRunDependency();
          }
          addRunDependency();
          function receiveInstantiationResult(result) {
            receiveInstance(result["instance"]);
          }
          function instantiateArrayBuffer(receiver) {
            return getBinaryPromise().then(function(binary) {
              var result = WebAssembly.instantiate(binary, info);
              return result;
            }).then(receiver, function(reason) {
              err("failed to asynchronously prepare wasm: " + reason);
              abort(reason);
            });
          }
          function instantiateAsync() {
            if (!wasmBinary && typeof WebAssembly.instantiateStreaming === "function" && !isDataURI(wasmBinaryFile) && !isFileURI(wasmBinaryFile) && typeof fetch === "function") {
              return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function(response) {
                var result = WebAssembly.instantiateStreaming(response, info);
                return result.then(receiveInstantiationResult, function(reason) {
                  err("wasm streaming compile failed: " + reason);
                  err("falling back to ArrayBuffer instantiation");
                  return instantiateArrayBuffer(receiveInstantiationResult);
                });
              });
            } else {
              return instantiateArrayBuffer(receiveInstantiationResult);
            }
          }
          if (Module["instantiateWasm"]) {
            try {
              var exports2 = Module["instantiateWasm"](info, receiveInstance);
              return exports2;
            } catch (e) {
              err("Module.instantiateWasm callback failed with error: " + e);
              return false;
            }
          }
          instantiateAsync().catch(readyPromiseReject);
          return {};
        }
        var tempDouble;
        var tempI64;
        function callRuntimeCallbacks(callbacks) {
          while (callbacks.length > 0) {
            var callback = callbacks.shift();
            if (typeof callback == "function") {
              callback(Module);
              continue;
            }
            var func = callback.func;
            if (typeof func === "number") {
              if (callback.arg === void 0) {
                wasmTable.get(func)();
              } else {
                wasmTable.get(func)(callback.arg);
              }
            } else {
              func(callback.arg === void 0 ? null : callback.arg);
            }
          }
        }
        function ___assert_fail(condition, filename, line, func) {
          abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        }
        function ___cxa_allocate_exception(size) {
          return _malloc(size + 16) + 16;
        }
        function ExceptionInfo(excPtr) {
          this.excPtr = excPtr;
          this.ptr = excPtr - 16;
          this.set_type = function(type) {
            HEAP32[this.ptr + 4 >>> 2] = type;
          };
          this.get_type = function() {
            return HEAP32[this.ptr + 4 >>> 2];
          };
          this.set_destructor = function(destructor) {
            HEAP32[this.ptr + 8 >>> 2] = destructor;
          };
          this.get_destructor = function() {
            return HEAP32[this.ptr + 8 >>> 2];
          };
          this.set_refcount = function(refcount) {
            HEAP32[this.ptr >>> 2] = refcount;
          };
          this.set_caught = function(caught) {
            caught = caught ? 1 : 0;
            HEAP8[this.ptr + 12 >>> 0] = caught;
          };
          this.get_caught = function() {
            return HEAP8[this.ptr + 12 >>> 0] != 0;
          };
          this.set_rethrown = function(rethrown) {
            rethrown = rethrown ? 1 : 0;
            HEAP8[this.ptr + 13 >>> 0] = rethrown;
          };
          this.get_rethrown = function() {
            return HEAP8[this.ptr + 13 >>> 0] != 0;
          };
          this.init = function(type, destructor) {
            this.set_type(type);
            this.set_destructor(destructor);
            this.set_refcount(0);
            this.set_caught(false);
            this.set_rethrown(false);
          };
          this.add_ref = function() {
            var value = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = value + 1;
          };
          this.release_ref = function() {
            var prev = HEAP32[this.ptr >>> 2];
            HEAP32[this.ptr >>> 2] = prev - 1;
            return prev === 1;
          };
        }
        function ___cxa_throw(ptr, type, destructor) {
          var info = new ExceptionInfo(ptr);
          info.init(type, destructor);
          throw ptr;
        }
        function setErrNo(value) {
          HEAP32[___errno_location() >>> 2] = value;
          return value;
        }
        var PATH = { splitPath: function(filename) {
          var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
          return splitPathRe.exec(filename).slice(1);
        }, normalizeArray: function(parts, allowAboveRoot) {
          var up = 0;
          for (var i = parts.length - 1; i >= 0; i--) {
            var last = parts[i];
            if (last === ".") {
              parts.splice(i, 1);
            } else if (last === "..") {
              parts.splice(i, 1);
              up++;
            } else if (up) {
              parts.splice(i, 1);
              up--;
            }
          }
          if (allowAboveRoot) {
            for (; up; up--) {
              parts.unshift("..");
            }
          }
          return parts;
        }, normalize: function(path) {
          var isAbsolute = path.charAt(0) === "/", trailingSlash = path.substr(-1) === "/";
          path = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), !isAbsolute).join("/");
          if (!path && !isAbsolute) {
            path = ".";
          }
          if (path && trailingSlash) {
            path += "/";
          }
          return (isAbsolute ? "/" : "") + path;
        }, dirname: function(path) {
          var result = PATH.splitPath(path), root = result[0], dir = result[1];
          if (!root && !dir) {
            return ".";
          }
          if (dir) {
            dir = dir.substr(0, dir.length - 1);
          }
          return root + dir;
        }, basename: function(path) {
          if (path === "/")
            return "/";
          path = PATH.normalize(path);
          path = path.replace(/\/$/, "");
          var lastSlash = path.lastIndexOf("/");
          if (lastSlash === -1)
            return path;
          return path.substr(lastSlash + 1);
        }, extname: function(path) {
          return PATH.splitPath(path)[3];
        }, join: function() {
          var paths = Array.prototype.slice.call(arguments, 0);
          return PATH.normalize(paths.join("/"));
        }, join2: function(l, r) {
          return PATH.normalize(l + "/" + r);
        } };
        function getRandomDevice() {
          if (typeof crypto === "object" && typeof crypto["getRandomValues"] === "function") {
            var randomBuffer = new Uint8Array(1);
            return function() {
              crypto.getRandomValues(randomBuffer);
              return randomBuffer[0];
            };
          } else if (ENVIRONMENT_IS_NODE) {
            try {
              var crypto_module = require_crypto();
              return function() {
                return crypto_module["randomBytes"](1)[0];
              };
            } catch (e) {
            }
          }
          return function() {
            abort("randomDevice");
          };
        }
        var PATH_FS = { resolve: function() {
          var resolvedPath = "", resolvedAbsolute = false;
          for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
            var path = i >= 0 ? arguments[i] : FS.cwd();
            if (typeof path !== "string") {
              throw new TypeError("Arguments to path.resolve must be strings");
            } else if (!path) {
              return "";
            }
            resolvedPath = path + "/" + resolvedPath;
            resolvedAbsolute = path.charAt(0) === "/";
          }
          resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter(function(p) {
            return !!p;
          }), !resolvedAbsolute).join("/");
          return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
        }, relative: function(from, to) {
          from = PATH_FS.resolve(from).substr(1);
          to = PATH_FS.resolve(to).substr(1);
          function trim(arr) {
            var start = 0;
            for (; start < arr.length; start++) {
              if (arr[start] !== "")
                break;
            }
            var end = arr.length - 1;
            for (; end >= 0; end--) {
              if (arr[end] !== "")
                break;
            }
            if (start > end)
              return [];
            return arr.slice(start, end - start + 1);
          }
          var fromParts = trim(from.split("/"));
          var toParts = trim(to.split("/"));
          var length = Math.min(fromParts.length, toParts.length);
          var samePartsLength = length;
          for (var i = 0; i < length; i++) {
            if (fromParts[i] !== toParts[i]) {
              samePartsLength = i;
              break;
            }
          }
          var outputParts = [];
          for (var i = samePartsLength; i < fromParts.length; i++) {
            outputParts.push("..");
          }
          outputParts = outputParts.concat(toParts.slice(samePartsLength));
          return outputParts.join("/");
        } };
        var TTY = { ttys: [], init: function() {
        }, shutdown: function() {
        }, register: function(dev, ops) {
          TTY.ttys[dev] = { input: [], output: [], ops };
          FS.registerDevice(dev, TTY.stream_ops);
        }, stream_ops: { open: function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        }, close: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, flush: function(stream) {
          stream.tty.ops.flush(stream.tty);
        }, read: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0)
              break;
            bytesRead++;
            buffer2[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer2[offset + i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } }, default_tty_ops: { get_char: function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch (e) {
                if (e.toString().includes("EOF"))
                  bytesRead = 0;
                else
                  throw e;
              }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString("utf-8");
              } else {
                result = null;
              }
            } else if (typeof window != "undefined" && typeof window.prompt == "function") {
              result = window.prompt("Input: ");
              if (result !== null) {
                result += "\n";
              }
            } else if (typeof readline == "function") {
              result = readline();
              if (result !== null) {
                result += "\n";
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        }, put_char: function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } }, default_tty1_ops: { put_char: function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0)
              tty.output.push(val);
          }
        }, flush: function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        } } };
        function mmapAlloc(size) {
          abort();
        }
        var MEMFS = { ops_table: null, mount: function(mount) {
          return MEMFS.createNode(null, "/", 16384 | 511, 0);
        }, createNode: function(parent, name2, mode, dev) {
          if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
            throw new FS.ErrnoError(63);
          }
          if (!MEMFS.ops_table) {
            MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } };
          }
          var node = FS.createNode(parent, name2, mode, dev);
          if (FS.isDir(node.mode)) {
            node.node_ops = MEMFS.ops_table.dir.node;
            node.stream_ops = MEMFS.ops_table.dir.stream;
            node.contents = {};
          } else if (FS.isFile(node.mode)) {
            node.node_ops = MEMFS.ops_table.file.node;
            node.stream_ops = MEMFS.ops_table.file.stream;
            node.usedBytes = 0;
            node.contents = null;
          } else if (FS.isLink(node.mode)) {
            node.node_ops = MEMFS.ops_table.link.node;
            node.stream_ops = MEMFS.ops_table.link.stream;
          } else if (FS.isChrdev(node.mode)) {
            node.node_ops = MEMFS.ops_table.chrdev.node;
            node.stream_ops = MEMFS.ops_table.chrdev.stream;
          }
          node.timestamp = Date.now();
          if (parent) {
            parent.contents[name2] = node;
            parent.timestamp = node.timestamp;
          }
          return node;
        }, getFileDataAsTypedArray: function(node) {
          if (!node.contents)
            return new Uint8Array(0);
          if (node.contents.subarray)
            return node.contents.subarray(0, node.usedBytes);
          return new Uint8Array(node.contents);
        }, expandFileStorage: function(node, newCapacity) {
          newCapacity >>>= 0;
          var prevCapacity = node.contents ? node.contents.length : 0;
          if (prevCapacity >= newCapacity)
            return;
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
          if (prevCapacity != 0)
            newCapacity = Math.max(newCapacity, 256);
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity);
          if (node.usedBytes > 0)
            node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
        }, resizeFileStorage: function(node, newSize) {
          newSize >>>= 0;
          if (node.usedBytes == newSize)
            return;
          if (newSize == 0) {
            node.contents = null;
            node.usedBytes = 0;
          } else {
            var oldContents = node.contents;
            node.contents = new Uint8Array(newSize);
            if (oldContents) {
              node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
            }
            node.usedBytes = newSize;
          }
        }, node_ops: { getattr: function(node) {
          var attr = {};
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        }, setattr: function(node, attr) {
          if (attr.mode !== void 0) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== void 0) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== void 0) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        }, lookup: function(parent, name2) {
          throw FS.genericErrors[44];
        }, mknod: function(parent, name2, mode, dev) {
          return MEMFS.createNode(parent, name2, mode, dev);
        }, rename: function(old_node, new_dir, new_name) {
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now();
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        }, unlink: function(parent, name2) {
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, rmdir: function(parent, name2) {
          var node = FS.lookupNode(parent, name2);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name2];
          parent.timestamp = Date.now();
        }, readdir: function(node) {
          var entries = [".", ".."];
          for (var key2 in node.contents) {
            if (!node.contents.hasOwnProperty(key2)) {
              continue;
            }
            entries.push(key2);
          }
          return entries;
        }, symlink: function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
          node.link = oldpath;
          return node;
        }, readlink: function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        } }, stream_ops: { read: function(stream, buffer2, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes)
            return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) {
            buffer2.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++)
              buffer2[offset + i] = contents[position + i];
          }
          return size;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          if (buffer2.buffer === HEAP8.buffer) {
            canOwn = false;
          }
          if (!length)
            return 0;
          var node = stream.node;
          node.timestamp = Date.now();
          if (buffer2.subarray && (!node.contents || node.contents.subarray)) {
            if (canOwn) {
              node.contents = buffer2.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) {
              node.contents = buffer2.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) {
              node.contents.set(buffer2.subarray(offset, offset + length), position);
              return length;
            }
          }
          MEMFS.expandFileStorage(node, position + length);
          if (node.contents.subarray && buffer2.subarray) {
            node.contents.set(buffer2.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
              node.contents[position + i] = buffer2[offset + i];
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        }, llseek: function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        }, allocate: function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          if (!(flags & 2) && contents.buffer === buffer) {
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc();
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            ptr >>>= 0;
            HEAP8.set(contents, ptr >>> 0);
          }
          return { ptr, allocated };
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            return 0;
          }
          MEMFS.stream_ops.write(stream, buffer2, 0, length, offset, false);
          return 0;
        } } };
        function asyncLoad(url, onload, onerror, noRunDep) {
          var dep = !noRunDep ? getUniqueRunDependency("al " + url) : "";
          readAsync(url, function(arrayBuffer) {
            assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
            onload(new Uint8Array(arrayBuffer));
            if (dep)
              removeRunDependency();
          }, function(event) {
            if (onerror) {
              onerror();
            } else {
              throw 'Loading data file "' + url + '" failed.';
            }
          });
          if (dep)
            addRunDependency();
        }
        var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, lookupPath: function(path, opts) {
          path = PATH_FS.resolve(FS.cwd(), path);
          opts = opts || {};
          if (!path)
            return { path: "", node: null };
          var defaults = { follow_mount: true, recurse_count: 0 };
          for (var key2 in defaults) {
            if (opts[key2] === void 0) {
              opts[key2] = defaults[key2];
            }
          }
          if (opts.recurse_count > 8) {
            throw new FS.ErrnoError(32);
          }
          var parts = PATH.normalizeArray(path.split("/").filter(function(p) {
            return !!p;
          }), false);
          var current = FS.root;
          var current_path = "/";
          for (var i = 0; i < parts.length; i++) {
            var islast = i === parts.length - 1;
            if (islast && opts.parent) {
              break;
            }
            current = FS.lookupNode(current, parts[i]);
            current_path = PATH.join2(current_path, parts[i]);
            if (FS.isMountpoint(current)) {
              if (!islast || islast && opts.follow_mount) {
                current = current.mounted.root;
              }
            }
            if (!islast || opts.follow) {
              var count = 0;
              while (FS.isLink(current.mode)) {
                var link = FS.readlink(current_path);
                current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
                var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
                current = lookup.node;
                if (count++ > 40) {
                  throw new FS.ErrnoError(32);
                }
              }
            }
          }
          return { path: current_path, node: current };
        }, getPath: function(node) {
          var path;
          while (true) {
            if (FS.isRoot(node)) {
              var mount = node.mount.mountpoint;
              if (!path)
                return mount;
              return mount[mount.length - 1] !== "/" ? mount + "/" + path : mount + path;
            }
            path = path ? node.name + "/" + path : node.name;
            node = node.parent;
          }
        }, hashName: function(parentid, name2) {
          var hash = 0;
          for (var i = 0; i < name2.length; i++) {
            hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
          }
          return (parentid + hash >>> 0) % FS.nameTable.length;
        }, hashAddNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          node.name_next = FS.nameTable[hash];
          FS.nameTable[hash] = node;
        }, hashRemoveNode: function(node) {
          var hash = FS.hashName(node.parent.id, node.name);
          if (FS.nameTable[hash] === node) {
            FS.nameTable[hash] = node.name_next;
          } else {
            var current = FS.nameTable[hash];
            while (current) {
              if (current.name_next === node) {
                current.name_next = node.name_next;
                break;
              }
              current = current.name_next;
            }
          }
        }, lookupNode: function(parent, name2) {
          var errCode = FS.mayLookup(parent);
          if (errCode) {
            throw new FS.ErrnoError(errCode, parent);
          }
          var hash = FS.hashName(parent.id, name2);
          for (var node = FS.nameTable[hash]; node; node = node.name_next) {
            var nodeName = node.name;
            if (node.parent.id === parent.id && nodeName === name2) {
              return node;
            }
          }
          return FS.lookup(parent, name2);
        }, createNode: function(parent, name2, mode, rdev) {
          var node = new FS.FSNode(parent, name2, mode, rdev);
          FS.hashAddNode(node);
          return node;
        }, destroyNode: function(node) {
          FS.hashRemoveNode(node);
        }, isRoot: function(node) {
          return node === node.parent;
        }, isMountpoint: function(node) {
          return !!node.mounted;
        }, isFile: function(mode) {
          return (mode & 61440) === 32768;
        }, isDir: function(mode) {
          return (mode & 61440) === 16384;
        }, isLink: function(mode) {
          return (mode & 61440) === 40960;
        }, isChrdev: function(mode) {
          return (mode & 61440) === 8192;
        }, isBlkdev: function(mode) {
          return (mode & 61440) === 24576;
        }, isFIFO: function(mode) {
          return (mode & 61440) === 4096;
        }, isSocket: function(mode) {
          return (mode & 49152) === 49152;
        }, flagModes: { "r": 0, "r+": 2, "w": 577, "w+": 578, "a": 1089, "a+": 1090 }, modeStringToFlags: function(str) {
          var flags = FS.flagModes[str];
          if (typeof flags === "undefined") {
            throw new Error("Unknown file open mode: " + str);
          }
          return flags;
        }, flagsToPermissionString: function(flag) {
          var perms = ["r", "w", "rw"][flag & 3];
          if (flag & 512) {
            perms += "w";
          }
          return perms;
        }, nodePermissions: function(node, perms) {
          if (FS.ignorePermissions) {
            return 0;
          }
          if (perms.includes("r") && !(node.mode & 292)) {
            return 2;
          } else if (perms.includes("w") && !(node.mode & 146)) {
            return 2;
          } else if (perms.includes("x") && !(node.mode & 73)) {
            return 2;
          }
          return 0;
        }, mayLookup: function(dir) {
          var errCode = FS.nodePermissions(dir, "x");
          if (errCode)
            return errCode;
          if (!dir.node_ops.lookup)
            return 2;
          return 0;
        }, mayCreate: function(dir, name2) {
          try {
            var node = FS.lookupNode(dir, name2);
            return 20;
          } catch (e) {
          }
          return FS.nodePermissions(dir, "wx");
        }, mayDelete: function(dir, name2, isdir) {
          var node;
          try {
            node = FS.lookupNode(dir, name2);
          } catch (e) {
            return e.errno;
          }
          var errCode = FS.nodePermissions(dir, "wx");
          if (errCode) {
            return errCode;
          }
          if (isdir) {
            if (!FS.isDir(node.mode)) {
              return 54;
            }
            if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
              return 10;
            }
          } else {
            if (FS.isDir(node.mode)) {
              return 31;
            }
          }
          return 0;
        }, mayOpen: function(node, flags) {
          if (!node) {
            return 44;
          }
          if (FS.isLink(node.mode)) {
            return 32;
          } else if (FS.isDir(node.mode)) {
            if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
              return 31;
            }
          }
          return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
        }, MAX_OPEN_FDS: 4096, nextfd: function(fd_start, fd_end) {
          fd_start = fd_start || 0;
          fd_end = fd_end || FS.MAX_OPEN_FDS;
          for (var fd = fd_start; fd <= fd_end; fd++) {
            if (!FS.streams[fd]) {
              return fd;
            }
          }
          throw new FS.ErrnoError(33);
        }, getStream: function(fd) {
          return FS.streams[fd];
        }, createStream: function(stream, fd_start, fd_end) {
          if (!FS.FSStream) {
            FS.FSStream = function() {
            };
            FS.FSStream.prototype = { object: { get: function() {
              return this.node;
            }, set: function(val) {
              this.node = val;
            } }, isRead: { get: function() {
              return (this.flags & 2097155) !== 1;
            } }, isWrite: { get: function() {
              return (this.flags & 2097155) !== 0;
            } }, isAppend: { get: function() {
              return this.flags & 1024;
            } } };
          }
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
          var fd = FS.nextfd(fd_start, fd_end);
          stream.fd = fd;
          FS.streams[fd] = stream;
          return stream;
        }, closeStream: function(fd) {
          FS.streams[fd] = null;
        }, chrdev_stream_ops: { open: function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          stream.stream_ops = device.stream_ops;
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        }, llseek: function() {
          throw new FS.ErrnoError(70);
        } }, major: function(dev) {
          return dev >> 8;
        }, minor: function(dev) {
          return dev & 255;
        }, makedev: function(ma, mi) {
          return ma << 8 | mi;
        }, registerDevice: function(dev, ops) {
          FS.devices[dev] = { stream_ops: ops };
        }, getDevice: function(dev) {
          return FS.devices[dev];
        }, getMounts: function(mount) {
          var mounts = [];
          var check = [mount];
          while (check.length) {
            var m = check.pop();
            mounts.push(m);
            check.push.apply(check, m.mounts);
          }
          return mounts;
        }, syncfs: function(populate, callback) {
          if (typeof populate === "function") {
            callback = populate;
            populate = false;
          }
          FS.syncFSRequests++;
          if (FS.syncFSRequests > 1) {
            err("warning: " + FS.syncFSRequests + " FS.syncfs operations in flight at once, probably just doing extra work");
          }
          var mounts = FS.getMounts(FS.root.mount);
          var completed = 0;
          function doCallback(errCode) {
            FS.syncFSRequests--;
            return callback(errCode);
          }
          function done(errCode) {
            if (errCode) {
              if (!done.errored) {
                done.errored = true;
                return doCallback(errCode);
              }
              return;
            }
            if (++completed >= mounts.length) {
              doCallback(null);
            }
          }
          mounts.forEach(function(mount) {
            if (!mount.type.syncfs) {
              return done(null);
            }
            mount.type.syncfs(mount, populate, done);
          });
        }, mount: function(type, opts, mountpoint) {
          var root = mountpoint === "/";
          var pseudo = !mountpoint;
          var node;
          if (root && FS.root) {
            throw new FS.ErrnoError(10);
          } else if (!root && !pseudo) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            mountpoint = lookup.path;
            node = lookup.node;
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            if (!FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
          }
          var mount = { type, opts, mountpoint, mounts: [] };
          var mountRoot = type.mount(mount);
          mountRoot.mount = mount;
          mount.root = mountRoot;
          if (root) {
            FS.root = mountRoot;
          } else if (node) {
            node.mounted = mount;
            if (node.mount) {
              node.mount.mounts.push(mount);
            }
          }
          return mountRoot;
        }, unmount: function(mountpoint) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          if (!FS.isMountpoint(lookup.node)) {
            throw new FS.ErrnoError(28);
          }
          var node = lookup.node;
          var mount = node.mounted;
          var mounts = FS.getMounts(mount);
          Object.keys(FS.nameTable).forEach(function(hash) {
            var current = FS.nameTable[hash];
            while (current) {
              var next = current.name_next;
              if (mounts.includes(current.mount)) {
                FS.destroyNode(current);
              }
              current = next;
            }
          });
          node.mounted = null;
          var idx = node.mount.mounts.indexOf(mount);
          node.mount.mounts.splice(idx, 1);
        }, lookup: function(parent, name2) {
          return parent.node_ops.lookup(parent, name2);
        }, mknod: function(path, mode, dev) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          if (!name2 || name2 === "." || name2 === "..") {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.mayCreate(parent, name2);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.mknod) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.mknod(parent, name2, mode, dev);
        }, create: function(path, mode) {
          mode = mode !== void 0 ? mode : 438;
          mode &= 4095;
          mode |= 32768;
          return FS.mknod(path, mode, 0);
        }, mkdir: function(path, mode) {
          mode = mode !== void 0 ? mode : 511;
          mode &= 511 | 512;
          mode |= 16384;
          return FS.mknod(path, mode, 0);
        }, mkdirTree: function(path, mode) {
          var dirs = path.split("/");
          var d = "";
          for (var i = 0; i < dirs.length; ++i) {
            if (!dirs[i])
              continue;
            d += "/" + dirs[i];
            try {
              FS.mkdir(d, mode);
            } catch (e) {
              if (e.errno != 20)
                throw e;
            }
          }
        }, mkdev: function(path, mode, dev) {
          if (typeof dev === "undefined") {
            dev = mode;
            mode = 438;
          }
          mode |= 8192;
          return FS.mknod(path, mode, dev);
        }, symlink: function(oldpath, newpath) {
          if (!PATH_FS.resolve(oldpath)) {
            throw new FS.ErrnoError(44);
          }
          var lookup = FS.lookupPath(newpath, { parent: true });
          var parent = lookup.node;
          if (!parent) {
            throw new FS.ErrnoError(44);
          }
          var newname = PATH.basename(newpath);
          var errCode = FS.mayCreate(parent, newname);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.symlink) {
            throw new FS.ErrnoError(63);
          }
          return parent.node_ops.symlink(parent, newname, oldpath);
        }, rename: function(old_path, new_path) {
          var old_dirname = PATH.dirname(old_path);
          var new_dirname = PATH.dirname(new_path);
          var old_name = PATH.basename(old_path);
          var new_name = PATH.basename(new_path);
          var lookup, old_dir, new_dir;
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
          if (!old_dir || !new_dir)
            throw new FS.ErrnoError(44);
          if (old_dir.mount !== new_dir.mount) {
            throw new FS.ErrnoError(75);
          }
          var old_node = FS.lookupNode(old_dir, old_name);
          var relative = PATH_FS.relative(old_path, new_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(28);
          }
          relative = PATH_FS.relative(new_path, old_dirname);
          if (relative.charAt(0) !== ".") {
            throw new FS.ErrnoError(55);
          }
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (old_node === new_node) {
            return;
          }
          var isdir = FS.isDir(old_node.mode);
          var errCode = FS.mayDelete(old_dir, old_name, isdir);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!old_dir.node_ops.rename) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
            throw new FS.ErrnoError(10);
          }
          if (new_dir !== old_dir) {
            errCode = FS.nodePermissions(old_dir, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          try {
            if (FS.trackingDelegate["willMovePath"]) {
              FS.trackingDelegate["willMovePath"](old_path, new_path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
          FS.hashRemoveNode(old_node);
          try {
            old_dir.node_ops.rename(old_node, new_dir, new_name);
          } catch (e) {
            throw e;
          } finally {
            FS.hashAddNode(old_node);
          }
          try {
            if (FS.trackingDelegate["onMovePath"])
              FS.trackingDelegate["onMovePath"](old_path, new_path);
          } catch (e) {
            err("FS.trackingDelegate['onMovePath']('" + old_path + "', '" + new_path + "') threw an exception: " + e.message);
          }
        }, rmdir: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, true);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.rmdir) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.rmdir(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node.node_ops.readdir) {
            throw new FS.ErrnoError(54);
          }
          return node.node_ops.readdir(node);
        }, unlink: function(path) {
          var lookup = FS.lookupPath(path, { parent: true });
          var parent = lookup.node;
          var name2 = PATH.basename(path);
          var node = FS.lookupNode(parent, name2);
          var errCode = FS.mayDelete(parent, name2, false);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          if (!parent.node_ops.unlink) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          try {
            if (FS.trackingDelegate["willDeletePath"]) {
              FS.trackingDelegate["willDeletePath"](path);
            }
          } catch (e) {
            err("FS.trackingDelegate['willDeletePath']('" + path + "') threw an exception: " + e.message);
          }
          parent.node_ops.unlink(parent, name2);
          FS.destroyNode(node);
          try {
            if (FS.trackingDelegate["onDeletePath"])
              FS.trackingDelegate["onDeletePath"](path);
          } catch (e) {
            err("FS.trackingDelegate['onDeletePath']('" + path + "') threw an exception: " + e.message);
          }
        }, readlink: function(path) {
          var lookup = FS.lookupPath(path);
          var link = lookup.node;
          if (!link) {
            throw new FS.ErrnoError(44);
          }
          if (!link.node_ops.readlink) {
            throw new FS.ErrnoError(28);
          }
          return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
        }, stat: function(path, dontFollow) {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          var node = lookup.node;
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (!node.node_ops.getattr) {
            throw new FS.ErrnoError(63);
          }
          return node.node_ops.getattr(node);
        }, lstat: function(path) {
          return FS.stat(path, true);
        }, chmod: function(path, mode, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & ~4095, timestamp: Date.now() });
        }, lchmod: function(path, mode) {
          FS.chmod(path, mode, true);
        }, fchmod: function(fd, mode) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chmod(stream.node, mode);
        }, chown: function(path, uid, gid, dontFollow) {
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          node.node_ops.setattr(node, { timestamp: Date.now() });
        }, lchown: function(path, uid, gid) {
          FS.chown(path, uid, gid, true);
        }, fchown: function(fd, uid, gid) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          FS.chown(stream.node, uid, gid);
        }, truncate: function(path, len) {
          if (len < 0) {
            throw new FS.ErrnoError(28);
          }
          var node;
          if (typeof path === "string") {
            var lookup = FS.lookupPath(path, { follow: true });
            node = lookup.node;
          } else {
            node = path;
          }
          if (!node.node_ops.setattr) {
            throw new FS.ErrnoError(63);
          }
          if (FS.isDir(node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!FS.isFile(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          var errCode = FS.nodePermissions(node, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
        }, ftruncate: function(fd, len) {
          var stream = FS.getStream(fd);
          if (!stream) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(28);
          }
          FS.truncate(stream.node, len);
        }, utime: function(path, atime, mtime) {
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
        }, open: function(path, flags, mode, fd_start, fd_end) {
          if (path === "") {
            throw new FS.ErrnoError(44);
          }
          flags = typeof flags === "string" ? FS.modeStringToFlags(flags) : flags;
          mode = typeof mode === "undefined" ? 438 : mode;
          if (flags & 64) {
            mode = mode & 4095 | 32768;
          } else {
            mode = 0;
          }
          var node;
          if (typeof path === "object") {
            node = path;
          } else {
            path = PATH.normalize(path);
            try {
              var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
              node = lookup.node;
            } catch (e) {
            }
          }
          var created = false;
          if (flags & 64) {
            if (node) {
              if (flags & 128) {
                throw new FS.ErrnoError(20);
              }
            } else {
              node = FS.mknod(path, mode, 0);
              created = true;
            }
          }
          if (!node) {
            throw new FS.ErrnoError(44);
          }
          if (FS.isChrdev(node.mode)) {
            flags &= ~512;
          }
          if (flags & 65536 && !FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
          if (!created) {
            var errCode = FS.mayOpen(node, flags);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
          }
          if (flags & 512) {
            FS.truncate(node, 0);
          }
          flags &= ~(128 | 512 | 131072);
          var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false }, fd_start, fd_end);
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
          if (Module["logReadFiles"] && !(flags & 1)) {
            if (!FS.readFiles)
              FS.readFiles = {};
            if (!(path in FS.readFiles)) {
              FS.readFiles[path] = 1;
              err("FS.trackingDelegate error on read file: " + path);
            }
          }
          try {
            if (FS.trackingDelegate["onOpenFile"]) {
              var trackingFlags = 0;
              if ((flags & 2097155) !== 1) {
                trackingFlags |= FS.tracking.openFlags.READ;
              }
              if ((flags & 2097155) !== 0) {
                trackingFlags |= FS.tracking.openFlags.WRITE;
              }
              FS.trackingDelegate["onOpenFile"](path, trackingFlags);
            }
          } catch (e) {
            err("FS.trackingDelegate['onOpenFile']('" + path + "', flags) threw an exception: " + e.message);
          }
          return stream;
        }, close: function(stream) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (stream.getdents)
            stream.getdents = null;
          try {
            if (stream.stream_ops.close) {
              stream.stream_ops.close(stream);
            }
          } catch (e) {
            throw e;
          } finally {
            FS.closeStream(stream.fd);
          }
          stream.fd = null;
        }, isClosed: function(stream) {
          return stream.fd === null;
        }, llseek: function(stream, offset, whence) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (!stream.seekable || !stream.stream_ops.llseek) {
            throw new FS.ErrnoError(70);
          }
          if (whence != 0 && whence != 1 && whence != 2) {
            throw new FS.ErrnoError(28);
          }
          stream.position = stream.stream_ops.llseek(stream, offset, whence);
          stream.ungotten = [];
          return stream.position;
        }, read: function(stream, buffer2, offset, length, position) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.read) {
            throw new FS.ErrnoError(28);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesRead = stream.stream_ops.read(stream, buffer2, offset, length, position);
          if (!seeking)
            stream.position += bytesRead;
          return bytesRead;
        }, write: function(stream, buffer2, offset, length, position, canOwn) {
          offset >>>= 0;
          if (length < 0 || position < 0) {
            throw new FS.ErrnoError(28);
          }
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(31);
          }
          if (!stream.stream_ops.write) {
            throw new FS.ErrnoError(28);
          }
          if (stream.seekable && stream.flags & 1024) {
            FS.llseek(stream, 0, 2);
          }
          var seeking = typeof position !== "undefined";
          if (!seeking) {
            position = stream.position;
          } else if (!stream.seekable) {
            throw new FS.ErrnoError(70);
          }
          var bytesWritten = stream.stream_ops.write(stream, buffer2, offset, length, position, canOwn);
          if (!seeking)
            stream.position += bytesWritten;
          try {
            if (stream.path && FS.trackingDelegate["onWriteToFile"])
              FS.trackingDelegate["onWriteToFile"](stream.path);
          } catch (e) {
            err("FS.trackingDelegate['onWriteToFile']('" + stream.path + "') threw an exception: " + e.message);
          }
          return bytesWritten;
        }, allocate: function(stream, offset, length) {
          if (FS.isClosed(stream)) {
            throw new FS.ErrnoError(8);
          }
          if (offset < 0 || length <= 0) {
            throw new FS.ErrnoError(28);
          }
          if ((stream.flags & 2097155) === 0) {
            throw new FS.ErrnoError(8);
          }
          if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (!stream.stream_ops.allocate) {
            throw new FS.ErrnoError(138);
          }
          stream.stream_ops.allocate(stream, offset, length);
        }, mmap: function(stream, address, length, position, prot, flags) {
          address >>>= 0;
          if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
            throw new FS.ErrnoError(2);
          }
          if ((stream.flags & 2097155) === 1) {
            throw new FS.ErrnoError(2);
          }
          if (!stream.stream_ops.mmap) {
            throw new FS.ErrnoError(43);
          }
          return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
        }, msync: function(stream, buffer2, offset, length, mmapFlags) {
          offset >>>= 0;
          if (!stream || !stream.stream_ops.msync) {
            return 0;
          }
          return stream.stream_ops.msync(stream, buffer2, offset, length, mmapFlags);
        }, munmap: function(stream) {
          return 0;
        }, ioctl: function(stream, cmd, arg) {
          if (!stream.stream_ops.ioctl) {
            throw new FS.ErrnoError(59);
          }
          return stream.stream_ops.ioctl(stream, cmd, arg);
        }, readFile: function(path, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 0;
          opts.encoding = opts.encoding || "binary";
          if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
            throw new Error('Invalid encoding type "' + opts.encoding + '"');
          }
          var ret;
          var stream = FS.open(path, opts.flags);
          var stat = FS.stat(path);
          var length = stat.size;
          var buf = new Uint8Array(length);
          FS.read(stream, buf, 0, length, 0);
          if (opts.encoding === "utf8") {
            ret = UTF8ArrayToString(buf, 0);
          } else if (opts.encoding === "binary") {
            ret = buf;
          }
          FS.close(stream);
          return ret;
        }, writeFile: function(path, data, opts) {
          opts = opts || {};
          opts.flags = opts.flags || 577;
          var stream = FS.open(path, opts.flags, opts.mode);
          if (typeof data === "string") {
            var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
            var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
            FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
          } else if (ArrayBuffer.isView(data)) {
            FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
          } else {
            throw new Error("Unsupported data type");
          }
          FS.close(stream);
        }, cwd: function() {
          return FS.currentPath;
        }, chdir: function(path) {
          var lookup = FS.lookupPath(path, { follow: true });
          if (lookup.node === null) {
            throw new FS.ErrnoError(44);
          }
          if (!FS.isDir(lookup.node.mode)) {
            throw new FS.ErrnoError(54);
          }
          var errCode = FS.nodePermissions(lookup.node, "x");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
          FS.currentPath = lookup.path;
        }, createDefaultDirectories: function() {
          FS.mkdir("/tmp");
          FS.mkdir("/home");
          FS.mkdir("/home/web_user");
        }, createDefaultDevices: function() {
          FS.mkdir("/dev");
          FS.registerDevice(FS.makedev(1, 3), { read: function() {
            return 0;
          }, write: function(stream, buffer2, offset, length, pos) {
            return length;
          } });
          FS.mkdev("/dev/null", FS.makedev(1, 3));
          TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
          TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
          FS.mkdev("/dev/tty", FS.makedev(5, 0));
          FS.mkdev("/dev/tty1", FS.makedev(6, 0));
          var random_device = getRandomDevice();
          FS.createDevice("/dev", "random", random_device);
          FS.createDevice("/dev", "urandom", random_device);
          FS.mkdir("/dev/shm");
          FS.mkdir("/dev/shm/tmp");
        }, createSpecialDirectories: function() {
          FS.mkdir("/proc");
          var proc_self = FS.mkdir("/proc/self");
          FS.mkdir("/proc/self/fd");
          FS.mount({ mount: function() {
            var node = FS.createNode(proc_self, "fd", 16384 | 511, 73);
            node.node_ops = { lookup: function(parent, name2) {
              var fd = +name2;
              var stream = FS.getStream(fd);
              if (!stream)
                throw new FS.ErrnoError(8);
              var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function() {
                return stream.path;
              } } };
              ret.parent = ret;
              return ret;
            } };
            return node;
          } }, {}, "/proc/self/fd");
        }, createStandardStreams: function() {
          if (Module["stdin"]) {
            FS.createDevice("/dev", "stdin", Module["stdin"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdin");
          }
          if (Module["stdout"]) {
            FS.createDevice("/dev", "stdout", null, Module["stdout"]);
          } else {
            FS.symlink("/dev/tty", "/dev/stdout");
          }
          if (Module["stderr"]) {
            FS.createDevice("/dev", "stderr", null, Module["stderr"]);
          } else {
            FS.symlink("/dev/tty1", "/dev/stderr");
          }
          FS.open("/dev/stdin", 0);
          FS.open("/dev/stdout", 1);
          FS.open("/dev/stderr", 1);
        }, ensureErrnoError: function() {
          if (FS.ErrnoError)
            return;
          FS.ErrnoError = function ErrnoError(errno, node) {
            this.node = node;
            this.setErrno = function(errno2) {
              this.errno = errno2;
            };
            this.setErrno(errno);
            this.message = "FS error";
          };
          FS.ErrnoError.prototype = new Error();
          FS.ErrnoError.prototype.constructor = FS.ErrnoError;
          [44].forEach(function(code) {
            FS.genericErrors[code] = new FS.ErrnoError(code);
            FS.genericErrors[code].stack = "<generic error, no stack>";
          });
        }, staticInit: function() {
          FS.ensureErrnoError();
          FS.nameTable = new Array(4096);
          FS.mount(MEMFS, {}, "/");
          FS.createDefaultDirectories();
          FS.createDefaultDevices();
          FS.createSpecialDirectories();
          FS.filesystems = { "MEMFS": MEMFS };
        }, init: function(input, output, error) {
          FS.init.initialized = true;
          FS.ensureErrnoError();
          Module["stdin"] = input || Module["stdin"];
          Module["stdout"] = output || Module["stdout"];
          Module["stderr"] = error || Module["stderr"];
          FS.createStandardStreams();
        }, quit: function() {
          FS.init.initialized = false;
          var fflush = Module["_fflush"];
          if (fflush)
            fflush(0);
          for (var i = 0; i < FS.streams.length; i++) {
            var stream = FS.streams[i];
            if (!stream) {
              continue;
            }
            FS.close(stream);
          }
        }, getMode: function(canRead, canWrite) {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        }, findObject: function(path, dontResolveLastLink) {
          var ret = FS.analyzePath(path, dontResolveLastLink);
          if (ret.exists) {
            return ret.object;
          } else {
            return null;
          }
        }, analyzePath: function(path, dontResolveLastLink) {
          try {
            var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            path = lookup.path;
          } catch (e) {
          }
          var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
          try {
            var lookup = FS.lookupPath(path, { parent: true });
            ret.parentExists = true;
            ret.parentPath = lookup.path;
            ret.parentObject = lookup.node;
            ret.name = PATH.basename(path);
            lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
            ret.exists = true;
            ret.path = lookup.path;
            ret.object = lookup.node;
            ret.name = lookup.node.name;
            ret.isRoot = lookup.path === "/";
          } catch (e) {
            ret.error = e.errno;
          }
          return ret;
        }, createPath: function(parent, path, canRead, canWrite) {
          parent = typeof parent === "string" ? parent : FS.getPath(parent);
          var parts = path.split("/").reverse();
          while (parts.length) {
            var part = parts.pop();
            if (!part)
              continue;
            var current = PATH.join2(parent, part);
            try {
              FS.mkdir(current);
            } catch (e) {
            }
            parent = current;
          }
          return current;
        }, createFile: function(parent, name2, properties, canRead, canWrite) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(canRead, canWrite);
          return FS.create(path, mode);
        }, createDataFile: function(parent, name2, data, canRead, canWrite, canOwn) {
          var path = name2 ? PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2) : parent;
          var mode = FS.getMode(canRead, canWrite);
          var node = FS.create(path, mode);
          if (data) {
            if (typeof data === "string") {
              var arr = new Array(data.length);
              for (var i = 0, len = data.length; i < len; ++i)
                arr[i] = data.charCodeAt(i);
              data = arr;
            }
            FS.chmod(node, mode | 146);
            var stream = FS.open(node, 577);
            FS.write(stream, data, 0, data.length, 0, canOwn);
            FS.close(stream);
            FS.chmod(node, mode);
          }
          return node;
        }, createDevice: function(parent, name2, input, output) {
          var path = PATH.join2(typeof parent === "string" ? parent : FS.getPath(parent), name2);
          var mode = FS.getMode(!!input, !!output);
          if (!FS.createDevice.major)
            FS.createDevice.major = 64;
          var dev = FS.makedev(FS.createDevice.major++, 0);
          FS.registerDevice(dev, { open: function(stream) {
            stream.seekable = false;
          }, close: function(stream) {
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          }, read: function(stream, buffer2, offset, length, pos) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === void 0 && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === void 0)
                break;
              bytesRead++;
              buffer2[offset + i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          }, write: function(stream, buffer2, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer2[offset + i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          } });
          return FS.mkdev(path, mode, dev);
        }, forceLoadFile: function(obj) {
          if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
            return true;
          if (typeof XMLHttpRequest !== "undefined") {
            throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
          } else if (read_) {
            try {
              obj.contents = intArrayFromString(read_(obj.url), true);
              obj.usedBytes = obj.contents.length;
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          } else {
            throw new Error("Cannot load without read() or XMLHttpRequest.");
          }
        }, createLazyFile: function(parent, name2, url, canRead, canWrite) {
          function LazyUint8Array() {
            this.lengthKnown = false;
            this.chunks = [];
          }
          LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          };
          LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
            this.getter = getter;
          };
          LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
              throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing)
              chunkSize = datalength;
            var doXHR = function(from, to) {
              if (from > to)
                throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1)
                throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize)
                xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              if (typeof Uint8Array != "undefined")
                xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              } else {
                return intArrayFromString(xhr2.responseText || "", true);
              }
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum + 1) * chunkSize - 1;
              end = Math.min(end, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] === "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof lazyArray2.chunks[chunkNum] === "undefined")
                throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          };
          if (typeof XMLHttpRequest !== "undefined") {
            if (!ENVIRONMENT_IS_WORKER)
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
            var lazyArray = new LazyUint8Array();
            Object.defineProperties(lazyArray, { length: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._length;
            } }, chunkSize: { get: function() {
              if (!this.lengthKnown) {
                this.cacheLength();
              }
              return this._chunkSize;
            } } });
            var properties = { isDevice: false, contents: lazyArray };
          } else {
            var properties = { isDevice: false, url };
          }
          var node = FS.createFile(parent, name2, properties, canRead, canWrite);
          if (properties.contents) {
            node.contents = properties.contents;
          } else if (properties.url) {
            node.contents = null;
            node.url = properties.url;
          }
          Object.defineProperties(node, { usedBytes: { get: function() {
            return this.contents.length;
          } } });
          var stream_ops = {};
          var keys = Object.keys(node.stream_ops);
          keys.forEach(function(key2) {
            var fn = node.stream_ops[key2];
            stream_ops[key2] = function forceLoadLazyFile() {
              FS.forceLoadFile(node);
              return fn.apply(null, arguments);
            };
          });
          stream_ops.read = function stream_ops_read(stream, buffer2, offset, length, position) {
            FS.forceLoadFile(node);
            var contents = stream.node.contents;
            if (position >= contents.length)
              return 0;
            var size = Math.min(contents.length - position, length);
            if (contents.slice) {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents[position + i];
              }
            } else {
              for (var i = 0; i < size; i++) {
                buffer2[offset + i] = contents.get(position + i);
              }
            }
            return size;
          };
          node.stream_ops = stream_ops;
          return node;
        }, createPreloadedFile: function(parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
          Browser.init();
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          function processData(byteArray) {
            function finish(byteArray2) {
              if (preFinish)
                preFinish();
              if (!dontCreateFile) {
                FS.createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              if (onload)
                onload();
              removeRunDependency();
            }
            var handled = false;
            Module["preloadPlugins"].forEach(function(plugin) {
              if (handled)
                return;
              if (plugin["canHandle"](fullname)) {
                plugin["handle"](byteArray, fullname, finish, function() {
                  if (onerror)
                    onerror();
                  removeRunDependency();
                });
                handled = true;
              }
            });
            if (!handled)
              finish(byteArray);
          }
          addRunDependency();
          if (typeof url == "string") {
            asyncLoad(url, function(byteArray) {
              processData(byteArray);
            }, onerror);
          } else {
            processData(url);
          }
        }, indexedDB: function() {
          return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        }, DB_NAME: function() {
          return "EM_FS_" + window.location.pathname;
        }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
            out("creating db");
            var db = openRequest.result;
            db.createObjectStore(FS.DB_STORE_NAME);
          };
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            var transaction = db.transaction([FS.DB_STORE_NAME], "readwrite");
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var putRequest = files.put(FS.analyzePath(path).object.contents, path);
              putRequest.onsuccess = function putRequest_onsuccess() {
                ok++;
                if (ok + fail == total)
                  finish();
              };
              putRequest.onerror = function putRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        }, loadFilesFromDB: function(paths, onload, onerror) {
          onload = onload || function() {
          };
          onerror = onerror || function() {
          };
          var indexedDB = FS.indexedDB();
          try {
            var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
          } catch (e) {
            return onerror(e);
          }
          openRequest.onupgradeneeded = onerror;
          openRequest.onsuccess = function openRequest_onsuccess() {
            var db = openRequest.result;
            try {
              var transaction = db.transaction([FS.DB_STORE_NAME], "readonly");
            } catch (e) {
              onerror(e);
              return;
            }
            var files = transaction.objectStore(FS.DB_STORE_NAME);
            var ok = 0, fail = 0, total = paths.length;
            function finish() {
              if (fail == 0)
                onload();
              else
                onerror();
            }
            paths.forEach(function(path) {
              var getRequest = files.get(path);
              getRequest.onsuccess = function getRequest_onsuccess() {
                if (FS.analyzePath(path).exists) {
                  FS.unlink(path);
                }
                FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
                ok++;
                if (ok + fail == total)
                  finish();
              };
              getRequest.onerror = function getRequest_onerror() {
                fail++;
                if (ok + fail == total)
                  finish();
              };
            });
            transaction.onerror = onerror;
          };
          openRequest.onerror = onerror;
        } };
        var SYSCALLS = { mappings: {}, DEFAULT_POLLMASK: 5, umask: 511, calculateAt: function(dirfd, path, allowEmpty) {
          if (path[0] === "/") {
            return path;
          }
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream)
              throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          if (path.length == 0) {
            if (!allowEmpty) {
              throw new FS.ErrnoError(44);
            }
            return dir;
          }
          return PATH.join2(dir, path);
        }, doStat: function(func, path, buf) {
          try {
            var stat = func(path);
          } catch (e) {
            if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
              return -54;
            }
            throw e;
          }
          HEAP32[buf >>> 2] = stat.dev;
          HEAP32[buf + 4 >>> 2] = 0;
          HEAP32[buf + 8 >>> 2] = stat.ino;
          HEAP32[buf + 12 >>> 2] = stat.mode;
          HEAP32[buf + 16 >>> 2] = stat.nlink;
          HEAP32[buf + 20 >>> 2] = stat.uid;
          HEAP32[buf + 24 >>> 2] = stat.gid;
          HEAP32[buf + 28 >>> 2] = stat.rdev;
          HEAP32[buf + 32 >>> 2] = 0;
          tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >>> 2] = tempI64[0], HEAP32[buf + 44 >>> 2] = tempI64[1];
          HEAP32[buf + 48 >>> 2] = 4096;
          HEAP32[buf + 52 >>> 2] = stat.blocks;
          HEAP32[buf + 56 >>> 2] = stat.atime.getTime() / 1e3 | 0;
          HEAP32[buf + 60 >>> 2] = 0;
          HEAP32[buf + 64 >>> 2] = stat.mtime.getTime() / 1e3 | 0;
          HEAP32[buf + 68 >>> 2] = 0;
          HEAP32[buf + 72 >>> 2] = stat.ctime.getTime() / 1e3 | 0;
          HEAP32[buf + 76 >>> 2] = 0;
          tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >>> 2] = tempI64[0], HEAP32[buf + 84 >>> 2] = tempI64[1];
          return 0;
        }, doMsync: function(addr, stream, len, flags, offset) {
          var buffer2 = HEAPU8.slice(addr, addr + len);
          FS.msync(stream, buffer2, offset, len, flags);
        }, doMkdir: function(path, mode) {
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/")
            path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        }, doMknod: function(path, mode, dev) {
          switch (mode & 61440) {
            case 32768:
            case 8192:
            case 24576:
            case 4096:
            case 49152:
              break;
            default:
              return -28;
          }
          FS.mknod(path, mode, dev);
          return 0;
        }, doReadlink: function(path, buf, bufsize) {
          if (bufsize <= 0)
            return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = HEAP8[buf + len >>> 0];
          stringToUTF8(ret, buf, bufsize + 1);
          HEAP8[buf + len >>> 0] = endChar;
          return len;
        }, doAccess: function(path, amode) {
          if (amode & ~7) {
            return -28;
          }
          var node;
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4)
            perms += "r";
          if (amode & 2)
            perms += "w";
          if (amode & 1)
            perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        }, doDup: function(path, flags, suggestFD) {
          var suggest = FS.getStream(suggestFD);
          if (suggest)
            FS.close(suggest);
          return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
        }, doReadv: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        }, doWritev: function(stream, iov, iovcnt, offset) {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAP32[iov + i * 8 >>> 2];
            var len = HEAP32[iov + (i * 8 + 4) >>> 2];
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
          }
          return ret;
        }, varargs: void 0, get: function() {
          SYSCALLS.varargs += 4;
          var ret = HEAP32[SYSCALLS.varargs - 4 >>> 2];
          return ret;
        }, getStr: function(ptr) {
          var ret = UTF8ToString(ptr);
          return ret;
        }, getStreamFromFD: function(fd) {
          var stream = FS.getStream(fd);
          if (!stream)
            throw new FS.ErrnoError(8);
          return stream;
        }, get64: function(low, high) {
          return low;
        } };
        function ___sys_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = SYSCALLS.get();
                if (arg < 0) {
                  return -28;
                }
                var newStream;
                newStream = FS.open(stream.path, stream.flags, 0, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = SYSCALLS.get();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = SYSCALLS.get();
                var offset = 0;
                HEAP16[arg + offset >>> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
              case 16:
              case 8:
                return -28;
              case 9:
                setErrNo(28);
                return -1;
              default: {
                return -28;
              }
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509:
              case 21505: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21510:
              case 21511:
              case 21512:
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = SYSCALLS.get();
                HEAP32[argp >>> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = SYSCALLS.get();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                abort("bad ioctl syscall " + op);
            }
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        function ___sys_open(path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var pathname = SYSCALLS.getStr(path);
            var mode = varargs ? SYSCALLS.get() : 0;
            var stream = FS.open(pathname, flags, mode);
            return stream.fd;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return -e.errno;
          }
        }
        var tupleRegistrations = {};
        function runDestructors(destructors) {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        }
        function simpleReadValueFromPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >>> 2]);
        }
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var char_0 = 48;
        var char_9 = 57;
        function makeLegalFunctionName(name2) {
          if (name2 === void 0) {
            return "_unknown";
          }
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return "_" + name2;
          } else {
            return name2;
          }
        }
        function createNamedFunction(name2, body) {
          name2 = makeLegalFunctionName(name2);
          return new Function("body", "return function " + name2 + '() {\n    "use strict";    return body.apply(this, arguments);\n};\n')(body);
        }
        function extendError(baseErrorType, errorName) {
          var errorClass = createNamedFunction(errorName, function(message) {
            this.name = errorName;
            this.message = message;
            var stack = new Error(message).stack;
            if (stack !== void 0) {
              this.stack = this.toString() + "\n" + stack.replace(/^Error(:[^\n]*)?\n/, "");
            }
          });
          errorClass.prototype = Object.create(baseErrorType.prototype);
          errorClass.prototype.constructor = errorClass;
          errorClass.prototype.toString = function() {
            if (this.message === void 0) {
              return this.name;
            } else {
              return this.name + ": " + this.message;
            }
          };
          return errorClass;
        }
        var InternalError = void 0;
        function throwInternalError(message) {
          throw new InternalError(message);
        }
        function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
          myTypes.forEach(function(type) {
            typeDependencies[type] = dependentTypes;
          });
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach(function(dt, i) {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (unregisteredTypes.length === 0) {
            onComplete(typeConverters);
          }
        }
        function __embind_finalize_value_array(rawTupleType) {
          var reg = tupleRegistrations[rawTupleType];
          delete tupleRegistrations[rawTupleType];
          var elements = reg.elements;
          var elementsLength = elements.length;
          var elementTypes = elements.map(function(elt) {
            return elt.getterReturnType;
          }).concat(elements.map(function(elt) {
            return elt.setterArgumentType;
          }));
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          whenDependentTypesAreResolved([rawTupleType], elementTypes, function(elementTypes2) {
            elements.forEach(function(elt, i) {
              var getterReturnType = elementTypes2[i];
              var getter = elt.getter;
              var getterContext = elt.getterContext;
              var setterArgumentType = elementTypes2[i + elementsLength];
              var setter = elt.setter;
              var setterContext = elt.setterContext;
              elt.read = function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              };
              elt.write = function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = new Array(elementsLength);
              for (var i = 0; i < elementsLength; ++i) {
                rv[i] = elements[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              if (elementsLength !== o.length) {
                throw new TypeError("Incorrect number of tuple elements for " + reg.name + ": expected=" + elementsLength + ", actual=" + o.length);
              }
              var ptr = rawConstructor();
              for (var i = 0; i < elementsLength; ++i) {
                elements[i].write(ptr, o[i]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        var structRegistrations = {};
        function __embind_finalize_value_object(structType) {
          var reg = structRegistrations[structType];
          delete structRegistrations[structType];
          var rawConstructor = reg.rawConstructor;
          var rawDestructor = reg.rawDestructor;
          var fieldRecords = reg.fields;
          var fieldTypes = fieldRecords.map(function(field) {
            return field.getterReturnType;
          }).concat(fieldRecords.map(function(field) {
            return field.setterArgumentType;
          }));
          whenDependentTypesAreResolved([structType], fieldTypes, function(fieldTypes2) {
            var fields = {};
            fieldRecords.forEach(function(field, i) {
              var fieldName = field.fieldName;
              var getterReturnType = fieldTypes2[i];
              var getter = field.getter;
              var getterContext = field.getterContext;
              var setterArgumentType = fieldTypes2[i + fieldRecords.length];
              var setter = field.setter;
              var setterContext = field.setterContext;
              fields[fieldName] = { read: function(ptr) {
                return getterReturnType["fromWireType"](getter(getterContext, ptr));
              }, write: function(ptr, o) {
                var destructors = [];
                setter(setterContext, ptr, setterArgumentType["toWireType"](destructors, o));
                runDestructors(destructors);
              } };
            });
            return [{ name: reg.name, "fromWireType": function(ptr) {
              var rv = {};
              for (var i in fields) {
                rv[i] = fields[i].read(ptr);
              }
              rawDestructor(ptr);
              return rv;
            }, "toWireType": function(destructors, o) {
              for (var fieldName in fields) {
                if (!(fieldName in o)) {
                  throw new TypeError('Missing field:  "' + fieldName + '"');
                }
              }
              var ptr = rawConstructor();
              for (fieldName in fields) {
                fields[fieldName].write(ptr, o[fieldName]);
              }
              if (destructors !== null) {
                destructors.push(rawDestructor, ptr);
              }
              return ptr;
            }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: rawDestructor }];
          });
        }
        function __embind_register_bigint(primitiveType, name2, size, minRange, maxRange) {
        }
        function getShiftFromSize(size) {
          switch (size) {
            case 1:
              return 0;
            case 2:
              return 1;
            case 4:
              return 2;
            case 8:
              return 3;
            default:
              throw new TypeError("Unknown type size: " + size);
          }
        }
        function embind_init_charCodes() {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        }
        var embind_charCodes = void 0;
        function readLatin1String(ptr) {
          var ret = "";
          var c = ptr;
          while (HEAPU8[c >>> 0]) {
            ret += embind_charCodes[HEAPU8[c++ >>> 0]];
          }
          return ret;
        }
        var BindingError = void 0;
        function throwBindingError(message) {
          throw new BindingError(message);
        }
        function registerType(rawType, registeredInstance, options) {
          options = options || {};
          if (!("argPackAdvance" in registeredInstance)) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError('type "' + name2 + '" must have a positive integer typeid pointer');
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError("Cannot register type '" + name2 + "' twice");
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach(function(cb) {
              cb();
            });
          }
        }
        function __embind_register_bool(rawType, name2, size, trueValue, falseValue) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(wt) {
            return !!wt;
          }, "toWireType": function(destructors, o) {
            return o ? trueValue : falseValue;
          }, "argPackAdvance": 8, "readValueFromPointer": function(pointer) {
            var heap;
            if (size === 1) {
              heap = HEAP8;
            } else if (size === 2) {
              heap = HEAP16;
            } else if (size === 4) {
              heap = HEAP32;
            } else {
              throw new TypeError("Unknown boolean type size: " + name2);
            }
            return this["fromWireType"](heap[pointer >>> shift]);
          }, destructorFunction: null });
        }
        function ClassHandle_isAliasOf(other) {
          if (!(this instanceof ClassHandle)) {
            return false;
          }
          if (!(other instanceof ClassHandle)) {
            return false;
          }
          var leftClass = this.$$.ptrType.registeredClass;
          var left = this.$$.ptr;
          var rightClass = other.$$.ptrType.registeredClass;
          var right = other.$$.ptr;
          while (leftClass.baseClass) {
            left = leftClass.upcast(left);
            leftClass = leftClass.baseClass;
          }
          while (rightClass.baseClass) {
            right = rightClass.upcast(right);
            rightClass = rightClass.baseClass;
          }
          return leftClass === rightClass && left === right;
        }
        function shallowCopyInternalPointer(o) {
          return { count: o.count, deleteScheduled: o.deleteScheduled, preservePointerOnDelete: o.preservePointerOnDelete, ptr: o.ptr, ptrType: o.ptrType, smartPtr: o.smartPtr, smartPtrType: o.smartPtrType };
        }
        function throwInstanceAlreadyDeleted(obj) {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        }
        var finalizationGroup = false;
        function detachFinalizer(handle) {
        }
        function runDestructor($$) {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        }
        function releaseClassHandle($$) {
          $$.count.value -= 1;
          var toDelete = $$.count.value === 0;
          if (toDelete) {
            runDestructor($$);
          }
        }
        function attachFinalizer(handle) {
          if (typeof FinalizationGroup === "undefined") {
            attachFinalizer = function(handle2) {
              return handle2;
            };
            return handle;
          }
          finalizationGroup = new FinalizationGroup(function(iter) {
            for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                console.warn("object already deleted: " + $$.ptr);
              } else {
                releaseClassHandle($$);
              }
            }
          });
          attachFinalizer = function(handle2) {
            finalizationGroup.register(handle2, handle2.$$, handle2.$$);
            return handle2;
          };
          detachFinalizer = function(handle2) {
            finalizationGroup.unregister(handle2.$$);
          };
          return attachFinalizer(handle);
        }
        function ClassHandle_clone() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.preservePointerOnDelete) {
            this.$$.count.value += 1;
            return this;
          } else {
            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), { $$: { value: shallowCopyInternalPointer(this.$$) } }));
            clone.$$.count.value += 1;
            clone.$$.deleteScheduled = false;
            return clone;
          }
        }
        function ClassHandle_delete() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          detachFinalizer(this);
          releaseClassHandle(this.$$);
          if (!this.$$.preservePointerOnDelete) {
            this.$$.smartPtr = void 0;
            this.$$.ptr = void 0;
          }
        }
        function ClassHandle_isDeleted() {
          return !this.$$.ptr;
        }
        var delayFunction = void 0;
        var deletionQueue = [];
        function flushPendingDeletes() {
          while (deletionQueue.length) {
            var obj = deletionQueue.pop();
            obj.$$.deleteScheduled = false;
            obj["delete"]();
          }
        }
        function ClassHandle_deleteLater() {
          if (!this.$$.ptr) {
            throwInstanceAlreadyDeleted(this);
          }
          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
            throwBindingError("Object already scheduled for deletion");
          }
          deletionQueue.push(this);
          if (deletionQueue.length === 1 && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
          this.$$.deleteScheduled = true;
          return this;
        }
        function init_ClassHandle() {
          ClassHandle.prototype["isAliasOf"] = ClassHandle_isAliasOf;
          ClassHandle.prototype["clone"] = ClassHandle_clone;
          ClassHandle.prototype["delete"] = ClassHandle_delete;
          ClassHandle.prototype["isDeleted"] = ClassHandle_isDeleted;
          ClassHandle.prototype["deleteLater"] = ClassHandle_deleteLater;
        }
        function ClassHandle() {
        }
        var registeredPointers = {};
        function ensureOverloadTable(proto, methodName, humanName) {
          if (proto[methodName].overloadTable === void 0) {
            var prevFunc = proto[methodName];
            proto[methodName] = function() {
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        }
        function exposePublicSymbol(name2, value, numArguments) {
          if (Module.hasOwnProperty(name2)) {
            if (numArguments === void 0 || Module[name2].overloadTable !== void 0 && Module[name2].overloadTable[numArguments] !== void 0) {
              throwBindingError("Cannot register public name '" + name2 + "' twice");
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            if (numArguments !== void 0) {
              Module[name2].numArguments = numArguments;
            }
          }
        }
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        function upcastPointer(ptr, ptrClass, desiredClass) {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        }
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (handle.$$.smartPtr === void 0) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError("Cannot convert argument of type " + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + " to parameter type " + this.name);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(ptr, __emval_register(function() {
                    clonedHandle["delete"]();
                  }));
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError("null is not a valid " + this.name);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
          }
          if (!handle.$$.ptr) {
            throwBindingError("Cannot pass deleted object as a pointer of type " + this.name);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError("Cannot convert argument of type " + handle.$$.ptrType.name + " to parameter type " + this.name);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function RegisteredPointer_getPointee(ptr) {
          if (this.rawGetPointee) {
            ptr = this.rawGetPointee(ptr);
          }
          return ptr;
        }
        function RegisteredPointer_destructor(ptr) {
          if (this.rawDestructor) {
            this.rawDestructor(ptr);
          }
        }
        function RegisteredPointer_deleteObject(handle) {
          if (handle !== null) {
            handle["delete"]();
          }
        }
        function downcastPointer(ptr, ptrClass, desiredClass) {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (desiredClass.baseClass === void 0) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        }
        function getInheritedInstanceCount() {
          return Object.keys(registeredInstances).length;
        }
        function getLiveInheritedInstances() {
          var rv = [];
          for (var k in registeredInstances) {
            if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
            }
          }
          return rv;
        }
        function setDelayFunction(fn) {
          delayFunction = fn;
          if (deletionQueue.length && delayFunction) {
            delayFunction(flushPendingDeletes);
          }
        }
        function init_embind() {
          Module["getInheritedInstanceCount"] = getInheritedInstanceCount;
          Module["getLiveInheritedInstances"] = getLiveInheritedInstances;
          Module["flushPendingDeletes"] = flushPendingDeletes;
          Module["setDelayFunction"] = setDelayFunction;
        }
        var registeredInstances = {};
        function getBasestPointer(class_, ptr) {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        }
        function getInheritedInstance(class_, ptr) {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        }
        function makeClassHandle(prototype, record) {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, { $$: { value: record } }));
        }
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (registeredInstance !== void 0) {
            if (registeredInstance.$$.count.value === 0) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this.pointeeType, ptr: rawPointer, smartPtrType: this, smartPtr: ptr });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, { ptrType: this, ptr });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp, smartPtrType: this, smartPtr: ptr });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, { ptrType: toType, ptr: dp });
          }
        }
        function init_RegisteredPointer() {
          RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
          RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
          RegisteredPointer.prototype["argPackAdvance"] = 8;
          RegisteredPointer.prototype["readValueFromPointer"] = simpleReadValueFromPointer;
          RegisteredPointer.prototype["deleteObject"] = RegisteredPointer_deleteObject;
          RegisteredPointer.prototype["fromWireType"] = RegisteredPointer_fromWireType;
        }
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        function replacePublicSymbol(name2, value, numArguments) {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistant public symbol");
          }
          if (Module[name2].overloadTable !== void 0 && numArguments !== void 0) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        }
        function dynCallLegacy(sig, ptr, args) {
          var f = Module["dynCall_" + sig];
          return args && args.length ? f.apply(null, [ptr].concat(args)) : f.call(null, ptr);
        }
        function dynCall(sig, ptr, args) {
          if (sig.includes("j")) {
            return dynCallLegacy(sig, ptr, args);
          }
          return wasmTable.get(ptr).apply(null, args);
        }
        function getDynCaller(sig, ptr) {
          var argCache = [];
          return function() {
            argCache.length = arguments.length;
            for (var i = 0; i < arguments.length; i++) {
              argCache[i] = arguments[i];
            }
            return dynCall(sig, ptr, argCache);
          };
        }
        function embind__requireFunction(signature, rawFunction) {
          signature = readLatin1String(signature);
          function makeDynCaller() {
            if (signature.includes("j")) {
              return getDynCaller(signature, rawFunction);
            }
            return wasmTable.get(rawFunction);
          }
          var fp = makeDynCaller();
          if (typeof fp !== "function") {
            throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
          }
          return fp;
        }
        var UnboundTypeError = void 0;
        function getTypeName(type) {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        }
        function throwUnboundTypeError(message, types) {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(message + ": " + unboundTypes.map(getTypeName).join([", "]));
        }
        function __embind_register_class(rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          if (upcast) {
            upcast = embind__requireFunction(upcastSignature, upcast);
          }
          if (downcast) {
            downcast = embind__requireFunction(downcastSignature, downcast);
          }
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError("Cannot construct " + name2 + " due to unbound types", [baseClassRawType]);
          });
          whenDependentTypesAreResolved([rawType, rawPointerType, rawConstPointerType], baseClassRawType ? [baseClassRawType] : [], function(base) {
            base = base[0];
            var baseClass;
            var basePrototype;
            if (baseClassRawType) {
              baseClass = base.registeredClass;
              basePrototype = baseClass.instancePrototype;
            } else {
              basePrototype = ClassHandle.prototype;
            }
            var constructor = createNamedFunction(legalFunctionName, function() {
              if (Object.getPrototypeOf(this) !== instancePrototype) {
                throw new BindingError("Use 'new' to construct " + name2);
              }
              if (registeredClass.constructor_body === void 0) {
                throw new BindingError(name2 + " has no accessible constructor");
              }
              var body = registeredClass.constructor_body[arguments.length];
              if (body === void 0) {
                throw new BindingError("Tried to invoke ctor of " + name2 + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
              }
              return body.apply(this, arguments);
            });
            var instancePrototype = Object.create(basePrototype, { constructor: { value: constructor } });
            constructor.prototype = instancePrototype;
            var registeredClass = new RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);
            var referenceConverter = new RegisteredPointer(name2, registeredClass, true, false, false);
            var pointerConverter = new RegisteredPointer(name2 + "*", registeredClass, false, false, false);
            var constPointerConverter = new RegisteredPointer(name2 + " const*", registeredClass, false, true, false);
            registeredPointers[rawType] = { pointerType: pointerConverter, constPointerType: constPointerConverter };
            replacePublicSymbol(legalFunctionName, constructor);
            return [referenceConverter, pointerConverter, constPointerConverter];
          });
        }
        function heap32VectorToArray(count, firstElement) {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(HEAP32[(firstElement >> 2) + i >>> 0]);
          }
          return array;
        }
        function __embind_register_class_constructor(rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          var args = [rawConstructor];
          var destructors = [];
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = "constructor " + classType.name;
            if (classType.registeredClass.constructor_body === void 0) {
              classType.registeredClass.constructor_body = [];
            }
            if (classType.registeredClass.constructor_body[argCount - 1] !== void 0) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount - 1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
            }
            classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError("Cannot construct " + classType.name + " due to unbound types", rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                if (arguments.length !== argCount - 1) {
                  throwBindingError(humanName + " called with " + arguments.length + " arguments, expected " + (argCount - 1));
                }
                destructors.length = 0;
                args.length = argCount;
                for (var i = 1; i < argCount; ++i) {
                  args[i] = argTypes[i]["toWireType"](destructors, arguments[i - 1]);
                }
                var ptr = invoker.apply(null, args);
                runDestructors(destructors);
                return argTypes[0]["fromWireType"](ptr);
              };
              return [];
            });
            return [];
          });
        }
        function new_(constructor, argumentList) {
          if (!(constructor instanceof Function)) {
            throw new TypeError("new_ called with constructor type " + typeof constructor + " which is not a function");
          }
          var dummy = createNamedFunction(constructor.name || "unknownFunctionName", function() {
          });
          dummy.prototype = constructor.prototype;
          var obj = new dummy();
          var r = constructor.apply(obj, argumentList);
          return r instanceof Object ? r : obj;
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = false;
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              needsDestructorStack = true;
              break;
            }
          }
          var returns = argTypes[0].name !== "void";
          var argsList = "";
          var argsListWired = "";
          for (var i = 0; i < argCount - 2; ++i) {
            argsList += (i !== 0 ? ", " : "") + "arg" + i;
            argsListWired += (i !== 0 ? ", " : "") + "arg" + i + "Wired";
          }
          var invokerFnBody = "return function " + makeLegalFunctionName(humanName) + "(" + argsList + ") {\nif (arguments.length !== " + (argCount - 2) + ") {\nthrowBindingError('function " + humanName + " called with ' + arguments.length + ' arguments, expected " + (argCount - 2) + " args!');\n}\n";
          if (needsDestructorStack) {
            invokerFnBody += "var destructors = [];\n";
          }
          var dtorStack = needsDestructorStack ? "destructors" : "null";
          var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
          var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
          if (isClassMethodFunc) {
            invokerFnBody += "var thisWired = classParam.toWireType(" + dtorStack + ", this);\n";
          }
          for (var i = 0; i < argCount - 2; ++i) {
            invokerFnBody += "var arg" + i + "Wired = argType" + i + ".toWireType(" + dtorStack + ", arg" + i + "); // " + argTypes[i + 2].name + "\n";
            args1.push("argType" + i);
            args2.push(argTypes[i + 2]);
          }
          if (isClassMethodFunc) {
            argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
          }
          invokerFnBody += (returns ? "var rv = " : "") + "invoker(fn" + (argsListWired.length > 0 ? ", " : "") + argsListWired + ");\n";
          if (needsDestructorStack) {
            invokerFnBody += "runDestructors(destructors);\n";
          } else {
            for (var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i) {
              var paramName = i === 1 ? "thisWired" : "arg" + (i - 2) + "Wired";
              if (argTypes[i].destructorFunction !== null) {
                invokerFnBody += paramName + "_dtor(" + paramName + "); // " + argTypes[i].name + "\n";
                args1.push(paramName + "_dtor");
                args2.push(argTypes[i].destructorFunction);
              }
            }
          }
          if (returns) {
            invokerFnBody += "var ret = retType.fromWireType(rv);\nreturn ret;\n";
          }
          invokerFnBody += "}\n";
          args1.push(invokerFnBody);
          var invokerFunction = new_(Function, args1).apply(null, args2);
          return invokerFunction;
        }
        function __embind_register_class_function(rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual) {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
          whenDependentTypesAreResolved([], [rawClassType], function(classType) {
            classType = classType[0];
            var humanName = classType.name + "." + methodName;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError("Cannot call " + humanName + " due to unbound types", rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (method === void 0 || method.overloadTable === void 0 && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
              if (proto[methodName].overloadTable === void 0) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        }
        var emval_free_list = [];
        var emval_handle_array = [{}, { value: void 0 }, { value: null }, { value: true }, { value: false }];
        function __emval_decref(handle) {
          if (handle > 4 && --emval_handle_array[handle].refcount === 0) {
            emval_handle_array[handle] = void 0;
            emval_free_list.push(handle);
          }
        }
        function count_emval_handles() {
          var count = 0;
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              ++count;
            }
          }
          return count;
        }
        function get_first_emval() {
          for (var i = 5; i < emval_handle_array.length; ++i) {
            if (emval_handle_array[i] !== void 0) {
              return emval_handle_array[i];
            }
          }
          return null;
        }
        function init_emval() {
          Module["count_emval_handles"] = count_emval_handles;
          Module["get_first_emval"] = get_first_emval;
        }
        function __emval_register(value) {
          switch (value) {
            case void 0: {
              return 1;
            }
            case null: {
              return 2;
            }
            case true: {
              return 3;
            }
            case false: {
              return 4;
            }
            default: {
              var handle = emval_free_list.length ? emval_free_list.pop() : emval_handle_array.length;
              emval_handle_array[handle] = { refcount: 1, value };
              return handle;
            }
          }
        }
        function __embind_register_emval(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(handle) {
            var rv = emval_handle_array[handle].value;
            __emval_decref(handle);
            return rv;
          }, "toWireType": function(destructors, value) {
            return __emval_register(value);
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: null });
        }
        function enumReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return function(pointer) {
                var heap = signed ? HEAP8 : HEAPU8;
                return this["fromWireType"](heap[pointer >>> 0]);
              };
            case 1:
              return function(pointer) {
                var heap = signed ? HEAP16 : HEAPU16;
                return this["fromWireType"](heap[pointer >>> 1]);
              };
            case 2:
              return function(pointer) {
                var heap = signed ? HEAP32 : HEAPU32;
                return this["fromWireType"](heap[pointer >>> 2]);
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_enum(rawType, name2, size, isSigned) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          function ctor() {
          }
          ctor.values = {};
          registerType(rawType, { name: name2, constructor: ctor, "fromWireType": function(c) {
            return this.constructor.values[c];
          }, "toWireType": function(destructors, c) {
            return c.value;
          }, "argPackAdvance": 8, "readValueFromPointer": enumReadValueFromPointer(name2, shift, isSigned), destructorFunction: null });
          exposePublicSymbol(name2, ctor);
        }
        function requireRegisteredType(rawType, humanName) {
          var impl = registeredTypes[rawType];
          if (impl === void 0) {
            throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
          }
          return impl;
        }
        function __embind_register_enum_value(rawEnumType, name2, enumValue) {
          var enumType = requireRegisteredType(rawEnumType, "enum");
          name2 = readLatin1String(name2);
          var Enum = enumType.constructor;
          var Value2 = Object.create(enumType.constructor.prototype, { value: { value: enumValue }, constructor: { value: createNamedFunction(enumType.name + "_" + name2, function() {
          }) } });
          Enum.values[enumValue] = Value2;
          Enum[name2] = Value2;
        }
        function _embind_repr(v) {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        }
        function floatReadValueFromPointer(name2, shift) {
          switch (shift) {
            case 2:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >>> 2]);
              };
            case 3:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >>> 3]);
              };
            default:
              throw new TypeError("Unknown float type: " + name2);
          }
        }
        function __embind_register_float(rawType, name2, size) {
          var shift = getShiftFromSize(size);
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            return value;
          }, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            return value;
          }, "argPackAdvance": 8, "readValueFromPointer": floatReadValueFromPointer(name2, shift), destructorFunction: null });
        }
        function __embind_register_function(name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError("Cannot call " + name2 + " due to unbound types", argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, function(argTypes2) {
            var invokerArgsArray = [argTypes2[0], null].concat(argTypes2.slice(1));
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn), argCount - 1);
            return [];
          });
        }
        function integerReadValueFromPointer(name2, shift, signed) {
          switch (shift) {
            case 0:
              return signed ? function readS8FromPointer(pointer) {
                return HEAP8[pointer >>> 0];
              } : function readU8FromPointer(pointer) {
                return HEAPU8[pointer >>> 0];
              };
            case 1:
              return signed ? function readS16FromPointer(pointer) {
                return HEAP16[pointer >>> 1];
              } : function readU16FromPointer(pointer) {
                return HEAPU16[pointer >>> 1];
              };
            case 2:
              return signed ? function readS32FromPointer(pointer) {
                return HEAP32[pointer >>> 2];
              } : function readU32FromPointer(pointer) {
                return HEAPU32[pointer >>> 2];
              };
            default:
              throw new TypeError("Unknown integer type: " + name2);
          }
        }
        function __embind_register_integer(primitiveType, name2, size, minRange, maxRange) {
          name2 = readLatin1String(name2);
          if (maxRange === -1) {
            maxRange = 4294967295;
          }
          var shift = getShiftFromSize(size);
          var fromWireType = function(value) {
            return value;
          };
          if (minRange === 0) {
            var bitshift = 32 - 8 * size;
            fromWireType = function(value) {
              return value << bitshift >>> bitshift;
            };
          }
          var isUnsignedType = name2.includes("unsigned");
          registerType(primitiveType, { name: name2, "fromWireType": fromWireType, "toWireType": function(destructors, value) {
            if (typeof value !== "number" && typeof value !== "boolean") {
              throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
            }
            if (value < minRange || value > maxRange) {
              throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name2 + '", which is outside the valid range [' + minRange + ", " + maxRange + "]!");
            }
            return isUnsignedType ? value >>> 0 : value | 0;
          }, "argPackAdvance": 8, "readValueFromPointer": integerReadValueFromPointer(name2, shift, minRange !== 0), destructorFunction: null });
        }
        function __embind_register_memory_view(rawType, dataTypeIndex, name2) {
          var typeMapping = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            handle = handle >> 2;
            var heap = HEAPU32;
            var size = heap[handle >>> 0];
            var data = heap[handle + 1 >>> 0];
            return new TA(buffer, data, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, { name: name2, "fromWireType": decodeMemoryView, "argPackAdvance": 8, "readValueFromPointer": decodeMemoryView }, { ignoreDuplicateRegistrations: true });
        }
        function __embind_register_std_string(rawType, name2) {
          name2 = readLatin1String(name2);
          var stdStringIsUTF8 = name2 === "std::string";
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var str;
            if (stdStringIsUTF8) {
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i;
                if (i == length || HEAPU8[currentBytePtr >>> 0] == 0) {
                  var maxRead = currentBytePtr - decodeStartPtr;
                  var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + 1;
                }
              }
            } else {
              var a = new Array(length);
              for (var i = 0; i < length; ++i) {
                a[i] = String.fromCharCode(HEAPU8[value + 4 + i >>> 0]);
              }
              str = a.join("");
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (value instanceof ArrayBuffer) {
              value = new Uint8Array(value);
            }
            var getLength;
            var valueIsOfTypeString = typeof value === "string";
            if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
              throwBindingError("Cannot pass non-string to std::string");
            }
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              getLength = function() {
                return lengthBytesUTF8(value);
              };
            } else {
              getLength = function() {
                return value.length;
              };
            }
            var length = getLength();
            var ptr = _malloc(4 + length + 1);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length;
            if (stdStringIsUTF8 && valueIsOfTypeString) {
              stringToUTF8(value, ptr + 4, length + 1);
            } else {
              if (valueIsOfTypeString) {
                for (var i = 0; i < length; ++i) {
                  var charCode = value.charCodeAt(i);
                  if (charCode > 255) {
                    _free(ptr);
                    throwBindingError("String has UTF-16 code units that do not fit in 8 bits");
                  }
                  HEAPU8[ptr + 4 + i >>> 0] = charCode;
                }
              } else {
                for (var i = 0; i < length; ++i) {
                  HEAPU8[ptr + 4 + i >>> 0] = value[i];
                }
              }
            }
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_std_wstring(rawType, charSize, name2) {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            getHeap = function() {
              return HEAPU16;
            };
            shift = 1;
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            getHeap = function() {
              return HEAPU32;
            };
            shift = 2;
          }
          registerType(rawType, { name: name2, "fromWireType": function(value) {
            var length = HEAPU32[value >>> 2];
            var HEAP = getHeap();
            var str;
            var decodeStartPtr = value + 4;
            for (var i = 0; i <= length; ++i) {
              var currentBytePtr = value + 4 + i * charSize;
              if (i == length || HEAP[currentBytePtr >>> shift] == 0) {
                var maxReadBytes = currentBytePtr - decodeStartPtr;
                var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                if (str === void 0) {
                  str = stringSegment;
                } else {
                  str += String.fromCharCode(0);
                  str += stringSegment;
                }
                decodeStartPtr = currentBytePtr + charSize;
              }
            }
            _free(value);
            return str;
          }, "toWireType": function(destructors, value) {
            if (!(typeof value === "string")) {
              throwBindingError("Cannot pass non-string to C++ string type " + name2);
            }
            var length = lengthBytesUTF(value);
            var ptr = _malloc(4 + length + charSize);
            ptr >>>= 0;
            HEAPU32[ptr >>> 2] = length >> shift;
            encodeString(value, ptr + 4, length + charSize);
            if (destructors !== null) {
              destructors.push(_free, ptr);
            }
            return ptr;
          }, "argPackAdvance": 8, "readValueFromPointer": simpleReadValueFromPointer, destructorFunction: function(ptr) {
            _free(ptr);
          } });
        }
        function __embind_register_value_array(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          tupleRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), elements: [] };
        }
        function __embind_register_value_array_element(rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          tupleRegistrations[rawTupleType].elements.push({ getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_value_object(rawType, name2, constructorSignature, rawConstructor, destructorSignature, rawDestructor) {
          structRegistrations[rawType] = { name: readLatin1String(name2), rawConstructor: embind__requireFunction(constructorSignature, rawConstructor), rawDestructor: embind__requireFunction(destructorSignature, rawDestructor), fields: [] };
        }
        function __embind_register_value_object_field(structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext) {
          structRegistrations[structType].fields.push({ fieldName: readLatin1String(fieldName), getterReturnType, getter: embind__requireFunction(getterSignature, getter), getterContext, setterArgumentType, setter: embind__requireFunction(setterSignature, setter), setterContext });
        }
        function __embind_register_void(rawType, name2) {
          name2 = readLatin1String(name2);
          registerType(rawType, { isVoid: true, name: name2, "argPackAdvance": 0, "fromWireType": function() {
            return void 0;
          }, "toWireType": function(destructors, o) {
            return void 0;
          } });
        }
        function requireHandle(handle) {
          if (!handle) {
            throwBindingError("Cannot use deleted val. handle = " + handle);
          }
          return emval_handle_array[handle].value;
        }
        function __emval_as(handle, returnType, destructorsRef) {
          handle = requireHandle(handle);
          returnType = requireRegisteredType(returnType, "emval::as");
          var destructors = [];
          var rd = __emval_register(destructors);
          HEAP32[destructorsRef >>> 2] = rd;
          return returnType["toWireType"](destructors, handle);
        }
        function __emval_lookupTypes(argCount, argTypes) {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(HEAP32[(argTypes >> 2) + i >>> 0], "parameter " + i);
          }
          return a;
        }
        function __emval_call(handle, argCount, argTypes, argv) {
          handle = requireHandle(handle);
          var types = __emval_lookupTypes(argCount, argTypes);
          var args = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            var type = types[i];
            args[i] = type["readValueFromPointer"](argv);
            argv += type["argPackAdvance"];
          }
          var rv = handle.apply(void 0, args);
          return __emval_register(rv);
        }
        var emval_symbols = {};
        function getStringOrSymbol(address) {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          } else {
            return symbol;
          }
        }
        function emval_get_global() {
          if (typeof globalThis === "object") {
            return globalThis;
          }
          return function() {
            return Function;
          }()("return this")();
        }
        function __emval_get_global(name2) {
          if (name2 === 0) {
            return __emval_register(emval_get_global());
          } else {
            name2 = getStringOrSymbol(name2);
            return __emval_register(emval_get_global()[name2]);
          }
        }
        function __emval_get_property(handle, key2) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          return __emval_register(handle[key2]);
        }
        function __emval_incref(handle) {
          if (handle > 4) {
            emval_handle_array[handle].refcount += 1;
          }
        }
        function __emval_instanceof(object, constructor) {
          object = requireHandle(object);
          constructor = requireHandle(constructor);
          return object instanceof constructor;
        }
        function __emval_is_number(handle) {
          handle = requireHandle(handle);
          return typeof handle === "number";
        }
        function __emval_new_array() {
          return __emval_register([]);
        }
        function __emval_new_cstring(v) {
          return __emval_register(getStringOrSymbol(v));
        }
        function __emval_new_object() {
          return __emval_register({});
        }
        function __emval_run_destructors(handle) {
          var destructors = emval_handle_array[handle].value;
          runDestructors(destructors);
          __emval_decref(handle);
        }
        function __emval_set_property(handle, key2, value) {
          handle = requireHandle(handle);
          key2 = requireHandle(key2);
          value = requireHandle(value);
          handle[key2] = value;
        }
        function __emval_take_value(type, argv) {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](argv);
          return __emval_register(v);
        }
        function _abort() {
          abort();
        }
        var _emscripten_get_now;
        if (ENVIRONMENT_IS_NODE) {
          _emscripten_get_now = function() {
            var t = process["hrtime"]();
            return t[0] * 1e3 + t[1] / 1e6;
          };
        } else
          _emscripten_get_now = function() {
            return performance.now();
          };
        var _emscripten_get_now_is_monotonic = true;
        function _clock_gettime(clk_id, tp) {
          var now;
          if (clk_id === 0) {
            now = Date.now();
          } else if ((clk_id === 1 || clk_id === 4) && _emscripten_get_now_is_monotonic) {
            now = _emscripten_get_now();
          } else {
            setErrNo(28);
            return -1;
          }
          HEAP32[tp >>> 2] = now / 1e3 | 0;
          HEAP32[tp + 4 >>> 2] = now % 1e3 * 1e3 * 1e3 | 0;
          return 0;
        }
        function _emscripten_memcpy_big(dest, src, num) {
          HEAPU8.copyWithin(dest >>> 0, src >>> 0, src + num >>> 0);
        }
        function emscripten_realloc_buffer(size) {
          try {
            wasmMemory.grow(size - buffer.byteLength + 65535 >>> 16);
            updateGlobalBufferAndViews(wasmMemory.buffer);
            return 1;
          } catch (e) {
          }
        }
        function _emscripten_resize_heap(requestedSize) {
          var oldSize = HEAPU8.length;
          requestedSize = requestedSize >>> 0;
          var maxHeapSize = 4294901760;
          if (requestedSize > maxHeapSize) {
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = emscripten_realloc_buffer(newSize);
            if (replacement) {
              return true;
            }
          }
          return false;
        }
        var ENV = {};
        function getExecutableName() {
          return thisProgram || "./this.program";
        }
        function getEnvStrings() {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator === "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": lang, "_": getExecutableName() };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env[x];
              else
                env[x] = ENV[x];
            }
            var strings = [];
            for (var x in env) {
              strings.push(x + "=" + env[x]);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        }
        function _environ_get(__environ, environ_buf) {
          try {
            var bufSize = 0;
            getEnvStrings().forEach(function(string, i) {
              var ptr = environ_buf + bufSize;
              HEAP32[__environ + i * 4 >>> 2] = ptr;
              writeAsciiToMemory(string, ptr);
              bufSize += string.length + 1;
            });
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _environ_sizes_get(penviron_count, penviron_buf_size) {
          try {
            var strings = getEnvStrings();
            HEAP32[penviron_count >>> 2] = strings.length;
            var bufSize = 0;
            strings.forEach(function(string) {
              bufSize += string.length + 1;
            });
            HEAP32[penviron_buf_size >>> 2] = bufSize;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doReadv(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var HIGH_OFFSET = 4294967296;
            var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
            var DOUBLE_LIMIT = 9007199254740992;
            if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
              return -61;
            }
            FS.llseek(stream, offset, whence);
            tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? (Math.min(+Math.floor(tempDouble / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >>> 2] = tempI64[0], HEAP32[newOffset + 4 >>> 2] = tempI64[1];
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = SYSCALLS.doWritev(stream, iov, iovcnt);
            HEAP32[pnum >>> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS === "undefined" || !(e instanceof FS.ErrnoError))
              abort(e);
            return e.errno;
          }
        }
        function _setTempRet0(val) {
        }
        function __isLeapYear(year) {
          return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
        }
        function __arraySum(array, index) {
          var sum = 0;
          for (var i = 0; i <= index; sum += array[i++]) {
          }
          return sum;
        }
        var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        function __addDays(date, days) {
          var newDate = new Date(date.getTime());
          while (days > 0) {
            var leap = __isLeapYear(newDate.getFullYear());
            var currentMonth = newDate.getMonth();
            var daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth];
            if (days > daysInCurrentMonth - newDate.getDate()) {
              days -= daysInCurrentMonth - newDate.getDate() + 1;
              newDate.setDate(1);
              if (currentMonth < 11) {
                newDate.setMonth(currentMonth + 1);
              } else {
                newDate.setMonth(0);
                newDate.setFullYear(newDate.getFullYear() + 1);
              }
            } else {
              newDate.setDate(newDate.getDate() + days);
              return newDate;
            }
          }
          return newDate;
        }
        function _strftime(s, maxsize, format, tm) {
          var tm_zone = HEAP32[tm + 40 >>> 2];
          var date = { tm_sec: HEAP32[tm >>> 2], tm_min: HEAP32[tm + 4 >>> 2], tm_hour: HEAP32[tm + 8 >>> 2], tm_mday: HEAP32[tm + 12 >>> 2], tm_mon: HEAP32[tm + 16 >>> 2], tm_year: HEAP32[tm + 20 >>> 2], tm_wday: HEAP32[tm + 24 >>> 2], tm_yday: HEAP32[tm + 28 >>> 2], tm_isdst: HEAP32[tm + 32 >>> 2], tm_gmtoff: HEAP32[tm + 36 >>> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" };
          var pattern = UTF8ToString(format);
          var EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
          for (var rule in EXPANSION_RULES_1) {
            pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]);
          }
          var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
          var MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
          function leadingSomething(value, digits, character) {
            var str = typeof value === "number" ? value.toString() : value || "";
            while (str.length < digits) {
              str = character[0] + str;
            }
            return str;
          }
          function leadingNulls(value, digits) {
            return leadingSomething(value, digits, "0");
          }
          function compareByDay(date1, date2) {
            function sgn(value) {
              return value < 0 ? -1 : value > 0 ? 1 : 0;
            }
            var compare;
            if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {
              if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {
                compare = sgn(date1.getDate() - date2.getDate());
              }
            }
            return compare;
          }
          function getFirstWeekStartDate(janFourth) {
            switch (janFourth.getDay()) {
              case 0:
                return new Date(janFourth.getFullYear() - 1, 11, 29);
              case 1:
                return janFourth;
              case 2:
                return new Date(janFourth.getFullYear(), 0, 3);
              case 3:
                return new Date(janFourth.getFullYear(), 0, 2);
              case 4:
                return new Date(janFourth.getFullYear(), 0, 1);
              case 5:
                return new Date(janFourth.getFullYear() - 1, 11, 31);
              case 6:
                return new Date(janFourth.getFullYear() - 1, 11, 30);
            }
          }
          function getWeekBasedYear(date2) {
            var thisDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);
            var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {
              if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {
                return thisDate.getFullYear() + 1;
              } else {
                return thisDate.getFullYear();
              }
            } else {
              return thisDate.getFullYear() - 1;
            }
          }
          var EXPANSION_RULES_2 = { "%a": function(date2) {
            return WEEKDAYS[date2.tm_wday].substring(0, 3);
          }, "%A": function(date2) {
            return WEEKDAYS[date2.tm_wday];
          }, "%b": function(date2) {
            return MONTHS[date2.tm_mon].substring(0, 3);
          }, "%B": function(date2) {
            return MONTHS[date2.tm_mon];
          }, "%C": function(date2) {
            var year = date2.tm_year + 1900;
            return leadingNulls(year / 100 | 0, 2);
          }, "%d": function(date2) {
            return leadingNulls(date2.tm_mday, 2);
          }, "%e": function(date2) {
            return leadingSomething(date2.tm_mday, 2, " ");
          }, "%g": function(date2) {
            return getWeekBasedYear(date2).toString().substring(2);
          }, "%G": function(date2) {
            return getWeekBasedYear(date2);
          }, "%H": function(date2) {
            return leadingNulls(date2.tm_hour, 2);
          }, "%I": function(date2) {
            var twelveHour = date2.tm_hour;
            if (twelveHour == 0)
              twelveHour = 12;
            else if (twelveHour > 12)
              twelveHour -= 12;
            return leadingNulls(twelveHour, 2);
          }, "%j": function(date2) {
            return leadingNulls(date2.tm_mday + __arraySum(__isLeapYear(date2.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date2.tm_mon - 1), 3);
          }, "%m": function(date2) {
            return leadingNulls(date2.tm_mon + 1, 2);
          }, "%M": function(date2) {
            return leadingNulls(date2.tm_min, 2);
          }, "%n": function() {
            return "\n";
          }, "%p": function(date2) {
            if (date2.tm_hour >= 0 && date2.tm_hour < 12) {
              return "AM";
            } else {
              return "PM";
            }
          }, "%S": function(date2) {
            return leadingNulls(date2.tm_sec, 2);
          }, "%t": function() {
            return "	";
          }, "%u": function(date2) {
            return date2.tm_wday || 7;
          }, "%U": function(date2) {
            var janFirst = new Date(date2.tm_year + 1900, 0, 1);
            var firstSunday = janFirst.getDay() === 0 ? janFirst : __addDays(janFirst, 7 - janFirst.getDay());
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstSunday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstSundayUntilEndJanuary = 31 - firstSunday.getDate();
              var days = firstSundayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstSunday, janFirst) === 0 ? "01" : "00";
          }, "%V": function(date2) {
            var janFourthThisYear = new Date(date2.tm_year + 1900, 0, 4);
            var janFourthNextYear = new Date(date2.tm_year + 1901, 0, 4);
            var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);
            var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);
            var endDate = __addDays(new Date(date2.tm_year + 1900, 0, 1), date2.tm_yday);
            if (compareByDay(endDate, firstWeekStartThisYear) < 0) {
              return "53";
            }
            if (compareByDay(firstWeekStartNextYear, endDate) <= 0) {
              return "01";
            }
            var daysDifference;
            if (firstWeekStartThisYear.getFullYear() < date2.tm_year + 1900) {
              daysDifference = date2.tm_yday + 32 - firstWeekStartThisYear.getDate();
            } else {
              daysDifference = date2.tm_yday + 1 - firstWeekStartThisYear.getDate();
            }
            return leadingNulls(Math.ceil(daysDifference / 7), 2);
          }, "%w": function(date2) {
            return date2.tm_wday;
          }, "%W": function(date2) {
            var janFirst = new Date(date2.tm_year, 0, 1);
            var firstMonday = janFirst.getDay() === 1 ? janFirst : __addDays(janFirst, janFirst.getDay() === 0 ? 1 : 7 - janFirst.getDay() + 1);
            var endDate = new Date(date2.tm_year + 1900, date2.tm_mon, date2.tm_mday);
            if (compareByDay(firstMonday, endDate) < 0) {
              var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31;
              var firstMondayUntilEndJanuary = 31 - firstMonday.getDate();
              var days = firstMondayUntilEndJanuary + februaryFirstUntilEndMonth + endDate.getDate();
              return leadingNulls(Math.ceil(days / 7), 2);
            }
            return compareByDay(firstMonday, janFirst) === 0 ? "01" : "00";
          }, "%y": function(date2) {
            return (date2.tm_year + 1900).toString().substring(2);
          }, "%Y": function(date2) {
            return date2.tm_year + 1900;
          }, "%z": function(date2) {
            var off = date2.tm_gmtoff;
            var ahead = off >= 0;
            off = Math.abs(off) / 60;
            off = off / 60 * 100 + off % 60;
            return (ahead ? "+" : "-") + String("0000" + off).slice(-4);
          }, "%Z": function(date2) {
            return date2.tm_zone;
          }, "%%": function() {
            return "%";
          } };
          for (var rule in EXPANSION_RULES_2) {
            if (pattern.includes(rule)) {
              pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date));
            }
          }
          var bytes = intArrayFromString(pattern, false);
          if (bytes.length > maxsize) {
            return 0;
          }
          writeArrayToMemory(bytes, s);
          return bytes.length - 1;
        }
        function _strftime_l(s, maxsize, format, tm) {
          return _strftime(s, maxsize, format, tm);
        }
        var FSNode = function(parent, name2, mode, rdev) {
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.mounted = null;
          this.id = FS.nextInode++;
          this.name = name2;
          this.mode = mode;
          this.node_ops = {};
          this.stream_ops = {};
          this.rdev = rdev;
        };
        var readMode = 292 | 73;
        var writeMode = 146;
        Object.defineProperties(FSNode.prototype, { read: { get: function() {
          return (this.mode & readMode) === readMode;
        }, set: function(val) {
          val ? this.mode |= readMode : this.mode &= ~readMode;
        } }, write: { get: function() {
          return (this.mode & writeMode) === writeMode;
        }, set: function(val) {
          val ? this.mode |= writeMode : this.mode &= ~writeMode;
        } }, isFolder: { get: function() {
          return FS.isDir(this.mode);
        } }, isDevice: { get: function() {
          return FS.isChrdev(this.mode);
        } } });
        FS.FSNode = FSNode;
        FS.staticInit();
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        InternalError = Module["InternalError"] = extendError(Error, "InternalError");
        embind_init_charCodes();
        BindingError = Module["BindingError"] = extendError(Error, "BindingError");
        init_ClassHandle();
        init_RegisteredPointer();
        init_embind();
        UnboundTypeError = Module["UnboundTypeError"] = extendError(Error, "UnboundTypeError");
        init_emval();
        function intArrayFromString(stringy, dontAddNull, length) {
          var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          if (dontAddNull)
            u8array.length = numBytesWritten;
          return u8array;
        }
        var asmLibraryArg = { "y": ___assert_fail, "x": ___cxa_allocate_exception, "w": ___cxa_throw, "A": ___sys_fcntl64, "O": ___sys_ioctl, "P": ___sys_open, "Z": __embind_finalize_value_array, "o": __embind_finalize_value_object, "J": __embind_register_bigint, "W": __embind_register_bool, "r": __embind_register_class, "q": __embind_register_class_constructor, "b": __embind_register_class_function, "V": __embind_register_emval, "Y": __embind_register_enum, "t": __embind_register_enum_value, "D": __embind_register_float, "e": __embind_register_function, "n": __embind_register_integer, "j": __embind_register_memory_view, "E": __embind_register_std_string, "v": __embind_register_std_wstring, "_": __embind_register_value_array, "g": __embind_register_value_array_element, "p": __embind_register_value_object, "d": __embind_register_value_object_field, "X": __embind_register_void, "l": __emval_as, "F": __emval_call, "a": __emval_decref, "H": __emval_get_global, "m": __emval_get_property, "i": __emval_incref, "L": __emval_instanceof, "G": __emval_is_number, "z": __emval_new_array, "f": __emval_new_cstring, "s": __emval_new_object, "k": __emval_run_destructors, "h": __emval_set_property, "c": __emval_take_value, "C": _abort, "N": _clock_gettime, "M": _emscripten_memcpy_big, "u": _emscripten_resize_heap, "R": _environ_get, "S": _environ_sizes_get, "B": _fd_close, "U": _fd_read, "I": _fd_seek, "T": _fd_write, "K": _setTempRet0, "Q": _strftime_l };
        createWasm();
        Module["___wasm_call_ctors"] = function() {
          return (Module["___wasm_call_ctors"] = Module["asm"]["aa"]).apply(null, arguments);
        };
        Module["_main"] = function() {
          return (Module["_main"] = Module["asm"]["ba"]).apply(null, arguments);
        };
        var _malloc = Module["_malloc"] = function() {
          return (_malloc = Module["_malloc"] = Module["asm"]["ca"]).apply(null, arguments);
        };
        var _free = Module["_free"] = function() {
          return (_free = Module["_free"] = Module["asm"]["da"]).apply(null, arguments);
        };
        var ___getTypeName = Module["___getTypeName"] = function() {
          return (___getTypeName = Module["___getTypeName"] = Module["asm"]["ea"]).apply(null, arguments);
        };
        Module["___embind_register_native_and_builtin_types"] = function() {
          return (Module["___embind_register_native_and_builtin_types"] = Module["asm"]["fa"]).apply(null, arguments);
        };
        var ___errno_location = Module["___errno_location"] = function() {
          return (___errno_location = Module["___errno_location"] = Module["asm"]["ga"]).apply(null, arguments);
        };
        Module["dynCall_jiji"] = function() {
          return (Module["dynCall_jiji"] = Module["asm"]["ia"]).apply(null, arguments);
        };
        Module["dynCall_viijii"] = function() {
          return (Module["dynCall_viijii"] = Module["asm"]["ja"]).apply(null, arguments);
        };
        Module["dynCall_iiiiij"] = function() {
          return (Module["dynCall_iiiiij"] = Module["asm"]["ka"]).apply(null, arguments);
        };
        Module["dynCall_iiiiijj"] = function() {
          return (Module["dynCall_iiiiijj"] = Module["asm"]["la"]).apply(null, arguments);
        };
        Module["dynCall_iiiiiijj"] = function() {
          return (Module["dynCall_iiiiiijj"] = Module["asm"]["ma"]).apply(null, arguments);
        };
        Module["addRunDependency"] = addRunDependency;
        Module["removeRunDependency"] = removeRunDependency;
        Module["FS_createPath"] = FS.createPath;
        Module["FS_createDataFile"] = FS.createDataFile;
        Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
        Module["FS_createLazyFile"] = FS.createLazyFile;
        Module["FS_createDevice"] = FS.createDevice;
        Module["FS_unlink"] = FS.unlink;
        Module["FS"] = FS;
        var calledRun;
        function ExitStatus(status) {
          this.name = "ExitStatus";
          this.message = "Program terminated with exit(" + status + ")";
          this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
          if (!calledRun)
            run();
          if (!calledRun)
            dependenciesFulfilled = runCaller;
        };
        function callMain(args) {
          var entryFunction = Module["_main"];
          var argc = 0;
          var argv = 0;
          try {
            var ret = entryFunction(argc, argv);
            exit(ret, true);
          } catch (e) {
            if (e instanceof ExitStatus || e == "unwind") {
              return;
            }
            var toLog = e;
            if (e && typeof e === "object" && e.stack) {
              toLog = [e, e.stack];
            }
            err("exception thrown: " + toLog);
            quit_(1, e);
          } finally {
          }
        }
        function run(args) {
          if (runDependencies > 0) {
            return;
          }
          preRun();
          if (runDependencies > 0) {
            return;
          }
          function doRun() {
            if (calledRun)
              return;
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            preMain();
            readyPromiseResolve(Module);
            if (Module["onRuntimeInitialized"])
              Module["onRuntimeInitialized"]();
            if (shouldRunNow)
              callMain();
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(function() {
              setTimeout(function() {
                Module["setStatus"]("");
              }, 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
        }
        Module["run"] = run;
        function exit(status, implicit) {
          if (keepRuntimeAlive()) ; else {
            if (Module["onExit"])
              Module["onExit"](status);
            ABORT = true;
          }
          quit_(status, new ExitStatus(status));
        }
        if (Module["preInit"]) {
          if (typeof Module["preInit"] == "function")
            Module["preInit"] = [Module["preInit"]];
          while (Module["preInit"].length > 0) {
            Module["preInit"].pop()();
          }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
          shouldRunNow = false;
        run();
        return WebIFCWasm3.ready;
      };
    }();
    if (typeof exports === "object" && typeof module === "object")
      module.exports = WebIFCWasm2;
    else if (typeof define === "function" && define["amd"])
      define([], function() {
        return WebIFCWasm2;
      });
    else if (typeof exports === "object")
      exports["WebIFCWasm"] = WebIFCWasm2;
  }
});

// dist/ifc2x4.ts
var IFCACTIONREQUEST = 3821786052;
var IFCACTOR = 2296667514;
var IFCACTORROLE = 3630933823;
var IFCACTUATOR = 4288193352;
var IFCACTUATORTYPE = 2874132201;
var IFCADDRESS = 618182010;
var IFCADVANCEDBREP = 1635779807;
var IFCADVANCEDBREPWITHVOIDS = 2603310189;
var IFCADVANCEDFACE = 3406155212;
var IFCAIRTERMINAL = 1634111441;
var IFCAIRTERMINALBOX = 177149247;
var IFCAIRTERMINALBOXTYPE = 1411407467;
var IFCAIRTERMINALTYPE = 3352864051;
var IFCAIRTOAIRHEATRECOVERY = 2056796094;
var IFCAIRTOAIRHEATRECOVERYTYPE = 1871374353;
var IFCALARM = 3087945054;
var IFCALARMTYPE = 3001207471;
var IFCALIGNMENT = 325726236;
var IFCALIGNMENT2DHORIZONTAL = 749761778;
var IFCALIGNMENT2DHORIZONTALSEGMENT = 3199563722;
var IFCALIGNMENT2DSEGMENT = 2483840362;
var IFCALIGNMENT2DVERSEGCIRCULARARC = 3379348081;
var IFCALIGNMENT2DVERSEGLINE = 3239324667;
var IFCALIGNMENT2DVERSEGPARABOLICARC = 4263986512;
var IFCALIGNMENT2DVERTICAL = 53199957;
var IFCALIGNMENT2DVERTICALSEGMENT = 2029264950;
var IFCALIGNMENTCURVE = 3512275521;
var IFCANNOTATION = 1674181508;
var IFCANNOTATIONFILLAREA = 669184980;
var IFCAPPLICATION = 639542469;
var IFCAPPLIEDVALUE = 411424972;
var IFCAPPROVAL = 130549933;
var IFCAPPROVALRELATIONSHIP = 3869604511;
var IFCARBITRARYCLOSEDPROFILEDEF = 3798115385;
var IFCARBITRARYOPENPROFILEDEF = 1310608509;
var IFCARBITRARYPROFILEDEFWITHVOIDS = 2705031697;
var IFCASSET = 3460190687;
var IFCASYMMETRICISHAPEPROFILEDEF = 3207858831;
var IFCAUDIOVISUALAPPLIANCE = 277319702;
var IFCAUDIOVISUALAPPLIANCETYPE = 1532957894;
var IFCAXIS1PLACEMENT = 4261334040;
var IFCAXIS2PLACEMENT2D = 3125803723;
var IFCAXIS2PLACEMENT3D = 2740243338;
var IFCBSPLINECURVE = 1967976161;
var IFCBSPLINECURVEWITHKNOTS = 2461110595;
var IFCBSPLINESURFACE = 2887950389;
var IFCBSPLINESURFACEWITHKNOTS = 167062518;
var IFCBEAM = 753842376;
var IFCBEAMSTANDARDCASE = 2906023776;
var IFCBEAMTYPE = 819618141;
var IFCBEARING = 4196446775;
var IFCBEARINGTYPE = 3649138523;
var IFCBLOBTEXTURE = 616511568;
var IFCBLOCK = 1334484129;
var IFCBOILER = 32344328;
var IFCBOILERTYPE = 231477066;
var IFCBOOLEANCLIPPINGRESULT = 3649129432;
var IFCBOOLEANRESULT = 2736907675;
var IFCBOUNDARYCONDITION = 4037036970;
var IFCBOUNDARYCURVE = 1136057603;
var IFCBOUNDARYEDGECONDITION = 1560379544;
var IFCBOUNDARYFACECONDITION = 3367102660;
var IFCBOUNDARYNODECONDITION = 1387855156;
var IFCBOUNDARYNODECONDITIONWARPING = 2069777674;
var IFCBOUNDEDCURVE = 1260505505;
var IFCBOUNDEDSURFACE = 4182860854;
var IFCBOUNDINGBOX = 2581212453;
var IFCBOXEDHALFSPACE = 2713105998;
var IFCBRIDGE = 644574406;
var IFCBRIDGEPART = 963979645;
var IFCBUILDING = 4031249490;
var IFCBUILDINGELEMENT = 3299480353;
var IFCBUILDINGELEMENTPART = 2979338954;
var IFCBUILDINGELEMENTPARTTYPE = 39481116;
var IFCBUILDINGELEMENTPROXY = 1095909175;
var IFCBUILDINGELEMENTPROXYTYPE = 1909888760;
var IFCBUILDINGELEMENTTYPE = 1950629157;
var IFCBUILDINGSTOREY = 3124254112;
var IFCBUILDINGSYSTEM = 1177604601;
var IFCBURNER = 2938176219;
var IFCBURNERTYPE = 2188180465;
var IFCCSHAPEPROFILEDEF = 2898889636;
var IFCCABLECARRIERFITTING = 635142910;
var IFCCABLECARRIERFITTINGTYPE = 395041908;
var IFCCABLECARRIERSEGMENT = 3758799889;
var IFCCABLECARRIERSEGMENTTYPE = 3293546465;
var IFCCABLEFITTING = 1051757585;
var IFCCABLEFITTINGTYPE = 2674252688;
var IFCCABLESEGMENT = 4217484030;
var IFCCABLESEGMENTTYPE = 1285652485;
var IFCCAISSONFOUNDATION = 3999819293;
var IFCCAISSONFOUNDATIONTYPE = 3203706013;
var IFCCARTESIANPOINT = 1123145078;
var IFCCARTESIANPOINTLIST = 574549367;
var IFCCARTESIANPOINTLIST2D = 1675464909;
var IFCCARTESIANPOINTLIST3D = 2059837836;
var IFCCARTESIANTRANSFORMATIONOPERATOR = 59481748;
var IFCCARTESIANTRANSFORMATIONOPERATOR2D = 3749851601;
var IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM = 3486308946;
var IFCCARTESIANTRANSFORMATIONOPERATOR3D = 3331915920;
var IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM = 1416205885;
var IFCCENTERLINEPROFILEDEF = 3150382593;
var IFCCHILLER = 3902619387;
var IFCCHILLERTYPE = 2951183804;
var IFCCHIMNEY = 3296154744;
var IFCCHIMNEYTYPE = 2197970202;
var IFCCIRCLE = 2611217952;
var IFCCIRCLEHOLLOWPROFILEDEF = 2937912522;
var IFCCIRCLEPROFILEDEF = 1383045692;
var IFCCIRCULARARCSEGMENT2D = 1062206242;
var IFCCIVILELEMENT = 1677625105;
var IFCCIVILELEMENTTYPE = 3893394355;
var IFCCLASSIFICATION = 747523909;
var IFCCLASSIFICATIONREFERENCE = 647927063;
var IFCCLOSEDSHELL = 2205249479;
var IFCCOIL = 639361253;
var IFCCOILTYPE = 2301859152;
var IFCCOLOURRGB = 776857604;
var IFCCOLOURRGBLIST = 3285139300;
var IFCCOLOURSPECIFICATION = 3264961684;
var IFCCOLUMN = 843113511;
var IFCCOLUMNSTANDARDCASE = 905975707;
var IFCCOLUMNTYPE = 300633059;
var IFCCOMMUNICATIONSAPPLIANCE = 3221913625;
var IFCCOMMUNICATIONSAPPLIANCETYPE = 400855858;
var IFCCOMPLEXPROPERTY = 2542286263;
var IFCCOMPLEXPROPERTYTEMPLATE = 3875453745;
var IFCCOMPOSITECURVE = 3732776249;
var IFCCOMPOSITECURVEONSURFACE = 15328376;
var IFCCOMPOSITECURVESEGMENT = 2485617015;
var IFCCOMPOSITEPROFILEDEF = 1485152156;
var IFCCOMPRESSOR = 3571504051;
var IFCCOMPRESSORTYPE = 3850581409;
var IFCCONDENSER = 2272882330;
var IFCCONDENSERTYPE = 2816379211;
var IFCCONIC = 2510884976;
var IFCCONNECTEDFACESET = 370225590;
var IFCCONNECTIONCURVEGEOMETRY = 1981873012;
var IFCCONNECTIONGEOMETRY = 2859738748;
var IFCCONNECTIONPOINTECCENTRICITY = 45288368;
var IFCCONNECTIONPOINTGEOMETRY = 2614616156;
var IFCCONNECTIONSURFACEGEOMETRY = 2732653382;
var IFCCONNECTIONVOLUMEGEOMETRY = 775493141;
var IFCCONSTRAINT = 1959218052;
var IFCCONSTRUCTIONEQUIPMENTRESOURCE = 3898045240;
var IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE = 2185764099;
var IFCCONSTRUCTIONMATERIALRESOURCE = 1060000209;
var IFCCONSTRUCTIONMATERIALRESOURCETYPE = 4105962743;
var IFCCONSTRUCTIONPRODUCTRESOURCE = 488727124;
var IFCCONSTRUCTIONPRODUCTRESOURCETYPE = 1525564444;
var IFCCONSTRUCTIONRESOURCE = 2559216714;
var IFCCONSTRUCTIONRESOURCETYPE = 2574617495;
var IFCCONTEXT = 3419103109;
var IFCCONTEXTDEPENDENTUNIT = 3050246964;
var IFCCONTROL = 3293443760;
var IFCCONTROLLER = 25142252;
var IFCCONTROLLERTYPE = 578613899;
var IFCCONVERSIONBASEDUNIT = 2889183280;
var IFCCONVERSIONBASEDUNITWITHOFFSET = 2713554722;
var IFCCOOLEDBEAM = 4136498852;
var IFCCOOLEDBEAMTYPE = 335055490;
var IFCCOOLINGTOWER = 3640358203;
var IFCCOOLINGTOWERTYPE = 2954562838;
var IFCCOORDINATEOPERATION = 1785450214;
var IFCCOORDINATEREFERENCESYSTEM = 1466758467;
var IFCCOSTITEM = 3895139033;
var IFCCOSTSCHEDULE = 1419761937;
var IFCCOSTVALUE = 602808272;
var IFCCOVERING = 1973544240;
var IFCCOVERINGTYPE = 1916426348;
var IFCCREWRESOURCE = 3295246426;
var IFCCREWRESOURCETYPE = 1815067380;
var IFCCSGPRIMITIVE3D = 2506170314;
var IFCCSGSOLID = 2147822146;
var IFCCURRENCYRELATIONSHIP = 539742890;
var IFCCURTAINWALL = 3495092785;
var IFCCURTAINWALLTYPE = 1457835157;
var IFCCURVE = 2601014836;
var IFCCURVEBOUNDEDPLANE = 2827736869;
var IFCCURVEBOUNDEDSURFACE = 2629017746;
var IFCCURVESEGMENT2D = 1186437898;
var IFCCURVESTYLE = 3800577675;
var IFCCURVESTYLEFONT = 1105321065;
var IFCCURVESTYLEFONTANDSCALING = 2367409068;
var IFCCURVESTYLEFONTPATTERN = 3510044353;
var IFCCYLINDRICALSURFACE = 1213902940;
var IFCDAMPER = 4074379575;
var IFCDAMPERTYPE = 3961806047;
var IFCDEEPFOUNDATION = 3426335179;
var IFCDEEPFOUNDATIONTYPE = 1306400036;
var IFCDERIVEDPROFILEDEF = 3632507154;
var IFCDERIVEDUNIT = 1765591967;
var IFCDERIVEDUNITELEMENT = 1045800335;
var IFCDIMENSIONALEXPONENTS = 2949456006;
var IFCDIRECTION = 32440307;
var IFCDISCRETEACCESSORY = 1335981549;
var IFCDISCRETEACCESSORYTYPE = 2635815018;
var IFCDISTANCEEXPRESSION = 1945343521;
var IFCDISTRIBUTIONCHAMBERELEMENT = 1052013943;
var IFCDISTRIBUTIONCHAMBERELEMENTTYPE = 1599208980;
var IFCDISTRIBUTIONCIRCUIT = 562808652;
var IFCDISTRIBUTIONCONTROLELEMENT = 1062813311;
var IFCDISTRIBUTIONCONTROLELEMENTTYPE = 2063403501;
var IFCDISTRIBUTIONELEMENT = 1945004755;
var IFCDISTRIBUTIONELEMENTTYPE = 3256556792;
var IFCDISTRIBUTIONFLOWELEMENT = 3040386961;
var IFCDISTRIBUTIONFLOWELEMENTTYPE = 3849074793;
var IFCDISTRIBUTIONPORT = 3041715199;
var IFCDISTRIBUTIONSYSTEM = 3205830791;
var IFCDOCUMENTINFORMATION = 1154170062;
var IFCDOCUMENTINFORMATIONRELATIONSHIP = 770865208;
var IFCDOCUMENTREFERENCE = 3732053477;
var IFCDOOR = 395920057;
var IFCDOORLININGPROPERTIES = 2963535650;
var IFCDOORPANELPROPERTIES = 1714330368;
var IFCDOORSTANDARDCASE = 3242481149;
var IFCDOORSTYLE = 526551008;
var IFCDOORTYPE = 2323601079;
var IFCDRAUGHTINGPREDEFINEDCOLOUR = 445594917;
var IFCDRAUGHTINGPREDEFINEDCURVEFONT = 4006246654;
var IFCDUCTFITTING = 342316401;
var IFCDUCTFITTINGTYPE = 869906466;
var IFCDUCTSEGMENT = 3518393246;
var IFCDUCTSEGMENTTYPE = 3760055223;
var IFCDUCTSILENCER = 1360408905;
var IFCDUCTSILENCERTYPE = 2030761528;
var IFCEDGE = 3900360178;
var IFCEDGECURVE = 476780140;
var IFCEDGELOOP = 1472233963;
var IFCELECTRICAPPLIANCE = 1904799276;
var IFCELECTRICAPPLIANCETYPE = 663422040;
var IFCELECTRICDISTRIBUTIONBOARD = 862014818;
var IFCELECTRICDISTRIBUTIONBOARDTYPE = 2417008758;
var IFCELECTRICFLOWSTORAGEDEVICE = 3310460725;
var IFCELECTRICFLOWSTORAGEDEVICETYPE = 3277789161;
var IFCELECTRICGENERATOR = 264262732;
var IFCELECTRICGENERATORTYPE = 1534661035;
var IFCELECTRICMOTOR = 402227799;
var IFCELECTRICMOTORTYPE = 1217240411;
var IFCELECTRICTIMECONTROL = 1003880860;
var IFCELECTRICTIMECONTROLTYPE = 712377611;
var IFCELEMENT = 1758889154;
var IFCELEMENTASSEMBLY = 4123344466;
var IFCELEMENTASSEMBLYTYPE = 2397081782;
var IFCELEMENTCOMPONENT = 1623761950;
var IFCELEMENTCOMPONENTTYPE = 2590856083;
var IFCELEMENTQUANTITY = 1883228015;
var IFCELEMENTTYPE = 339256511;
var IFCELEMENTARYSURFACE = 2777663545;
var IFCELLIPSE = 1704287377;
var IFCELLIPSEPROFILEDEF = 2835456948;
var IFCENERGYCONVERSIONDEVICE = 1658829314;
var IFCENERGYCONVERSIONDEVICETYPE = 2107101300;
var IFCENGINE = 2814081492;
var IFCENGINETYPE = 132023988;
var IFCEVAPORATIVECOOLER = 3747195512;
var IFCEVAPORATIVECOOLERTYPE = 3174744832;
var IFCEVAPORATOR = 484807127;
var IFCEVAPORATORTYPE = 3390157468;
var IFCEVENT = 4148101412;
var IFCEVENTTIME = 211053100;
var IFCEVENTTYPE = 4024345920;
var IFCEXTENDEDPROPERTIES = 297599258;
var IFCEXTERNALINFORMATION = 4294318154;
var IFCEXTERNALREFERENCE = 3200245327;
var IFCEXTERNALREFERENCERELATIONSHIP = 1437805879;
var IFCEXTERNALSPATIALELEMENT = 1209101575;
var IFCEXTERNALSPATIALSTRUCTUREELEMENT = 2853485674;
var IFCEXTERNALLYDEFINEDHATCHSTYLE = 2242383968;
var IFCEXTERNALLYDEFINEDSURFACESTYLE = 1040185647;
var IFCEXTERNALLYDEFINEDTEXTFONT = 3548104201;
var IFCEXTRUDEDAREASOLID = 477187591;
var IFCEXTRUDEDAREASOLIDTAPERED = 2804161546;
var IFCFACE = 2556980723;
var IFCFACEBASEDSURFACEMODEL = 2047409740;
var IFCFACEBOUND = 1809719519;
var IFCFACEOUTERBOUND = 803316827;
var IFCFACESURFACE = 3008276851;
var IFCFACETEDBREP = 807026263;
var IFCFACETEDBREPWITHVOIDS = 3737207727;
var IFCFACILITY = 24185140;
var IFCFACILITYPART = 1310830890;
var IFCFAILURECONNECTIONCONDITION = 4219587988;
var IFCFAN = 3415622556;
var IFCFANTYPE = 346874300;
var IFCFASTENER = 647756555;
var IFCFASTENERTYPE = 2489546625;
var IFCFEATUREELEMENT = 2827207264;
var IFCFEATUREELEMENTADDITION = 2143335405;
var IFCFEATUREELEMENTSUBTRACTION = 1287392070;
var IFCFILLAREASTYLE = 738692330;
var IFCFILLAREASTYLEHATCHING = 374418227;
var IFCFILLAREASTYLETILES = 315944413;
var IFCFILTER = 819412036;
var IFCFILTERTYPE = 1810631287;
var IFCFIRESUPPRESSIONTERMINAL = 1426591983;
var IFCFIRESUPPRESSIONTERMINALTYPE = 4222183408;
var IFCFIXEDREFERENCESWEPTAREASOLID = 2652556860;
var IFCFLOWCONTROLLER = 2058353004;
var IFCFLOWCONTROLLERTYPE = 3907093117;
var IFCFLOWFITTING = 4278956645;
var IFCFLOWFITTINGTYPE = 3198132628;
var IFCFLOWINSTRUMENT = 182646315;
var IFCFLOWINSTRUMENTTYPE = 4037862832;
var IFCFLOWMETER = 2188021234;
var IFCFLOWMETERTYPE = 3815607619;
var IFCFLOWMOVINGDEVICE = 3132237377;
var IFCFLOWMOVINGDEVICETYPE = 1482959167;
var IFCFLOWSEGMENT = 987401354;
var IFCFLOWSEGMENTTYPE = 1834744321;
var IFCFLOWSTORAGEDEVICE = 707683696;
var IFCFLOWSTORAGEDEVICETYPE = 1339347760;
var IFCFLOWTERMINAL = 2223149337;
var IFCFLOWTERMINALTYPE = 2297155007;
var IFCFLOWTREATMENTDEVICE = 3508470533;
var IFCFLOWTREATMENTDEVICETYPE = 3009222698;
var IFCFOOTING = 900683007;
var IFCFOOTINGTYPE = 1893162501;
var IFCFURNISHINGELEMENT = 263784265;
var IFCFURNISHINGELEMENTTYPE = 4238390223;
var IFCFURNITURE = 1509553395;
var IFCFURNITURETYPE = 1268542332;
var IFCGEOGRAPHICELEMENT = 3493046030;
var IFCGEOGRAPHICELEMENTTYPE = 4095422895;
var IFCGEOMETRICCURVESET = 987898635;
var IFCGEOMETRICREPRESENTATIONCONTEXT = 3448662350;
var IFCGEOMETRICREPRESENTATIONITEM = 2453401579;
var IFCGEOMETRICREPRESENTATIONSUBCONTEXT = 4142052618;
var IFCGEOMETRICSET = 3590301190;
var IFCGRID = 3009204131;
var IFCGRIDAXIS = 852622518;
var IFCGRIDPLACEMENT = 178086475;
var IFCGROUP = 2706460486;
var IFCHALFSPACESOLID = 812098782;
var IFCHEATEXCHANGER = 3319311131;
var IFCHEATEXCHANGERTYPE = 1251058090;
var IFCHUMIDIFIER = 2068733104;
var IFCHUMIDIFIERTYPE = 1806887404;
var IFCISHAPEPROFILEDEF = 1484403080;
var IFCIMAGETEXTURE = 3905492369;
var IFCINDEXEDCOLOURMAP = 3570813810;
var IFCINDEXEDPOLYCURVE = 2571569899;
var IFCINDEXEDPOLYGONALFACE = 178912537;
var IFCINDEXEDPOLYGONALFACEWITHVOIDS = 2294589976;
var IFCINDEXEDTEXTUREMAP = 1437953363;
var IFCINDEXEDTRIANGLETEXTUREMAP = 2133299955;
var IFCINTERCEPTOR = 4175244083;
var IFCINTERCEPTORTYPE = 3946677679;
var IFCINTERSECTIONCURVE = 3113134337;
var IFCINVENTORY = 2391368822;
var IFCIRREGULARTIMESERIES = 3741457305;
var IFCIRREGULARTIMESERIESVALUE = 3020489413;
var IFCJUNCTIONBOX = 2176052936;
var IFCJUNCTIONBOXTYPE = 4288270099;
var IFCLSHAPEPROFILEDEF = 572779678;
var IFCLABORRESOURCE = 3827777499;
var IFCLABORRESOURCETYPE = 428585644;
var IFCLAGTIME = 1585845231;
var IFCLAMP = 76236018;
var IFCLAMPTYPE = 1051575348;
var IFCLIBRARYINFORMATION = 2655187982;
var IFCLIBRARYREFERENCE = 3452421091;
var IFCLIGHTDISTRIBUTIONDATA = 4162380809;
var IFCLIGHTFIXTURE = 629592764;
var IFCLIGHTFIXTURETYPE = 1161773419;
var IFCLIGHTINTENSITYDISTRIBUTION = 1566485204;
var IFCLIGHTSOURCE = 1402838566;
var IFCLIGHTSOURCEAMBIENT = 125510826;
var IFCLIGHTSOURCEDIRECTIONAL = 2604431987;
var IFCLIGHTSOURCEGONIOMETRIC = 4266656042;
var IFCLIGHTSOURCEPOSITIONAL = 1520743889;
var IFCLIGHTSOURCESPOT = 3422422726;
var IFCLINE = 1281925730;
var IFCLINESEGMENT2D = 3092502836;
var IFCLINEARPLACEMENT = 388784114;
var IFCLINEARPOSITIONINGELEMENT = 1154579445;
var IFCLOCALPLACEMENT = 2624227202;
var IFCLOOP = 1008929658;
var IFCMANIFOLDSOLIDBREP = 1425443689;
var IFCMAPCONVERSION = 3057273783;
var IFCMAPPEDITEM = 2347385850;
var IFCMATERIAL = 1838606355;
var IFCMATERIALCLASSIFICATIONRELATIONSHIP = 1847130766;
var IFCMATERIALCONSTITUENT = 3708119e3;
var IFCMATERIALCONSTITUENTSET = 2852063980;
var IFCMATERIALDEFINITION = 760658860;
var IFCMATERIALDEFINITIONREPRESENTATION = 2022407955;
var IFCMATERIALLAYER = 248100487;
var IFCMATERIALLAYERSET = 3303938423;
var IFCMATERIALLAYERSETUSAGE = 1303795690;
var IFCMATERIALLAYERWITHOFFSETS = 1847252529;
var IFCMATERIALLIST = 2199411900;
var IFCMATERIALPROFILE = 2235152071;
var IFCMATERIALPROFILESET = 164193824;
var IFCMATERIALPROFILESETUSAGE = 3079605661;
var IFCMATERIALPROFILESETUSAGETAPERING = 3404854881;
var IFCMATERIALPROFILEWITHOFFSETS = 552965576;
var IFCMATERIALPROPERTIES = 3265635763;
var IFCMATERIALRELATIONSHIP = 853536259;
var IFCMATERIALUSAGEDEFINITION = 1507914824;
var IFCMEASUREWITHUNIT = 2597039031;
var IFCMECHANICALFASTENER = 377706215;
var IFCMECHANICALFASTENERTYPE = 2108223431;
var IFCMEDICALDEVICE = 1437502449;
var IFCMEDICALDEVICETYPE = 1114901282;
var IFCMEMBER = 1073191201;
var IFCMEMBERSTANDARDCASE = 1911478936;
var IFCMEMBERTYPE = 3181161470;
var IFCMETRIC = 3368373690;
var IFCMIRROREDPROFILEDEF = 2998442950;
var IFCMONETARYUNIT = 2706619895;
var IFCMOTORCONNECTION = 2474470126;
var IFCMOTORCONNECTIONTYPE = 977012517;
var IFCNAMEDUNIT = 1918398963;
var IFCOBJECT = 3888040117;
var IFCOBJECTDEFINITION = 219451334;
var IFCOBJECTPLACEMENT = 3701648758;
var IFCOBJECTIVE = 2251480897;
var IFCOCCUPANT = 4143007308;
var IFCOFFSETCURVE = 590820931;
var IFCOFFSETCURVE2D = 3388369263;
var IFCOFFSETCURVE3D = 3505215534;
var IFCOFFSETCURVEBYDISTANCES = 2485787929;
var IFCOPENSHELL = 2665983363;
var IFCOPENINGELEMENT = 3588315303;
var IFCOPENINGSTANDARDCASE = 3079942009;
var IFCORGANIZATION = 4251960020;
var IFCORGANIZATIONRELATIONSHIP = 1411181986;
var IFCORIENTATIONEXPRESSION = 643959842;
var IFCORIENTEDEDGE = 1029017970;
var IFCOUTERBOUNDARYCURVE = 144952367;
var IFCOUTLET = 3694346114;
var IFCOUTLETTYPE = 2837617999;
var IFCOWNERHISTORY = 1207048766;
var IFCPARAMETERIZEDPROFILEDEF = 2529465313;
var IFCPATH = 2519244187;
var IFCPCURVE = 1682466193;
var IFCPERFORMANCEHISTORY = 2382730787;
var IFCPERMEABLECOVERINGPROPERTIES = 3566463478;
var IFCPERMIT = 3327091369;
var IFCPERSON = 2077209135;
var IFCPERSONANDORGANIZATION = 101040310;
var IFCPHYSICALCOMPLEXQUANTITY = 3021840470;
var IFCPHYSICALQUANTITY = 2483315170;
var IFCPHYSICALSIMPLEQUANTITY = 2226359599;
var IFCPILE = 1687234759;
var IFCPILETYPE = 1158309216;
var IFCPIPEFITTING = 310824031;
var IFCPIPEFITTINGTYPE = 804291784;
var IFCPIPESEGMENT = 3612865200;
var IFCPIPESEGMENTTYPE = 4231323485;
var IFCPIXELTEXTURE = 597895409;
var IFCPLACEMENT = 2004835150;
var IFCPLANARBOX = 603570806;
var IFCPLANAREXTENT = 1663979128;
var IFCPLANE = 220341763;
var IFCPLATE = 3171933400;
var IFCPLATESTANDARDCASE = 1156407060;
var IFCPLATETYPE = 4017108033;
var IFCPOINT = 2067069095;
var IFCPOINTONCURVE = 4022376103;
var IFCPOINTONSURFACE = 1423911732;
var IFCPOLYLOOP = 2924175390;
var IFCPOLYGONALBOUNDEDHALFSPACE = 2775532180;
var IFCPOLYGONALFACESET = 2839578677;
var IFCPOLYLINE = 3724593414;
var IFCPORT = 3740093272;
var IFCPOSITIONINGELEMENT = 1946335990;
var IFCPOSTALADDRESS = 3355820592;
var IFCPREDEFINEDCOLOUR = 759155922;
var IFCPREDEFINEDCURVEFONT = 2559016684;
var IFCPREDEFINEDITEM = 3727388367;
var IFCPREDEFINEDPROPERTIES = 3778827333;
var IFCPREDEFINEDPROPERTYSET = 3967405729;
var IFCPREDEFINEDTEXTFONT = 1775413392;
var IFCPRESENTATIONITEM = 677532197;
var IFCPRESENTATIONLAYERASSIGNMENT = 2022622350;
var IFCPRESENTATIONLAYERWITHSTYLE = 1304840413;
var IFCPRESENTATIONSTYLE = 3119450353;
var IFCPRESENTATIONSTYLEASSIGNMENT = 2417041796;
var IFCPROCEDURE = 2744685151;
var IFCPROCEDURETYPE = 569719735;
var IFCPROCESS = 2945172077;
var IFCPRODUCT = 4208778838;
var IFCPRODUCTDEFINITIONSHAPE = 673634403;
var IFCPRODUCTREPRESENTATION = 2095639259;
var IFCPROFILEDEF = 3958567839;
var IFCPROFILEPROPERTIES = 2802850158;
var IFCPROJECT = 103090709;
var IFCPROJECTLIBRARY = 653396225;
var IFCPROJECTORDER = 2904328755;
var IFCPROJECTEDCRS = 3843373140;
var IFCPROJECTIONELEMENT = 3651124850;
var IFCPROPERTY = 2598011224;
var IFCPROPERTYABSTRACTION = 986844984;
var IFCPROPERTYBOUNDEDVALUE = 871118103;
var IFCPROPERTYDEFINITION = 1680319473;
var IFCPROPERTYDEPENDENCYRELATIONSHIP = 148025276;
var IFCPROPERTYENUMERATEDVALUE = 4166981789;
var IFCPROPERTYENUMERATION = 3710013099;
var IFCPROPERTYLISTVALUE = 2752243245;
var IFCPROPERTYREFERENCEVALUE = 941946838;
var IFCPROPERTYSET = 1451395588;
var IFCPROPERTYSETDEFINITION = 3357820518;
var IFCPROPERTYSETTEMPLATE = 492091185;
var IFCPROPERTYSINGLEVALUE = 3650150729;
var IFCPROPERTYTABLEVALUE = 110355661;
var IFCPROPERTYTEMPLATE = 3521284610;
var IFCPROPERTYTEMPLATEDEFINITION = 1482703590;
var IFCPROTECTIVEDEVICE = 738039164;
var IFCPROTECTIVEDEVICETRIPPINGUNIT = 2295281155;
var IFCPROTECTIVEDEVICETRIPPINGUNITTYPE = 655969474;
var IFCPROTECTIVEDEVICETYPE = 1842657554;
var IFCPROXY = 3219374653;
var IFCPUMP = 90941305;
var IFCPUMPTYPE = 2250791053;
var IFCQUANTITYAREA = 2044713172;
var IFCQUANTITYCOUNT = 2093928680;
var IFCQUANTITYLENGTH = 931644368;
var IFCQUANTITYSET = 2090586900;
var IFCQUANTITYTIME = 3252649465;
var IFCQUANTITYVOLUME = 2405470396;
var IFCQUANTITYWEIGHT = 825690147;
var IFCRAILING = 2262370178;
var IFCRAILINGTYPE = 2893384427;
var IFCRAMP = 3024970846;
var IFCRAMPFLIGHT = 3283111854;
var IFCRAMPFLIGHTTYPE = 2324767716;
var IFCRAMPTYPE = 1469900589;
var IFCRATIONALBSPLINECURVEWITHKNOTS = 1232101972;
var IFCRATIONALBSPLINESURFACEWITHKNOTS = 683857671;
var IFCRECTANGLEHOLLOWPROFILEDEF = 2770003689;
var IFCRECTANGLEPROFILEDEF = 3615266464;
var IFCRECTANGULARPYRAMID = 2798486643;
var IFCRECTANGULARTRIMMEDSURFACE = 3454111270;
var IFCRECURRENCEPATTERN = 3915482550;
var IFCREFERENCE = 2433181523;
var IFCREFERENT = 4021432810;
var IFCREGULARTIMESERIES = 3413951693;
var IFCREINFORCEMENTBARPROPERTIES = 1580146022;
var IFCREINFORCEMENTDEFINITIONPROPERTIES = 3765753017;
var IFCREINFORCINGBAR = 979691226;
var IFCREINFORCINGBARTYPE = 2572171363;
var IFCREINFORCINGELEMENT = 3027567501;
var IFCREINFORCINGELEMENTTYPE = 964333572;
var IFCREINFORCINGMESH = 2320036040;
var IFCREINFORCINGMESHTYPE = 2310774935;
var IFCRELAGGREGATES = 160246688;
var IFCRELASSIGNS = 3939117080;
var IFCRELASSIGNSTOACTOR = 1683148259;
var IFCRELASSIGNSTOCONTROL = 2495723537;
var IFCRELASSIGNSTOGROUP = 1307041759;
var IFCRELASSIGNSTOGROUPBYFACTOR = 1027710054;
var IFCRELASSIGNSTOPROCESS = 4278684876;
var IFCRELASSIGNSTOPRODUCT = 2857406711;
var IFCRELASSIGNSTORESOURCE = 205026976;
var IFCRELASSOCIATES = 1865459582;
var IFCRELASSOCIATESAPPROVAL = 4095574036;
var IFCRELASSOCIATESCLASSIFICATION = 919958153;
var IFCRELASSOCIATESCONSTRAINT = 2728634034;
var IFCRELASSOCIATESDOCUMENT = 982818633;
var IFCRELASSOCIATESLIBRARY = 3840914261;
var IFCRELASSOCIATESMATERIAL = 2655215786;
var IFCRELCONNECTS = 826625072;
var IFCRELCONNECTSELEMENTS = 1204542856;
var IFCRELCONNECTSPATHELEMENTS = 3945020480;
var IFCRELCONNECTSPORTTOELEMENT = 4201705270;
var IFCRELCONNECTSPORTS = 3190031847;
var IFCRELCONNECTSSTRUCTURALACTIVITY = 2127690289;
var IFCRELCONNECTSSTRUCTURALMEMBER = 1638771189;
var IFCRELCONNECTSWITHECCENTRICITY = 504942748;
var IFCRELCONNECTSWITHREALIZINGELEMENTS = 3678494232;
var IFCRELCONTAINEDINSPATIALSTRUCTURE = 3242617779;
var IFCRELCOVERSBLDGELEMENTS = 886880790;
var IFCRELCOVERSSPACES = 2802773753;
var IFCRELDECLARES = 2565941209;
var IFCRELDECOMPOSES = 2551354335;
var IFCRELDEFINES = 693640335;
var IFCRELDEFINESBYOBJECT = 1462361463;
var IFCRELDEFINESBYPROPERTIES = 4186316022;
var IFCRELDEFINESBYTEMPLATE = 307848117;
var IFCRELDEFINESBYTYPE = 781010003;
var IFCRELFILLSELEMENT = 3940055652;
var IFCRELFLOWCONTROLELEMENTS = 279856033;
var IFCRELINTERFERESELEMENTS = 427948657;
var IFCRELNESTS = 3268803585;
var IFCRELPOSITIONS = 1441486842;
var IFCRELPROJECTSELEMENT = 750771296;
var IFCRELREFERENCEDINSPATIALSTRUCTURE = 1245217292;
var IFCRELSEQUENCE = 4122056220;
var IFCRELSERVICESBUILDINGS = 366585022;
var IFCRELSPACEBOUNDARY = 3451746338;
var IFCRELSPACEBOUNDARY1STLEVEL = 3523091289;
var IFCRELSPACEBOUNDARY2NDLEVEL = 1521410863;
var IFCRELVOIDSELEMENT = 1401173127;
var IFCRELATIONSHIP = 478536968;
var IFCREPARAMETRISEDCOMPOSITECURVESEGMENT = 816062949;
var IFCREPRESENTATION = 1076942058;
var IFCREPRESENTATIONCONTEXT = 3377609919;
var IFCREPRESENTATIONITEM = 3008791417;
var IFCREPRESENTATIONMAP = 1660063152;
var IFCRESOURCE = 2914609552;
var IFCRESOURCEAPPROVALRELATIONSHIP = 2943643501;
var IFCRESOURCECONSTRAINTRELATIONSHIP = 1608871552;
var IFCRESOURCELEVELRELATIONSHIP = 2439245199;
var IFCRESOURCETIME = 1042787934;
var IFCREVOLVEDAREASOLID = 1856042241;
var IFCREVOLVEDAREASOLIDTAPERED = 3243963512;
var IFCRIGHTCIRCULARCONE = 4158566097;
var IFCRIGHTCIRCULARCYLINDER = 3626867408;
var IFCROOF = 2016517767;
var IFCROOFTYPE = 2781568857;
var IFCROOT = 2341007311;
var IFCROUNDEDRECTANGLEPROFILEDEF = 2778083089;
var IFCSIUNIT = 448429030;
var IFCSANITARYTERMINAL = 3053780830;
var IFCSANITARYTERMINALTYPE = 1768891740;
var IFCSCHEDULINGTIME = 1054537805;
var IFCSEAMCURVE = 2157484638;
var IFCSECTIONPROPERTIES = 2042790032;
var IFCSECTIONREINFORCEMENTPROPERTIES = 4165799628;
var IFCSECTIONEDSOLID = 1862484736;
var IFCSECTIONEDSOLIDHORIZONTAL = 1290935644;
var IFCSECTIONEDSPINE = 1509187699;
var IFCSENSOR = 4086658281;
var IFCSENSORTYPE = 1783015770;
var IFCSHADINGDEVICE = 1329646415;
var IFCSHADINGDEVICETYPE = 4074543187;
var IFCSHAPEASPECT = 867548509;
var IFCSHAPEMODEL = 3982875396;
var IFCSHAPEREPRESENTATION = 4240577450;
var IFCSHELLBASEDSURFACEMODEL = 4124623270;
var IFCSIMPLEPROPERTY = 3692461612;
var IFCSIMPLEPROPERTYTEMPLATE = 3663146110;
var IFCSITE = 4097777520;
var IFCSLAB = 1529196076;
var IFCSLABELEMENTEDCASE = 3127900445;
var IFCSLABSTANDARDCASE = 3027962421;
var IFCSLABTYPE = 2533589738;
var IFCSLIPPAGECONNECTIONCONDITION = 2609359061;
var IFCSOLARDEVICE = 3420628829;
var IFCSOLARDEVICETYPE = 1072016465;
var IFCSOLIDMODEL = 723233188;
var IFCSPACE = 3856911033;
var IFCSPACEHEATER = 1999602285;
var IFCSPACEHEATERTYPE = 1305183839;
var IFCSPACETYPE = 3812236995;
var IFCSPATIALELEMENT = 1412071761;
var IFCSPATIALELEMENTTYPE = 710998568;
var IFCSPATIALSTRUCTUREELEMENT = 2706606064;
var IFCSPATIALSTRUCTUREELEMENTTYPE = 3893378262;
var IFCSPATIALZONE = 463610769;
var IFCSPATIALZONETYPE = 2481509218;
var IFCSPHERE = 451544542;
var IFCSPHERICALSURFACE = 4015995234;
var IFCSTACKTERMINAL = 1404847402;
var IFCSTACKTERMINALTYPE = 3112655638;
var IFCSTAIR = 331165859;
var IFCSTAIRFLIGHT = 4252922144;
var IFCSTAIRFLIGHTTYPE = 1039846685;
var IFCSTAIRTYPE = 338393293;
var IFCSTRUCTURALACTION = 682877961;
var IFCSTRUCTURALACTIVITY = 3544373492;
var IFCSTRUCTURALANALYSISMODEL = 2515109513;
var IFCSTRUCTURALCONNECTION = 1179482911;
var IFCSTRUCTURALCONNECTIONCONDITION = 2273995522;
var IFCSTRUCTURALCURVEACTION = 1004757350;
var IFCSTRUCTURALCURVECONNECTION = 4243806635;
var IFCSTRUCTURALCURVEMEMBER = 214636428;
var IFCSTRUCTURALCURVEMEMBERVARYING = 2445595289;
var IFCSTRUCTURALCURVEREACTION = 2757150158;
var IFCSTRUCTURALITEM = 3136571912;
var IFCSTRUCTURALLINEARACTION = 1807405624;
var IFCSTRUCTURALLOAD = 2162789131;
var IFCSTRUCTURALLOADCASE = 385403989;
var IFCSTRUCTURALLOADCONFIGURATION = 3478079324;
var IFCSTRUCTURALLOADGROUP = 1252848954;
var IFCSTRUCTURALLOADLINEARFORCE = 1595516126;
var IFCSTRUCTURALLOADORRESULT = 609421318;
var IFCSTRUCTURALLOADPLANARFORCE = 2668620305;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENT = 2473145415;
var IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION = 1973038258;
var IFCSTRUCTURALLOADSINGLEFORCE = 1597423693;
var IFCSTRUCTURALLOADSINGLEFORCEWARPING = 1190533807;
var IFCSTRUCTURALLOADSTATIC = 2525727697;
var IFCSTRUCTURALLOADTEMPERATURE = 3408363356;
var IFCSTRUCTURALMEMBER = 530289379;
var IFCSTRUCTURALPLANARACTION = 1621171031;
var IFCSTRUCTURALPOINTACTION = 2082059205;
var IFCSTRUCTURALPOINTCONNECTION = 734778138;
var IFCSTRUCTURALPOINTREACTION = 1235345126;
var IFCSTRUCTURALREACTION = 3689010777;
var IFCSTRUCTURALRESULTGROUP = 2986769608;
var IFCSTRUCTURALSURFACEACTION = 3657597509;
var IFCSTRUCTURALSURFACECONNECTION = 1975003073;
var IFCSTRUCTURALSURFACEMEMBER = 3979015343;
var IFCSTRUCTURALSURFACEMEMBERVARYING = 2218152070;
var IFCSTRUCTURALSURFACEREACTION = 603775116;
var IFCSTYLEMODEL = 2830218821;
var IFCSTYLEDITEM = 3958052878;
var IFCSTYLEDREPRESENTATION = 3049322572;
var IFCSUBCONTRACTRESOURCE = 148013059;
var IFCSUBCONTRACTRESOURCETYPE = 4095615324;
var IFCSUBEDGE = 2233826070;
var IFCSURFACE = 2513912981;
var IFCSURFACECURVE = 699246055;
var IFCSURFACECURVESWEPTAREASOLID = 2028607225;
var IFCSURFACEFEATURE = 3101698114;
var IFCSURFACEOFLINEAREXTRUSION = 2809605785;
var IFCSURFACEOFREVOLUTION = 4124788165;
var IFCSURFACEREINFORCEMENTAREA = 2934153892;
var IFCSURFACESTYLE = 1300840506;
var IFCSURFACESTYLELIGHTING = 3303107099;
var IFCSURFACESTYLEREFRACTION = 1607154358;
var IFCSURFACESTYLERENDERING = 1878645084;
var IFCSURFACESTYLESHADING = 846575682;
var IFCSURFACESTYLEWITHTEXTURES = 1351298697;
var IFCSURFACETEXTURE = 626085974;
var IFCSWEPTAREASOLID = 2247615214;
var IFCSWEPTDISKSOLID = 1260650574;
var IFCSWEPTDISKSOLIDPOLYGONAL = 1096409881;
var IFCSWEPTSURFACE = 230924584;
var IFCSWITCHINGDEVICE = 1162798199;
var IFCSWITCHINGDEVICETYPE = 2315554128;
var IFCSYSTEM = 2254336722;
var IFCSYSTEMFURNITUREELEMENT = 413509423;
var IFCSYSTEMFURNITUREELEMENTTYPE = 1580310250;
var IFCTSHAPEPROFILEDEF = 3071757647;
var IFCTABLE = 985171141;
var IFCTABLECOLUMN = 2043862942;
var IFCTABLEROW = 531007025;
var IFCTANK = 812556717;
var IFCTANKTYPE = 5716631;
var IFCTASK = 3473067441;
var IFCTASKTIME = 1549132990;
var IFCTASKTIMERECURRING = 2771591690;
var IFCTASKTYPE = 3206491090;
var IFCTELECOMADDRESS = 912023232;
var IFCTENDON = 3824725483;
var IFCTENDONANCHOR = 2347447852;
var IFCTENDONANCHORTYPE = 3081323446;
var IFCTENDONCONDUIT = 3663046924;
var IFCTENDONCONDUITTYPE = 2281632017;
var IFCTENDONTYPE = 2415094496;
var IFCTESSELLATEDFACESET = 2387106220;
var IFCTESSELLATEDITEM = 901063453;
var IFCTEXTLITERAL = 4282788508;
var IFCTEXTLITERALWITHEXTENT = 3124975700;
var IFCTEXTSTYLE = 1447204868;
var IFCTEXTSTYLEFONTMODEL = 1983826977;
var IFCTEXTSTYLEFORDEFINEDFONT = 2636378356;
var IFCTEXTSTYLETEXTMODEL = 1640371178;
var IFCTEXTURECOORDINATE = 280115917;
var IFCTEXTURECOORDINATEGENERATOR = 1742049831;
var IFCTEXTUREMAP = 2552916305;
var IFCTEXTUREVERTEX = 1210645708;
var IFCTEXTUREVERTEXLIST = 3611470254;
var IFCTIMEPERIOD = 1199560280;
var IFCTIMESERIES = 3101149627;
var IFCTIMESERIESVALUE = 581633288;
var IFCTOPOLOGICALREPRESENTATIONITEM = 1377556343;
var IFCTOPOLOGYREPRESENTATION = 1735638870;
var IFCTOROIDALSURFACE = 1935646853;
var IFCTRANSFORMER = 3825984169;
var IFCTRANSFORMERTYPE = 1692211062;
var IFCTRANSITIONCURVESEGMENT2D = 2595432518;
var IFCTRANSPORTELEMENT = 1620046519;
var IFCTRANSPORTELEMENTTYPE = 2097647324;
var IFCTRAPEZIUMPROFILEDEF = 2715220739;
var IFCTRIANGULATEDFACESET = 2916149573;
var IFCTRIANGULATEDIRREGULARNETWORK = 1229763772;
var IFCTRIMMEDCURVE = 3593883385;
var IFCTUBEBUNDLE = 3026737570;
var IFCTUBEBUNDLETYPE = 1600972822;
var IFCTYPEOBJECT = 1628702193;
var IFCTYPEPROCESS = 3736923433;
var IFCTYPEPRODUCT = 2347495698;
var IFCTYPERESOURCE = 3698973494;
var IFCUSHAPEPROFILEDEF = 427810014;
var IFCUNITASSIGNMENT = 180925521;
var IFCUNITARYCONTROLELEMENT = 630975310;
var IFCUNITARYCONTROLELEMENTTYPE = 3179687236;
var IFCUNITARYEQUIPMENT = 4292641817;
var IFCUNITARYEQUIPMENTTYPE = 1911125066;
var IFCVALVE = 4207607924;
var IFCVALVETYPE = 728799441;
var IFCVECTOR = 1417489154;
var IFCVERTEX = 2799835756;
var IFCVERTEXLOOP = 2759199220;
var IFCVERTEXPOINT = 1907098498;
var IFCVIBRATIONDAMPER = 1530820697;
var IFCVIBRATIONDAMPERTYPE = 3956297820;
var IFCVIBRATIONISOLATOR = 2391383451;
var IFCVIBRATIONISOLATORTYPE = 3313531582;
var IFCVIRTUALELEMENT = 2769231204;
var IFCVIRTUALGRIDINTERSECTION = 891718957;
var IFCVOIDINGFEATURE = 926996030;
var IFCWALL = 2391406946;
var IFCWALLELEMENTEDCASE = 4156078855;
var IFCWALLSTANDARDCASE = 3512223829;
var IFCWALLTYPE = 1898987631;
var IFCWASTETERMINAL = 4237592921;
var IFCWASTETERMINALTYPE = 1133259667;
var IFCWINDOW = 3304561284;
var IFCWINDOWLININGPROPERTIES = 336235671;
var IFCWINDOWPANELPROPERTIES = 512836454;
var IFCWINDOWSTANDARDCASE = 486154966;
var IFCWINDOWSTYLE = 1299126871;
var IFCWINDOWTYPE = 4009809668;
var IFCWORKCALENDAR = 4088093105;
var IFCWORKCONTROL = 1028945134;
var IFCWORKPLAN = 4218914973;
var IFCWORKSCHEDULE = 3342526732;
var IFCWORKTIME = 1236880293;
var IFCZSHAPEPROFILEDEF = 2543172580;
var IFCZONE = 1033361043;
var IfcElements$1 = [
  IFCACTUATOR,
  IFCAIRTERMINAL,
  IFCAIRTERMINALBOX,
  IFCAIRTOAIRHEATRECOVERY,
  IFCALARM,
  IFCALIGNMENT,
  IFCANNOTATION,
  IFCAUDIOVISUALAPPLIANCE,
  IFCBEAM,
  IFCBEAMSTANDARDCASE,
  IFCBEARING,
  IFCBOILER,
  IFCBRIDGE,
  IFCBRIDGEPART,
  IFCBUILDING,
  IFCBUILDINGELEMENT,
  IFCBUILDINGELEMENTPART,
  IFCBUILDINGELEMENTPROXY,
  IFCBUILDINGSTOREY,
  IFCBURNER,
  IFCCABLECARRIERFITTING,
  IFCCABLECARRIERSEGMENT,
  IFCCABLEFITTING,
  IFCCABLESEGMENT,
  IFCCAISSONFOUNDATION,
  IFCCHILLER,
  IFCCHIMNEY,
  IFCCIVILELEMENT,
  IFCCOIL,
  IFCCOLUMN,
  IFCCOLUMNSTANDARDCASE,
  IFCCOMMUNICATIONSAPPLIANCE,
  IFCCOMPRESSOR,
  IFCCONDENSER,
  IFCCONTROLLER,
  IFCCOOLEDBEAM,
  IFCCOOLINGTOWER,
  IFCCOVERING,
  IFCCURTAINWALL,
  IFCDAMPER,
  IFCDEEPFOUNDATION,
  IFCDISCRETEACCESSORY,
  IFCDISTRIBUTIONCHAMBERELEMENT,
  IFCDISTRIBUTIONCONTROLELEMENT,
  IFCDISTRIBUTIONELEMENT,
  IFCDISTRIBUTIONFLOWELEMENT,
  IFCDISTRIBUTIONPORT,
  IFCDOOR,
  IFCDOORSTANDARDCASE,
  IFCDUCTFITTING,
  IFCDUCTSEGMENT,
  IFCDUCTSILENCER,
  IFCELECTRICAPPLIANCE,
  IFCELECTRICDISTRIBUTIONBOARD,
  IFCELECTRICFLOWSTORAGEDEVICE,
  IFCELECTRICGENERATOR,
  IFCELECTRICMOTOR,
  IFCELECTRICTIMECONTROL,
  IFCELEMENT,
  IFCELEMENTASSEMBLY,
  IFCELEMENTCOMPONENT,
  IFCENERGYCONVERSIONDEVICE,
  IFCENGINE,
  IFCEVAPORATIVECOOLER,
  IFCEVAPORATOR,
  IFCEXTERNALSPATIALELEMENT,
  IFCEXTERNALSPATIALSTRUCTUREELEMENT,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCFAN,
  IFCFASTENER,
  IFCFEATUREELEMENT,
  IFCFEATUREELEMENTADDITION,
  IFCFEATUREELEMENTSUBTRACTION,
  IFCFILTER,
  IFCFIRESUPPRESSIONTERMINAL,
  IFCFLOWCONTROLLER,
  IFCFLOWFITTING,
  IFCFLOWINSTRUMENT,
  IFCFLOWMETER,
  IFCFLOWMOVINGDEVICE,
  IFCFLOWSEGMENT,
  IFCFLOWSTORAGEDEVICE,
  IFCFLOWTERMINAL,
  IFCFLOWTREATMENTDEVICE,
  IFCFOOTING,
  IFCFURNISHINGELEMENT,
  IFCFURNITURE,
  IFCGEOGRAPHICELEMENT,
  IFCGRID,
  IFCHEATEXCHANGER,
  IFCHUMIDIFIER,
  IFCINTERCEPTOR,
  IFCJUNCTIONBOX,
  IFCLAMP,
  IFCLIGHTFIXTURE,
  IFCLINEARPOSITIONINGELEMENT,
  IFCMECHANICALFASTENER,
  IFCMEDICALDEVICE,
  IFCMEMBER,
  IFCMEMBERSTANDARDCASE,
  IFCMOTORCONNECTION,
  IFCOPENINGELEMENT,
  IFCOPENINGSTANDARDCASE,
  IFCOUTLET,
  IFCPILE,
  IFCPIPEFITTING,
  IFCPIPESEGMENT,
  IFCPLATE,
  IFCPLATESTANDARDCASE,
  IFCPORT,
  IFCPOSITIONINGELEMENT,
  IFCPROJECTIONELEMENT,
  IFCPROTECTIVEDEVICE,
  IFCPROTECTIVEDEVICETRIPPINGUNIT,
  IFCPROXY,
  IFCPUMP,
  IFCRAILING,
  IFCRAMP,
  IFCRAMPFLIGHT,
  IFCREFERENT,
  IFCREINFORCINGBAR,
  IFCREINFORCINGELEMENT,
  IFCREINFORCINGMESH,
  IFCROOF,
  IFCSANITARYTERMINAL,
  IFCSENSOR,
  IFCSHADINGDEVICE,
  IFCSITE,
  IFCSLAB,
  IFCSLABELEMENTEDCASE,
  IFCSLABSTANDARDCASE,
  IFCSOLARDEVICE,
  IFCSPACE,
  IFCSPACEHEATER,
  IFCSPATIALELEMENT,
  IFCSPATIALSTRUCTUREELEMENT,
  IFCSPATIALZONE,
  IFCSTACKTERMINAL,
  IFCSTAIR,
  IFCSTAIRFLIGHT,
  IFCSTRUCTURALACTION,
  IFCSTRUCTURALACTIVITY,
  IFCSTRUCTURALCONNECTION,
  IFCSTRUCTURALCURVEACTION,
  IFCSTRUCTURALCURVECONNECTION,
  IFCSTRUCTURALCURVEMEMBER,
  IFCSTRUCTURALCURVEMEMBERVARYING,
  IFCSTRUCTURALCURVEREACTION,
  IFCSTRUCTURALITEM,
  IFCSTRUCTURALLINEARACTION,
  IFCSTRUCTURALMEMBER,
  IFCSTRUCTURALPLANARACTION,
  IFCSTRUCTURALPOINTACTION,
  IFCSTRUCTURALPOINTCONNECTION,
  IFCSTRUCTURALPOINTREACTION,
  IFCSTRUCTURALREACTION,
  IFCSTRUCTURALSURFACEACTION,
  IFCSTRUCTURALSURFACECONNECTION,
  IFCSTRUCTURALSURFACEMEMBER,
  IFCSTRUCTURALSURFACEMEMBERVARYING,
  IFCSTRUCTURALSURFACEREACTION,
  IFCSURFACEFEATURE,
  IFCSWITCHINGDEVICE,
  IFCSYSTEMFURNITUREELEMENT,
  IFCTANK,
  IFCTENDON,
  IFCTENDONANCHOR,
  IFCTENDONCONDUIT,
  IFCTRANSFORMER,
  IFCTRANSPORTELEMENT,
  IFCTUBEBUNDLE,
  IFCUNITARYCONTROLELEMENT,
  IFCUNITARYEQUIPMENT,
  IFCVALVE,
  IFCVIBRATIONDAMPER,
  IFCVIBRATIONISOLATOR,
  IFCVIRTUALELEMENT,
  IFCVOIDINGFEATURE,
  IFCWALL,
  IFCWALLELEMENTEDCASE,
  IFCWALLSTANDARDCASE,
  IFCWASTETERMINAL,
  IFCWINDOW,
  IFCWINDOWSTANDARDCASE
];

// dist/ifc2x4_helper.ts
var FromRawLineData = {};
FromRawLineData[IFCACTIONREQUEST] = (d) => {
  return IfcActionRequest.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTOR] = (d) => {
  return IfcActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTORROLE] = (d) => {
  return IfcActorRole.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATOR] = (d) => {
  return IfcActuator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCACTUATORTYPE] = (d) => {
  return IfcActuatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADDRESS] = (d) => {
  return IfcAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREP] = (d) => {
  return IfcAdvancedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDBREPWITHVOIDS] = (d) => {
  return IfcAdvancedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCADVANCEDFACE] = (d) => {
  return IfcAdvancedFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINAL] = (d) => {
  return IfcAirTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOX] = (d) => {
  return IfcAirTerminalBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALBOXTYPE] = (d) => {
  return IfcAirTerminalBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTERMINALTYPE] = (d) => {
  return IfcAirTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERY] = (d) => {
  return IfcAirToAirHeatRecovery.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAIRTOAIRHEATRECOVERYTYPE] = (d) => {
  return IfcAirToAirHeatRecoveryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARM] = (d) => {
  return IfcAlarm.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALARMTYPE] = (d) => {
  return IfcAlarmType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT] = (d) => {
  return IfcAlignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTAL] = (d) => {
  return IfcAlignment2DHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DHORIZONTALSEGMENT] = (d) => {
  return IfcAlignment2DHorizontalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DSEGMENT] = (d) => {
  return IfcAlignment2DSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGCIRCULARARC] = (d) => {
  return IfcAlignment2DVerSegCircularArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGLINE] = (d) => {
  return IfcAlignment2DVerSegLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERSEGPARABOLICARC] = (d) => {
  return IfcAlignment2DVerSegParabolicArc.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICAL] = (d) => {
  return IfcAlignment2DVertical.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENT2DVERTICALSEGMENT] = (d) => {
  return IfcAlignment2DVerticalSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCALIGNMENTCURVE] = (d) => {
  return IfcAlignmentCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATION] = (d) => {
  return IfcAnnotation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCANNOTATIONFILLAREA] = (d) => {
  return IfcAnnotationFillArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLICATION] = (d) => {
  return IfcApplication.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPLIEDVALUE] = (d) => {
  return IfcAppliedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVAL] = (d) => {
  return IfcApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAPPROVALRELATIONSHIP] = (d) => {
  return IfcApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYCLOSEDPROFILEDEF] = (d) => {
  return IfcArbitraryClosedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYOPENPROFILEDEF] = (d) => {
  return IfcArbitraryOpenProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCARBITRARYPROFILEDEFWITHVOIDS] = (d) => {
  return IfcArbitraryProfileDefWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASSET] = (d) => {
  return IfcAsset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCASYMMETRICISHAPEPROFILEDEF] = (d) => {
  return IfcAsymmetricIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCE] = (d) => {
  return IfcAudioVisualAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAUDIOVISUALAPPLIANCETYPE] = (d) => {
  return IfcAudioVisualApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS1PLACEMENT] = (d) => {
  return IfcAxis1Placement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT2D] = (d) => {
  return IfcAxis2Placement2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCAXIS2PLACEMENT3D] = (d) => {
  return IfcAxis2Placement3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVE] = (d) => {
  return IfcBSplineCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACE] = (d) => {
  return IfcBSplineSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAM] = (d) => {
  return IfcBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMSTANDARDCASE] = (d) => {
  return IfcBeamStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEAMTYPE] = (d) => {
  return IfcBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARING] = (d) => {
  return IfcBearing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBEARINGTYPE] = (d) => {
  return IfcBearingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOBTEXTURE] = (d) => {
  return IfcBlobTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBLOCK] = (d) => {
  return IfcBlock.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILER] = (d) => {
  return IfcBoiler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOILERTYPE] = (d) => {
  return IfcBoilerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANCLIPPINGRESULT] = (d) => {
  return IfcBooleanClippingResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOOLEANRESULT] = (d) => {
  return IfcBooleanResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCONDITION] = (d) => {
  return IfcBoundaryCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYCURVE] = (d) => {
  return IfcBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYEDGECONDITION] = (d) => {
  return IfcBoundaryEdgeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYFACECONDITION] = (d) => {
  return IfcBoundaryFaceCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITION] = (d) => {
  return IfcBoundaryNodeCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDARYNODECONDITIONWARPING] = (d) => {
  return IfcBoundaryNodeConditionWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDCURVE] = (d) => {
  return IfcBoundedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDEDSURFACE] = (d) => {
  return IfcBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOUNDINGBOX] = (d) => {
  return IfcBoundingBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBOXEDHALFSPACE] = (d) => {
  return IfcBoxedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGE] = (d) => {
  return IfcBridge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBRIDGEPART] = (d) => {
  return IfcBridgePart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDING] = (d) => {
  return IfcBuilding.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENT] = (d) => {
  return IfcBuildingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPART] = (d) => {
  return IfcBuildingElementPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPARTTYPE] = (d) => {
  return IfcBuildingElementPartType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXY] = (d) => {
  return IfcBuildingElementProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTPROXYTYPE] = (d) => {
  return IfcBuildingElementProxyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGELEMENTTYPE] = (d) => {
  return IfcBuildingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSTOREY] = (d) => {
  return IfcBuildingStorey.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBUILDINGSYSTEM] = (d) => {
  return IfcBuildingSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNER] = (d) => {
  return IfcBurner.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCBURNERTYPE] = (d) => {
  return IfcBurnerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSHAPEPROFILEDEF] = (d) => {
  return IfcCShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTING] = (d) => {
  return IfcCableCarrierFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERFITTINGTYPE] = (d) => {
  return IfcCableCarrierFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENT] = (d) => {
  return IfcCableCarrierSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLECARRIERSEGMENTTYPE] = (d) => {
  return IfcCableCarrierSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTING] = (d) => {
  return IfcCableFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLEFITTINGTYPE] = (d) => {
  return IfcCableFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENT] = (d) => {
  return IfcCableSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCABLESEGMENTTYPE] = (d) => {
  return IfcCableSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATION] = (d) => {
  return IfcCaissonFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCAISSONFOUNDATIONTYPE] = (d) => {
  return IfcCaissonFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINT] = (d) => {
  return IfcCartesianPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST] = (d) => {
  return IfcCartesianPointList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST2D] = (d) => {
  return IfcCartesianPointList2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANPOINTLIST3D] = (d) => {
  return IfcCartesianPointList3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR] = (d) => {
  return IfcCartesianTransformationOperator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2D] = (d) => {
  return IfcCartesianTransformationOperator2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator2DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3D] = (d) => {
  return IfcCartesianTransformationOperator3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM] = (d) => {
  return IfcCartesianTransformationOperator3DnonUniform.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCENTERLINEPROFILEDEF] = (d) => {
  return IfcCenterLineProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLER] = (d) => {
  return IfcChiller.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHILLERTYPE] = (d) => {
  return IfcChillerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEY] = (d) => {
  return IfcChimney.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCHIMNEYTYPE] = (d) => {
  return IfcChimneyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLE] = (d) => {
  return IfcCircle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEHOLLOWPROFILEDEF] = (d) => {
  return IfcCircleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCLEPROFILEDEF] = (d) => {
  return IfcCircleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIRCULARARCSEGMENT2D] = (d) => {
  return IfcCircularArcSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENT] = (d) => {
  return IfcCivilElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCIVILELEMENTTYPE] = (d) => {
  return IfcCivilElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATION] = (d) => {
  return IfcClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLASSIFICATIONREFERENCE] = (d) => {
  return IfcClassificationReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCLOSEDSHELL] = (d) => {
  return IfcClosedShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOIL] = (d) => {
  return IfcCoil.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOILTYPE] = (d) => {
  return IfcCoilType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGB] = (d) => {
  return IfcColourRgb.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURRGBLIST] = (d) => {
  return IfcColourRgbList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLOURSPECIFICATION] = (d) => {
  return IfcColourSpecification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMN] = (d) => {
  return IfcColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNSTANDARDCASE] = (d) => {
  return IfcColumnStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOLUMNTYPE] = (d) => {
  return IfcColumnType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCE] = (d) => {
  return IfcCommunicationsAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMMUNICATIONSAPPLIANCETYPE] = (d) => {
  return IfcCommunicationsApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTY] = (d) => {
  return IfcComplexProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPLEXPROPERTYTEMPLATE] = (d) => {
  return IfcComplexPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVE] = (d) => {
  return IfcCompositeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVEONSURFACE] = (d) => {
  return IfcCompositeCurveOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITECURVESEGMENT] = (d) => {
  return IfcCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPOSITEPROFILEDEF] = (d) => {
  return IfcCompositeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSOR] = (d) => {
  return IfcCompressor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOMPRESSORTYPE] = (d) => {
  return IfcCompressorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSER] = (d) => {
  return IfcCondenser.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONDENSERTYPE] = (d) => {
  return IfcCondenserType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONIC] = (d) => {
  return IfcConic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTEDFACESET] = (d) => {
  return IfcConnectedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONCURVEGEOMETRY] = (d) => {
  return IfcConnectionCurveGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONGEOMETRY] = (d) => {
  return IfcConnectionGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTECCENTRICITY] = (d) => {
  return IfcConnectionPointEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONPOINTGEOMETRY] = (d) => {
  return IfcConnectionPointGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONSURFACEGEOMETRY] = (d) => {
  return IfcConnectionSurfaceGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONNECTIONVOLUMEGEOMETRY] = (d) => {
  return IfcConnectionVolumeGeometry.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRAINT] = (d) => {
  return IfcConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCE] = (d) => {
  return IfcConstructionEquipmentResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE] = (d) => {
  return IfcConstructionEquipmentResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCE] = (d) => {
  return IfcConstructionMaterialResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONMATERIALRESOURCETYPE] = (d) => {
  return IfcConstructionMaterialResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCE] = (d) => {
  return IfcConstructionProductResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONPRODUCTRESOURCETYPE] = (d) => {
  return IfcConstructionProductResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCE] = (d) => {
  return IfcConstructionResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONSTRUCTIONRESOURCETYPE] = (d) => {
  return IfcConstructionResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXT] = (d) => {
  return IfcContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTEXTDEPENDENTUNIT] = (d) => {
  return IfcContextDependentUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROL] = (d) => {
  return IfcControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLER] = (d) => {
  return IfcController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONTROLLERTYPE] = (d) => {
  return IfcControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNIT] = (d) => {
  return IfcConversionBasedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCONVERSIONBASEDUNITWITHOFFSET] = (d) => {
  return IfcConversionBasedUnitWithOffset.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAM] = (d) => {
  return IfcCooledBeam.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLEDBEAMTYPE] = (d) => {
  return IfcCooledBeamType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWER] = (d) => {
  return IfcCoolingTower.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOOLINGTOWERTYPE] = (d) => {
  return IfcCoolingTowerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEOPERATION] = (d) => {
  return IfcCoordinateOperation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOORDINATEREFERENCESYSTEM] = (d) => {
  return IfcCoordinateReferenceSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTITEM] = (d) => {
  return IfcCostItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTSCHEDULE] = (d) => {
  return IfcCostSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOSTVALUE] = (d) => {
  return IfcCostValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERING] = (d) => {
  return IfcCovering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCOVERINGTYPE] = (d) => {
  return IfcCoveringType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCE] = (d) => {
  return IfcCrewResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCREWRESOURCETYPE] = (d) => {
  return IfcCrewResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGPRIMITIVE3D] = (d) => {
  return IfcCsgPrimitive3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCSGSOLID] = (d) => {
  return IfcCsgSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURRENCYRELATIONSHIP] = (d) => {
  return IfcCurrencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALL] = (d) => {
  return IfcCurtainWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURTAINWALLTYPE] = (d) => {
  return IfcCurtainWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVE] = (d) => {
  return IfcCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDPLANE] = (d) => {
  return IfcCurveBoundedPlane.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVEBOUNDEDSURFACE] = (d) => {
  return IfcCurveBoundedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESEGMENT2D] = (d) => {
  return IfcCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLE] = (d) => {
  return IfcCurveStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONT] = (d) => {
  return IfcCurveStyleFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTANDSCALING] = (d) => {
  return IfcCurveStyleFontAndScaling.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCURVESTYLEFONTPATTERN] = (d) => {
  return IfcCurveStyleFontPattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCCYLINDRICALSURFACE] = (d) => {
  return IfcCylindricalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPER] = (d) => {
  return IfcDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDAMPERTYPE] = (d) => {
  return IfcDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATION] = (d) => {
  return IfcDeepFoundation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDEEPFOUNDATIONTYPE] = (d) => {
  return IfcDeepFoundationType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDPROFILEDEF] = (d) => {
  return IfcDerivedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNIT] = (d) => {
  return IfcDerivedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDERIVEDUNITELEMENT] = (d) => {
  return IfcDerivedUnitElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIMENSIONALEXPONENTS] = (d) => {
  return IfcDimensionalExponents.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDIRECTION] = (d) => {
  return IfcDirection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORY] = (d) => {
  return IfcDiscreteAccessory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISCRETEACCESSORYTYPE] = (d) => {
  return IfcDiscreteAccessoryType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTANCEEXPRESSION] = (d) => {
  return IfcDistanceExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENT] = (d) => {
  return IfcDistributionChamberElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCHAMBERELEMENTTYPE] = (d) => {
  return IfcDistributionChamberElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCIRCUIT] = (d) => {
  return IfcDistributionCircuit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENT] = (d) => {
  return IfcDistributionControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONCONTROLELEMENTTYPE] = (d) => {
  return IfcDistributionControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENT] = (d) => {
  return IfcDistributionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONELEMENTTYPE] = (d) => {
  return IfcDistributionElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENT] = (d) => {
  return IfcDistributionFlowElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONFLOWELEMENTTYPE] = (d) => {
  return IfcDistributionFlowElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONPORT] = (d) => {
  return IfcDistributionPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDISTRIBUTIONSYSTEM] = (d) => {
  return IfcDistributionSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATION] = (d) => {
  return IfcDocumentInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTINFORMATIONRELATIONSHIP] = (d) => {
  return IfcDocumentInformationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOCUMENTREFERENCE] = (d) => {
  return IfcDocumentReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOOR] = (d) => {
  return IfcDoor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORLININGPROPERTIES] = (d) => {
  return IfcDoorLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORPANELPROPERTIES] = (d) => {
  return IfcDoorPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTANDARDCASE] = (d) => {
  return IfcDoorStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORSTYLE] = (d) => {
  return IfcDoorStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDOORTYPE] = (d) => {
  return IfcDoorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCOLOUR] = (d) => {
  return IfcDraughtingPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDRAUGHTINGPREDEFINEDCURVEFONT] = (d) => {
  return IfcDraughtingPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTING] = (d) => {
  return IfcDuctFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTFITTINGTYPE] = (d) => {
  return IfcDuctFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENT] = (d) => {
  return IfcDuctSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSEGMENTTYPE] = (d) => {
  return IfcDuctSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCER] = (d) => {
  return IfcDuctSilencer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCDUCTSILENCERTYPE] = (d) => {
  return IfcDuctSilencerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGE] = (d) => {
  return IfcEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGECURVE] = (d) => {
  return IfcEdgeCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEDGELOOP] = (d) => {
  return IfcEdgeLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCE] = (d) => {
  return IfcElectricAppliance.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICAPPLIANCETYPE] = (d) => {
  return IfcElectricApplianceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARD] = (d) => {
  return IfcElectricDistributionBoard.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICDISTRIBUTIONBOARDTYPE] = (d) => {
  return IfcElectricDistributionBoardType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICE] = (d) => {
  return IfcElectricFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcElectricFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATOR] = (d) => {
  return IfcElectricGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICGENERATORTYPE] = (d) => {
  return IfcElectricGeneratorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTOR] = (d) => {
  return IfcElectricMotor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICMOTORTYPE] = (d) => {
  return IfcElectricMotorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROL] = (d) => {
  return IfcElectricTimeControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELECTRICTIMECONTROLTYPE] = (d) => {
  return IfcElectricTimeControlType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENT] = (d) => {
  return IfcElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLY] = (d) => {
  return IfcElementAssembly.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTASSEMBLYTYPE] = (d) => {
  return IfcElementAssemblyType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENT] = (d) => {
  return IfcElementComponent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTCOMPONENTTYPE] = (d) => {
  return IfcElementComponentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTQUANTITY] = (d) => {
  return IfcElementQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTTYPE] = (d) => {
  return IfcElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELEMENTARYSURFACE] = (d) => {
  return IfcElementarySurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSE] = (d) => {
  return IfcEllipse.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCELLIPSEPROFILEDEF] = (d) => {
  return IfcEllipseProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICE] = (d) => {
  return IfcEnergyConversionDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENERGYCONVERSIONDEVICETYPE] = (d) => {
  return IfcEnergyConversionDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINE] = (d) => {
  return IfcEngine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCENGINETYPE] = (d) => {
  return IfcEngineType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLER] = (d) => {
  return IfcEvaporativeCooler.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATIVECOOLERTYPE] = (d) => {
  return IfcEvaporativeCoolerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATOR] = (d) => {
  return IfcEvaporator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVAPORATORTYPE] = (d) => {
  return IfcEvaporatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENT] = (d) => {
  return IfcEvent$1.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTIME] = (d) => {
  return IfcEventTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEVENTTYPE] = (d) => {
  return IfcEventType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTENDEDPROPERTIES] = (d) => {
  return IfcExtendedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALINFORMATION] = (d) => {
  return IfcExternalInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCE] = (d) => {
  return IfcExternalReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALREFERENCERELATIONSHIP] = (d) => {
  return IfcExternalReferenceRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALELEMENT] = (d) => {
  return IfcExternalSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcExternalSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDHATCHSTYLE] = (d) => {
  return IfcExternallyDefinedHatchStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDSURFACESTYLE] = (d) => {
  return IfcExternallyDefinedSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTERNALLYDEFINEDTEXTFONT] = (d) => {
  return IfcExternallyDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLID] = (d) => {
  return IfcExtrudedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCEXTRUDEDAREASOLIDTAPERED] = (d) => {
  return IfcExtrudedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACE] = (d) => {
  return IfcFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBASEDSURFACEMODEL] = (d) => {
  return IfcFaceBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEBOUND] = (d) => {
  return IfcFaceBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACEOUTERBOUND] = (d) => {
  return IfcFaceOuterBound.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACESURFACE] = (d) => {
  return IfcFaceSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREP] = (d) => {
  return IfcFacetedBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACETEDBREPWITHVOIDS] = (d) => {
  return IfcFacetedBrepWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITY] = (d) => {
  return IfcFacility.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFACILITYPART] = (d) => {
  return IfcFacilityPart.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAILURECONNECTIONCONDITION] = (d) => {
  return IfcFailureConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFAN] = (d) => {
  return IfcFan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFANTYPE] = (d) => {
  return IfcFanType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENER] = (d) => {
  return IfcFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFASTENERTYPE] = (d) => {
  return IfcFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENT] = (d) => {
  return IfcFeatureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTADDITION] = (d) => {
  return IfcFeatureElementAddition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFEATUREELEMENTSUBTRACTION] = (d) => {
  return IfcFeatureElementSubtraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLE] = (d) => {
  return IfcFillAreaStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLEHATCHING] = (d) => {
  return IfcFillAreaStyleHatching.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILLAREASTYLETILES] = (d) => {
  return IfcFillAreaStyleTiles.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTER] = (d) => {
  return IfcFilter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFILTERTYPE] = (d) => {
  return IfcFilterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINAL] = (d) => {
  return IfcFireSuppressionTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIRESUPPRESSIONTERMINALTYPE] = (d) => {
  return IfcFireSuppressionTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFIXEDREFERENCESWEPTAREASOLID] = (d) => {
  return IfcFixedReferenceSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLER] = (d) => {
  return IfcFlowController.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWCONTROLLERTYPE] = (d) => {
  return IfcFlowControllerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTING] = (d) => {
  return IfcFlowFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWFITTINGTYPE] = (d) => {
  return IfcFlowFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENT] = (d) => {
  return IfcFlowInstrument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWINSTRUMENTTYPE] = (d) => {
  return IfcFlowInstrumentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETER] = (d) => {
  return IfcFlowMeter.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMETERTYPE] = (d) => {
  return IfcFlowMeterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICE] = (d) => {
  return IfcFlowMovingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWMOVINGDEVICETYPE] = (d) => {
  return IfcFlowMovingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENT] = (d) => {
  return IfcFlowSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSEGMENTTYPE] = (d) => {
  return IfcFlowSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICE] = (d) => {
  return IfcFlowStorageDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWSTORAGEDEVICETYPE] = (d) => {
  return IfcFlowStorageDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINAL] = (d) => {
  return IfcFlowTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTERMINALTYPE] = (d) => {
  return IfcFlowTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICE] = (d) => {
  return IfcFlowTreatmentDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFLOWTREATMENTDEVICETYPE] = (d) => {
  return IfcFlowTreatmentDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTING] = (d) => {
  return IfcFooting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFOOTINGTYPE] = (d) => {
  return IfcFootingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENT] = (d) => {
  return IfcFurnishingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNISHINGELEMENTTYPE] = (d) => {
  return IfcFurnishingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURE] = (d) => {
  return IfcFurniture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCFURNITURETYPE] = (d) => {
  return IfcFurnitureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENT] = (d) => {
  return IfcGeographicElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOGRAPHICELEMENTTYPE] = (d) => {
  return IfcGeographicElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICCURVESET] = (d) => {
  return IfcGeometricCurveSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONCONTEXT] = (d) => {
  return IfcGeometricRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONITEM] = (d) => {
  return IfcGeometricRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICREPRESENTATIONSUBCONTEXT] = (d) => {
  return IfcGeometricRepresentationSubContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGEOMETRICSET] = (d) => {
  return IfcGeometricSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRID] = (d) => {
  return IfcGrid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDAXIS] = (d) => {
  return IfcGridAxis.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGRIDPLACEMENT] = (d) => {
  return IfcGridPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCGROUP] = (d) => {
  return IfcGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHALFSPACESOLID] = (d) => {
  return IfcHalfSpaceSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGER] = (d) => {
  return IfcHeatExchanger.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHEATEXCHANGERTYPE] = (d) => {
  return IfcHeatExchangerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIER] = (d) => {
  return IfcHumidifier.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCHUMIDIFIERTYPE] = (d) => {
  return IfcHumidifierType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCISHAPEPROFILEDEF] = (d) => {
  return IfcIShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIMAGETEXTURE] = (d) => {
  return IfcImageTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDCOLOURMAP] = (d) => {
  return IfcIndexedColourMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYCURVE] = (d) => {
  return IfcIndexedPolyCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACE] = (d) => {
  return IfcIndexedPolygonalFace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDPOLYGONALFACEWITHVOIDS] = (d) => {
  return IfcIndexedPolygonalFaceWithVoids.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTEXTUREMAP] = (d) => {
  return IfcIndexedTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINDEXEDTRIANGLETEXTUREMAP] = (d) => {
  return IfcIndexedTriangleTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTOR] = (d) => {
  return IfcInterceptor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERCEPTORTYPE] = (d) => {
  return IfcInterceptorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINTERSECTIONCURVE] = (d) => {
  return IfcIntersectionCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCINVENTORY] = (d) => {
  return IfcInventory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIES] = (d) => {
  return IfcIrregularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCIRREGULARTIMESERIESVALUE] = (d) => {
  return IfcIrregularTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOX] = (d) => {
  return IfcJunctionBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCJUNCTIONBOXTYPE] = (d) => {
  return IfcJunctionBoxType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLSHAPEPROFILEDEF] = (d) => {
  return IfcLShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCE] = (d) => {
  return IfcLaborResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLABORRESOURCETYPE] = (d) => {
  return IfcLaborResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAGTIME] = (d) => {
  return IfcLagTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMP] = (d) => {
  return IfcLamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLAMPTYPE] = (d) => {
  return IfcLampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYINFORMATION] = (d) => {
  return IfcLibraryInformation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIBRARYREFERENCE] = (d) => {
  return IfcLibraryReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTDISTRIBUTIONDATA] = (d) => {
  return IfcLightDistributionData.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURE] = (d) => {
  return IfcLightFixture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTFIXTURETYPE] = (d) => {
  return IfcLightFixtureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTINTENSITYDISTRIBUTION] = (d) => {
  return IfcLightIntensityDistribution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCE] = (d) => {
  return IfcLightSource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEAMBIENT] = (d) => {
  return IfcLightSourceAmbient.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEDIRECTIONAL] = (d) => {
  return IfcLightSourceDirectional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEGONIOMETRIC] = (d) => {
  return IfcLightSourceGoniometric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCEPOSITIONAL] = (d) => {
  return IfcLightSourcePositional.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLIGHTSOURCESPOT] = (d) => {
  return IfcLightSourceSpot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINE] = (d) => {
  return IfcLine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINESEGMENT2D] = (d) => {
  return IfcLineSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPLACEMENT] = (d) => {
  return IfcLinearPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLINEARPOSITIONINGELEMENT] = (d) => {
  return IfcLinearPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOCALPLACEMENT] = (d) => {
  return IfcLocalPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCLOOP] = (d) => {
  return IfcLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMANIFOLDSOLIDBREP] = (d) => {
  return IfcManifoldSolidBrep.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPCONVERSION] = (d) => {
  return IfcMapConversion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMAPPEDITEM] = (d) => {
  return IfcMappedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIAL] = (d) => {
  return IfcMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCLASSIFICATIONRELATIONSHIP] = (d) => {
  return IfcMaterialClassificationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENT] = (d) => {
  return IfcMaterialConstituent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALCONSTITUENTSET] = (d) => {
  return IfcMaterialConstituentSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITION] = (d) => {
  return IfcMaterialDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALDEFINITIONREPRESENTATION] = (d) => {
  return IfcMaterialDefinitionRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYER] = (d) => {
  return IfcMaterialLayer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSET] = (d) => {
  return IfcMaterialLayerSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERSETUSAGE] = (d) => {
  return IfcMaterialLayerSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLAYERWITHOFFSETS] = (d) => {
  return IfcMaterialLayerWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALLIST] = (d) => {
  return IfcMaterialList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILE] = (d) => {
  return IfcMaterialProfile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESET] = (d) => {
  return IfcMaterialProfileSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGE] = (d) => {
  return IfcMaterialProfileSetUsage.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILESETUSAGETAPERING] = (d) => {
  return IfcMaterialProfileSetUsageTapering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROFILEWITHOFFSETS] = (d) => {
  return IfcMaterialProfileWithOffsets.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALPROPERTIES] = (d) => {
  return IfcMaterialProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALRELATIONSHIP] = (d) => {
  return IfcMaterialRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMATERIALUSAGEDEFINITION] = (d) => {
  return IfcMaterialUsageDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEASUREWITHUNIT] = (d) => {
  return IfcMeasureWithUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENER] = (d) => {
  return IfcMechanicalFastener.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMECHANICALFASTENERTYPE] = (d) => {
  return IfcMechanicalFastenerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICE] = (d) => {
  return IfcMedicalDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEDICALDEVICETYPE] = (d) => {
  return IfcMedicalDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBER] = (d) => {
  return IfcMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERSTANDARDCASE] = (d) => {
  return IfcMemberStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMEMBERTYPE] = (d) => {
  return IfcMemberType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMETRIC] = (d) => {
  return IfcMetric.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMIRROREDPROFILEDEF] = (d) => {
  return IfcMirroredProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMONETARYUNIT] = (d) => {
  return IfcMonetaryUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTION] = (d) => {
  return IfcMotorConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCMOTORCONNECTIONTYPE] = (d) => {
  return IfcMotorConnectionType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCNAMEDUNIT] = (d) => {
  return IfcNamedUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECT] = (d) => {
  return IfcObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTDEFINITION] = (d) => {
  return IfcObjectDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTPLACEMENT] = (d) => {
  return IfcObjectPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOBJECTIVE] = (d) => {
  return IfcObjective.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOCCUPANT] = (d) => {
  return IfcOccupant.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE] = (d) => {
  return IfcOffsetCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE2D] = (d) => {
  return IfcOffsetCurve2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVE3D] = (d) => {
  return IfcOffsetCurve3D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOFFSETCURVEBYDISTANCES] = (d) => {
  return IfcOffsetCurveByDistances.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENSHELL] = (d) => {
  return IfcOpenShell.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGELEMENT] = (d) => {
  return IfcOpeningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOPENINGSTANDARDCASE] = (d) => {
  return IfcOpeningStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATION] = (d) => {
  return IfcOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORGANIZATIONRELATIONSHIP] = (d) => {
  return IfcOrganizationRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTATIONEXPRESSION] = (d) => {
  return IfcOrientationExpression.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCORIENTEDEDGE] = (d) => {
  return IfcOrientedEdge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTERBOUNDARYCURVE] = (d) => {
  return IfcOuterBoundaryCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLET] = (d) => {
  return IfcOutlet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOUTLETTYPE] = (d) => {
  return IfcOutletType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCOWNERHISTORY] = (d) => {
  return IfcOwnerHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPARAMETERIZEDPROFILEDEF] = (d) => {
  return IfcParameterizedProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPATH] = (d) => {
  return IfcPath.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPCURVE] = (d) => {
  return IfcPcurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERFORMANCEHISTORY] = (d) => {
  return IfcPerformanceHistory.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMEABLECOVERINGPROPERTIES] = (d) => {
  return IfcPermeableCoveringProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERMIT] = (d) => {
  return IfcPermit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSON] = (d) => {
  return IfcPerson.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPERSONANDORGANIZATION] = (d) => {
  return IfcPersonAndOrganization.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALCOMPLEXQUANTITY] = (d) => {
  return IfcPhysicalComplexQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALQUANTITY] = (d) => {
  return IfcPhysicalQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPHYSICALSIMPLEQUANTITY] = (d) => {
  return IfcPhysicalSimpleQuantity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILE] = (d) => {
  return IfcPile.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPILETYPE] = (d) => {
  return IfcPileType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTING] = (d) => {
  return IfcPipeFitting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPEFITTINGTYPE] = (d) => {
  return IfcPipeFittingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENT] = (d) => {
  return IfcPipeSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIPESEGMENTTYPE] = (d) => {
  return IfcPipeSegmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPIXELTEXTURE] = (d) => {
  return IfcPixelTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLACEMENT] = (d) => {
  return IfcPlacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANARBOX] = (d) => {
  return IfcPlanarBox.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANAREXTENT] = (d) => {
  return IfcPlanarExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLANE] = (d) => {
  return IfcPlane$1.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATE] = (d) => {
  return IfcPlate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATESTANDARDCASE] = (d) => {
  return IfcPlateStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPLATETYPE] = (d) => {
  return IfcPlateType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINT] = (d) => {
  return IfcPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONCURVE] = (d) => {
  return IfcPointOnCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOINTONSURFACE] = (d) => {
  return IfcPointOnSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLOOP] = (d) => {
  return IfcPolyLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALBOUNDEDHALFSPACE] = (d) => {
  return IfcPolygonalBoundedHalfSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYGONALFACESET] = (d) => {
  return IfcPolygonalFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOLYLINE] = (d) => {
  return IfcPolyline.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPORT] = (d) => {
  return IfcPort.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSITIONINGELEMENT] = (d) => {
  return IfcPositioningElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPOSTALADDRESS] = (d) => {
  return IfcPostalAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCOLOUR] = (d) => {
  return IfcPreDefinedColour.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDCURVEFONT] = (d) => {
  return IfcPreDefinedCurveFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDITEM] = (d) => {
  return IfcPreDefinedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTIES] = (d) => {
  return IfcPreDefinedProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDPROPERTYSET] = (d) => {
  return IfcPreDefinedPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPREDEFINEDTEXTFONT] = (d) => {
  return IfcPreDefinedTextFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONITEM] = (d) => {
  return IfcPresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERASSIGNMENT] = (d) => {
  return IfcPresentationLayerAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONLAYERWITHSTYLE] = (d) => {
  return IfcPresentationLayerWithStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLE] = (d) => {
  return IfcPresentationStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRESENTATIONSTYLEASSIGNMENT] = (d) => {
  return IfcPresentationStyleAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURE] = (d) => {
  return IfcProcedure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCEDURETYPE] = (d) => {
  return IfcProcedureType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROCESS] = (d) => {
  return IfcProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCT] = (d) => {
  return IfcProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTDEFINITIONSHAPE] = (d) => {
  return IfcProductDefinitionShape.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPRODUCTREPRESENTATION] = (d) => {
  return IfcProductRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEDEF] = (d) => {
  return IfcProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROFILEPROPERTIES] = (d) => {
  return IfcProfileProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECT] = (d) => {
  return IfcProject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTLIBRARY] = (d) => {
  return IfcProjectLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTORDER] = (d) => {
  return IfcProjectOrder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTEDCRS] = (d) => {
  return IfcProjectedCRS.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROJECTIONELEMENT] = (d) => {
  return IfcProjectionElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTY] = (d) => {
  return IfcProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYABSTRACTION] = (d) => {
  return IfcPropertyAbstraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYBOUNDEDVALUE] = (d) => {
  return IfcPropertyBoundedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEFINITION] = (d) => {
  return IfcPropertyDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYDEPENDENCYRELATIONSHIP] = (d) => {
  return IfcPropertyDependencyRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATEDVALUE] = (d) => {
  return IfcPropertyEnumeratedValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYENUMERATION] = (d) => {
  return IfcPropertyEnumeration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYLISTVALUE] = (d) => {
  return IfcPropertyListValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYREFERENCEVALUE] = (d) => {
  return IfcPropertyReferenceValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSET] = (d) => {
  return IfcPropertySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETDEFINITION] = (d) => {
  return IfcPropertySetDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSETTEMPLATE] = (d) => {
  return IfcPropertySetTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYSINGLEVALUE] = (d) => {
  return IfcPropertySingleValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTABLEVALUE] = (d) => {
  return IfcPropertyTableValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATE] = (d) => {
  return IfcPropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROPERTYTEMPLATEDEFINITION] = (d) => {
  return IfcPropertyTemplateDefinition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICE] = (d) => {
  return IfcProtectiveDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNIT] = (d) => {
  return IfcProtectiveDeviceTrippingUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETRIPPINGUNITTYPE] = (d) => {
  return IfcProtectiveDeviceTrippingUnitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROTECTIVEDEVICETYPE] = (d) => {
  return IfcProtectiveDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPROXY] = (d) => {
  return IfcProxy.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMP] = (d) => {
  return IfcPump.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCPUMPTYPE] = (d) => {
  return IfcPumpType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYAREA] = (d) => {
  return IfcQuantityArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYCOUNT] = (d) => {
  return IfcQuantityCount.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYLENGTH] = (d) => {
  return IfcQuantityLength.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYSET] = (d) => {
  return IfcQuantitySet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYTIME] = (d) => {
  return IfcQuantityTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYVOLUME] = (d) => {
  return IfcQuantityVolume.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCQUANTITYWEIGHT] = (d) => {
  return IfcQuantityWeight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILING] = (d) => {
  return IfcRailing.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAILINGTYPE] = (d) => {
  return IfcRailingType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMP] = (d) => {
  return IfcRamp.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHT] = (d) => {
  return IfcRampFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPFLIGHTTYPE] = (d) => {
  return IfcRampFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRAMPTYPE] = (d) => {
  return IfcRampType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINECURVEWITHKNOTS] = (d) => {
  return IfcRationalBSplineCurveWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRATIONALBSPLINESURFACEWITHKNOTS] = (d) => {
  return IfcRationalBSplineSurfaceWithKnots.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEHOLLOWPROFILEDEF] = (d) => {
  return IfcRectangleHollowProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGLEPROFILEDEF] = (d) => {
  return IfcRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARPYRAMID] = (d) => {
  return IfcRectangularPyramid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECTANGULARTRIMMEDSURFACE] = (d) => {
  return IfcRectangularTrimmedSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRECURRENCEPATTERN] = (d) => {
  return IfcRecurrencePattern.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENCE] = (d) => {
  return IfcReference.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREFERENT] = (d) => {
  return IfcReferent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREGULARTIMESERIES] = (d) => {
  return IfcRegularTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTBARPROPERTIES] = (d) => {
  return IfcReinforcementBarProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCEMENTDEFINITIONPROPERTIES] = (d) => {
  return IfcReinforcementDefinitionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBAR] = (d) => {
  return IfcReinforcingBar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGBARTYPE] = (d) => {
  return IfcReinforcingBarType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENT] = (d) => {
  return IfcReinforcingElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGELEMENTTYPE] = (d) => {
  return IfcReinforcingElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESH] = (d) => {
  return IfcReinforcingMesh.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREINFORCINGMESHTYPE] = (d) => {
  return IfcReinforcingMeshType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELAGGREGATES] = (d) => {
  return IfcRelAggregates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNS] = (d) => {
  return IfcRelAssigns.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOACTOR] = (d) => {
  return IfcRelAssignsToActor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOCONTROL] = (d) => {
  return IfcRelAssignsToControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUP] = (d) => {
  return IfcRelAssignsToGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOGROUPBYFACTOR] = (d) => {
  return IfcRelAssignsToGroupByFactor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPROCESS] = (d) => {
  return IfcRelAssignsToProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTOPRODUCT] = (d) => {
  return IfcRelAssignsToProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSIGNSTORESOURCE] = (d) => {
  return IfcRelAssignsToResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATES] = (d) => {
  return IfcRelAssociates.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESAPPROVAL] = (d) => {
  return IfcRelAssociatesApproval.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCLASSIFICATION] = (d) => {
  return IfcRelAssociatesClassification.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESCONSTRAINT] = (d) => {
  return IfcRelAssociatesConstraint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESDOCUMENT] = (d) => {
  return IfcRelAssociatesDocument.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESLIBRARY] = (d) => {
  return IfcRelAssociatesLibrary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELASSOCIATESMATERIAL] = (d) => {
  return IfcRelAssociatesMaterial.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTS] = (d) => {
  return IfcRelConnects.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSELEMENTS] = (d) => {
  return IfcRelConnectsElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPATHELEMENTS] = (d) => {
  return IfcRelConnectsPathElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTTOELEMENT] = (d) => {
  return IfcRelConnectsPortToElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSPORTS] = (d) => {
  return IfcRelConnectsPorts.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALACTIVITY] = (d) => {
  return IfcRelConnectsStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSSTRUCTURALMEMBER] = (d) => {
  return IfcRelConnectsStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHECCENTRICITY] = (d) => {
  return IfcRelConnectsWithEccentricity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONNECTSWITHREALIZINGELEMENTS] = (d) => {
  return IfcRelConnectsWithRealizingElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCONTAINEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelContainedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSBLDGELEMENTS] = (d) => {
  return IfcRelCoversBldgElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELCOVERSSPACES] = (d) => {
  return IfcRelCoversSpaces.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECLARES] = (d) => {
  return IfcRelDeclares.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDECOMPOSES] = (d) => {
  return IfcRelDecomposes.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINES] = (d) => {
  return IfcRelDefines.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYOBJECT] = (d) => {
  return IfcRelDefinesByObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYPROPERTIES] = (d) => {
  return IfcRelDefinesByProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTEMPLATE] = (d) => {
  return IfcRelDefinesByTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELDEFINESBYTYPE] = (d) => {
  return IfcRelDefinesByType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFILLSELEMENT] = (d) => {
  return IfcRelFillsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELFLOWCONTROLELEMENTS] = (d) => {
  return IfcRelFlowControlElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELINTERFERESELEMENTS] = (d) => {
  return IfcRelInterferesElements.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELNESTS] = (d) => {
  return IfcRelNests.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPOSITIONS] = (d) => {
  return IfcRelPositions.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELPROJECTSELEMENT] = (d) => {
  return IfcRelProjectsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELREFERENCEDINSPATIALSTRUCTURE] = (d) => {
  return IfcRelReferencedInSpatialStructure.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSEQUENCE] = (d) => {
  return IfcRelSequence.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSERVICESBUILDINGS] = (d) => {
  return IfcRelServicesBuildings.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY] = (d) => {
  return IfcRelSpaceBoundary.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY1STLEVEL] = (d) => {
  return IfcRelSpaceBoundary1stLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELSPACEBOUNDARY2NDLEVEL] = (d) => {
  return IfcRelSpaceBoundary2ndLevel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELVOIDSELEMENT] = (d) => {
  return IfcRelVoidsElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRELATIONSHIP] = (d) => {
  return IfcRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPARAMETRISEDCOMPOSITECURVESEGMENT] = (d) => {
  return IfcReparametrisedCompositeCurveSegment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATION] = (d) => {
  return IfcRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONCONTEXT] = (d) => {
  return IfcRepresentationContext.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONITEM] = (d) => {
  return IfcRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREPRESENTATIONMAP] = (d) => {
  return IfcRepresentationMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCE] = (d) => {
  return IfcResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCEAPPROVALRELATIONSHIP] = (d) => {
  return IfcResourceApprovalRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCECONSTRAINTRELATIONSHIP] = (d) => {
  return IfcResourceConstraintRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCELEVELRELATIONSHIP] = (d) => {
  return IfcResourceLevelRelationship.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRESOURCETIME] = (d) => {
  return IfcResourceTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLID] = (d) => {
  return IfcRevolvedAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCREVOLVEDAREASOLIDTAPERED] = (d) => {
  return IfcRevolvedAreaSolidTapered.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCONE] = (d) => {
  return IfcRightCircularCone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCRIGHTCIRCULARCYLINDER] = (d) => {
  return IfcRightCircularCylinder.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOF] = (d) => {
  return IfcRoof.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOFTYPE] = (d) => {
  return IfcRoofType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROOT] = (d) => {
  return IfcRoot.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCROUNDEDRECTANGLEPROFILEDEF] = (d) => {
  return IfcRoundedRectangleProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIUNIT] = (d) => {
  return IfcSIUnit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINAL] = (d) => {
  return IfcSanitaryTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSANITARYTERMINALTYPE] = (d) => {
  return IfcSanitaryTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSCHEDULINGTIME] = (d) => {
  return IfcSchedulingTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSEAMCURVE] = (d) => {
  return IfcSeamCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONPROPERTIES] = (d) => {
  return IfcSectionProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONREINFORCEMENTPROPERTIES] = (d) => {
  return IfcSectionReinforcementProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLID] = (d) => {
  return IfcSectionedSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSOLIDHORIZONTAL] = (d) => {
  return IfcSectionedSolidHorizontal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSECTIONEDSPINE] = (d) => {
  return IfcSectionedSpine.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSOR] = (d) => {
  return IfcSensor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSENSORTYPE] = (d) => {
  return IfcSensorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICE] = (d) => {
  return IfcShadingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHADINGDEVICETYPE] = (d) => {
  return IfcShadingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEASPECT] = (d) => {
  return IfcShapeAspect.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEMODEL] = (d) => {
  return IfcShapeModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHAPEREPRESENTATION] = (d) => {
  return IfcShapeRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSHELLBASEDSURFACEMODEL] = (d) => {
  return IfcShellBasedSurfaceModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTY] = (d) => {
  return IfcSimpleProperty.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSIMPLEPROPERTYTEMPLATE] = (d) => {
  return IfcSimplePropertyTemplate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSITE] = (d) => {
  return IfcSite.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLAB] = (d) => {
  return IfcSlab.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABELEMENTEDCASE] = (d) => {
  return IfcSlabElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABSTANDARDCASE] = (d) => {
  return IfcSlabStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLABTYPE] = (d) => {
  return IfcSlabType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSLIPPAGECONNECTIONCONDITION] = (d) => {
  return IfcSlippageConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICE] = (d) => {
  return IfcSolarDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLARDEVICETYPE] = (d) => {
  return IfcSolarDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSOLIDMODEL] = (d) => {
  return IfcSolidModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACE] = (d) => {
  return IfcSpace.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATER] = (d) => {
  return IfcSpaceHeater.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACEHEATERTYPE] = (d) => {
  return IfcSpaceHeaterType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPACETYPE] = (d) => {
  return IfcSpaceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENT] = (d) => {
  return IfcSpatialElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALELEMENTTYPE] = (d) => {
  return IfcSpatialElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENT] = (d) => {
  return IfcSpatialStructureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALSTRUCTUREELEMENTTYPE] = (d) => {
  return IfcSpatialStructureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONE] = (d) => {
  return IfcSpatialZone.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPATIALZONETYPE] = (d) => {
  return IfcSpatialZoneType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERE] = (d) => {
  return IfcSphere.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSPHERICALSURFACE] = (d) => {
  return IfcSphericalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINAL] = (d) => {
  return IfcStackTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTACKTERMINALTYPE] = (d) => {
  return IfcStackTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIR] = (d) => {
  return IfcStair.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHT] = (d) => {
  return IfcStairFlight.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRFLIGHTTYPE] = (d) => {
  return IfcStairFlightType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTAIRTYPE] = (d) => {
  return IfcStairType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTION] = (d) => {
  return IfcStructuralAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALACTIVITY] = (d) => {
  return IfcStructuralActivity.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALANALYSISMODEL] = (d) => {
  return IfcStructuralAnalysisModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTION] = (d) => {
  return IfcStructuralConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCONNECTIONCONDITION] = (d) => {
  return IfcStructuralConnectionCondition.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEACTION] = (d) => {
  return IfcStructuralCurveAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVECONNECTION] = (d) => {
  return IfcStructuralCurveConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBER] = (d) => {
  return IfcStructuralCurveMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEMEMBERVARYING] = (d) => {
  return IfcStructuralCurveMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALCURVEREACTION] = (d) => {
  return IfcStructuralCurveReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALITEM] = (d) => {
  return IfcStructuralItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLINEARACTION] = (d) => {
  return IfcStructuralLinearAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOAD] = (d) => {
  return IfcStructuralLoad.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCASE] = (d) => {
  return IfcStructuralLoadCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADCONFIGURATION] = (d) => {
  return IfcStructuralLoadConfiguration.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADGROUP] = (d) => {
  return IfcStructuralLoadGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADLINEARFORCE] = (d) => {
  return IfcStructuralLoadLinearForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADORRESULT] = (d) => {
  return IfcStructuralLoadOrResult.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADPLANARFORCE] = (d) => {
  return IfcStructuralLoadPlanarForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENT] = (d) => {
  return IfcStructuralLoadSingleDisplacement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION] = (d) => {
  return IfcStructuralLoadSingleDisplacementDistortion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCE] = (d) => {
  return IfcStructuralLoadSingleForce.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSINGLEFORCEWARPING] = (d) => {
  return IfcStructuralLoadSingleForceWarping.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADSTATIC] = (d) => {
  return IfcStructuralLoadStatic.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALLOADTEMPERATURE] = (d) => {
  return IfcStructuralLoadTemperature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALMEMBER] = (d) => {
  return IfcStructuralMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPLANARACTION] = (d) => {
  return IfcStructuralPlanarAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTACTION] = (d) => {
  return IfcStructuralPointAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTCONNECTION] = (d) => {
  return IfcStructuralPointConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALPOINTREACTION] = (d) => {
  return IfcStructuralPointReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALREACTION] = (d) => {
  return IfcStructuralReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALRESULTGROUP] = (d) => {
  return IfcStructuralResultGroup.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEACTION] = (d) => {
  return IfcStructuralSurfaceAction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACECONNECTION] = (d) => {
  return IfcStructuralSurfaceConnection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBER] = (d) => {
  return IfcStructuralSurfaceMember.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEMEMBERVARYING] = (d) => {
  return IfcStructuralSurfaceMemberVarying.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTRUCTURALSURFACEREACTION] = (d) => {
  return IfcStructuralSurfaceReaction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEMODEL] = (d) => {
  return IfcStyleModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDITEM] = (d) => {
  return IfcStyledItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSTYLEDREPRESENTATION] = (d) => {
  return IfcStyledRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCE] = (d) => {
  return IfcSubContractResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBCONTRACTRESOURCETYPE] = (d) => {
  return IfcSubContractResourceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSUBEDGE] = (d) => {
  return IfcSubedge.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACE] = (d) => {
  return IfcSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVE] = (d) => {
  return IfcSurfaceCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACECURVESWEPTAREASOLID] = (d) => {
  return IfcSurfaceCurveSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEFEATURE] = (d) => {
  return IfcSurfaceFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFLINEAREXTRUSION] = (d) => {
  return IfcSurfaceOfLinearExtrusion.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEOFREVOLUTION] = (d) => {
  return IfcSurfaceOfRevolution.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACEREINFORCEMENTAREA] = (d) => {
  return IfcSurfaceReinforcementArea.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLE] = (d) => {
  return IfcSurfaceStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLELIGHTING] = (d) => {
  return IfcSurfaceStyleLighting.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEREFRACTION] = (d) => {
  return IfcSurfaceStyleRefraction.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLERENDERING] = (d) => {
  return IfcSurfaceStyleRendering.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLESHADING] = (d) => {
  return IfcSurfaceStyleShading.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACESTYLEWITHTEXTURES] = (d) => {
  return IfcSurfaceStyleWithTextures.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSURFACETEXTURE] = (d) => {
  return IfcSurfaceTexture.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTAREASOLID] = (d) => {
  return IfcSweptAreaSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLID] = (d) => {
  return IfcSweptDiskSolid.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTDISKSOLIDPOLYGONAL] = (d) => {
  return IfcSweptDiskSolidPolygonal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWEPTSURFACE] = (d) => {
  return IfcSweptSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICE] = (d) => {
  return IfcSwitchingDevice.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSWITCHINGDEVICETYPE] = (d) => {
  return IfcSwitchingDeviceType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEM] = (d) => {
  return IfcSystem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENT] = (d) => {
  return IfcSystemFurnitureElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCSYSTEMFURNITUREELEMENTTYPE] = (d) => {
  return IfcSystemFurnitureElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTSHAPEPROFILEDEF] = (d) => {
  return IfcTShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLE] = (d) => {
  return IfcTable.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLECOLUMN] = (d) => {
  return IfcTableColumn.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTABLEROW] = (d) => {
  return IfcTableRow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANK] = (d) => {
  return IfcTank.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTANKTYPE] = (d) => {
  return IfcTankType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASK] = (d) => {
  return IfcTask.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIME] = (d) => {
  return IfcTaskTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTIMERECURRING] = (d) => {
  return IfcTaskTimeRecurring.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTASKTYPE] = (d) => {
  return IfcTaskType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTELECOMADDRESS] = (d) => {
  return IfcTelecomAddress.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDON] = (d) => {
  return IfcTendon.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHOR] = (d) => {
  return IfcTendonAnchor.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONANCHORTYPE] = (d) => {
  return IfcTendonAnchorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUIT] = (d) => {
  return IfcTendonConduit.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONCONDUITTYPE] = (d) => {
  return IfcTendonConduitType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTENDONTYPE] = (d) => {
  return IfcTendonType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDFACESET] = (d) => {
  return IfcTessellatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTESSELLATEDITEM] = (d) => {
  return IfcTessellatedItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERAL] = (d) => {
  return IfcTextLiteral.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTLITERALWITHEXTENT] = (d) => {
  return IfcTextLiteralWithExtent.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLE] = (d) => {
  return IfcTextStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFONTMODEL] = (d) => {
  return IfcTextStyleFontModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLEFORDEFINEDFONT] = (d) => {
  return IfcTextStyleForDefinedFont.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTSTYLETEXTMODEL] = (d) => {
  return IfcTextStyleTextModel.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATE] = (d) => {
  return IfcTextureCoordinate.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTURECOORDINATEGENERATOR] = (d) => {
  return IfcTextureCoordinateGenerator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREMAP] = (d) => {
  return IfcTextureMap.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEX] = (d) => {
  return IfcTextureVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTEXTUREVERTEXLIST] = (d) => {
  return IfcTextureVertexList.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMEPERIOD] = (d) => {
  return IfcTimePeriod.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIES] = (d) => {
  return IfcTimeSeries.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTIMESERIESVALUE] = (d) => {
  return IfcTimeSeriesValue.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGICALREPRESENTATIONITEM] = (d) => {
  return IfcTopologicalRepresentationItem.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOPOLOGYREPRESENTATION] = (d) => {
  return IfcTopologyRepresentation.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTOROIDALSURFACE] = (d) => {
  return IfcToroidalSurface.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMER] = (d) => {
  return IfcTransformer.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSFORMERTYPE] = (d) => {
  return IfcTransformerType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSITIONCURVESEGMENT2D] = (d) => {
  return IfcTransitionCurveSegment2D.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENT] = (d) => {
  return IfcTransportElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRANSPORTELEMENTTYPE] = (d) => {
  return IfcTransportElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRAPEZIUMPROFILEDEF] = (d) => {
  return IfcTrapeziumProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDFACESET] = (d) => {
  return IfcTriangulatedFaceSet.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIANGULATEDIRREGULARNETWORK] = (d) => {
  return IfcTriangulatedIrregularNetwork.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTRIMMEDCURVE] = (d) => {
  return IfcTrimmedCurve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLE] = (d) => {
  return IfcTubeBundle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTUBEBUNDLETYPE] = (d) => {
  return IfcTubeBundleType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEOBJECT] = (d) => {
  return IfcTypeObject.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPROCESS] = (d) => {
  return IfcTypeProcess.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPEPRODUCT] = (d) => {
  return IfcTypeProduct.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCTYPERESOURCE] = (d) => {
  return IfcTypeResource.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUSHAPEPROFILEDEF] = (d) => {
  return IfcUShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITASSIGNMENT] = (d) => {
  return IfcUnitAssignment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENT] = (d) => {
  return IfcUnitaryControlElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYCONTROLELEMENTTYPE] = (d) => {
  return IfcUnitaryControlElementType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENT] = (d) => {
  return IfcUnitaryEquipment.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCUNITARYEQUIPMENTTYPE] = (d) => {
  return IfcUnitaryEquipmentType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVE] = (d) => {
  return IfcValve.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVALVETYPE] = (d) => {
  return IfcValveType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVECTOR] = (d) => {
  return IfcVector.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEX] = (d) => {
  return IfcVertex.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXLOOP] = (d) => {
  return IfcVertexLoop.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVERTEXPOINT] = (d) => {
  return IfcVertexPoint.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPER] = (d) => {
  return IfcVibrationDamper.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONDAMPERTYPE] = (d) => {
  return IfcVibrationDamperType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATOR] = (d) => {
  return IfcVibrationIsolator.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIBRATIONISOLATORTYPE] = (d) => {
  return IfcVibrationIsolatorType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALELEMENT] = (d) => {
  return IfcVirtualElement.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVIRTUALGRIDINTERSECTION] = (d) => {
  return IfcVirtualGridIntersection.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCVOIDINGFEATURE] = (d) => {
  return IfcVoidingFeature.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALL] = (d) => {
  return IfcWall.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLELEMENTEDCASE] = (d) => {
  return IfcWallElementedCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLSTANDARDCASE] = (d) => {
  return IfcWallStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWALLTYPE] = (d) => {
  return IfcWallType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINAL] = (d) => {
  return IfcWasteTerminal.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWASTETERMINALTYPE] = (d) => {
  return IfcWasteTerminalType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOW] = (d) => {
  return IfcWindow.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWLININGPROPERTIES] = (d) => {
  return IfcWindowLiningProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWPANELPROPERTIES] = (d) => {
  return IfcWindowPanelProperties.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTANDARDCASE] = (d) => {
  return IfcWindowStandardCase.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWSTYLE] = (d) => {
  return IfcWindowStyle.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWINDOWTYPE] = (d) => {
  return IfcWindowType.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCALENDAR] = (d) => {
  return IfcWorkCalendar.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKCONTROL] = (d) => {
  return IfcWorkControl.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKPLAN] = (d) => {
  return IfcWorkPlan.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKSCHEDULE] = (d) => {
  return IfcWorkSchedule.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCWORKTIME] = (d) => {
  return IfcWorkTime.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZSHAPEPROFILEDEF] = (d) => {
  return IfcZShapeProfileDef.FromTape(d.ID, d.type, d.arguments);
};
FromRawLineData[IFCZONE] = (d) => {
  return IfcZone.FromTape(d.ID, d.type, d.arguments);
};
var IfcActionRequest = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcActionRequest(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    return new IfcActor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheActor);
    return args;
  }
};
var IfcActorRole = class {
  constructor(expressID, type, Role, UserDefinedRole, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Role = Role;
    this.UserDefinedRole = UserDefinedRole;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Role = tape[ptr++];
    let UserDefinedRole = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcActorRole(expressID, type, Role, UserDefinedRole, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Role);
    args.push(this.UserDefinedRole);
    args.push(this.Description);
    return args;
  }
};
var IfcActuator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcActuatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcActuatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    return new IfcAddress(expressID, type, Purpose, Description, UserDefinedPurpose);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    return args;
  }
};
var IfcAdvancedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcAdvancedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcAdvancedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcAdvancedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    args.push(this.Voids);
    return args;
  }
};
var IfcAdvancedFace = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcAdvancedFace(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    args.push(this.FaceSurface);
    args.push(this.SameSense);
    return args;
  }
};
var IfcAirTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirToAirHeatRecovery = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecovery(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAirToAirHeatRecoveryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAirToAirHeatRecoveryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlarm = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarm(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlarmType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlarmType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlignment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAlignment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Axis);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAlignment2DHorizontal = class {
  constructor(expressID, type, StartDistAlong, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.StartDistAlong = StartDistAlong;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartDistAlong = tape[ptr++];
    let Segments = tape[ptr++];
    return new IfcAlignment2DHorizontal(expressID, type, StartDistAlong, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.StartDistAlong);
    args.push(this.Segments);
    return args;
  }
};
var IfcAlignment2DHorizontalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.CurveGeometry = CurveGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let CurveGeometry = tape[ptr++];
    return new IfcAlignment2DHorizontalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, CurveGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.CurveGeometry);
    return args;
  }
};
var IfcAlignment2DSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    return new IfcAlignment2DSegment(expressID, type, TangentialContinuity, StartTag, EndTag);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    return args;
  }
};
var IfcAlignment2DVerSegCircularArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.Radius = Radius;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let Radius = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegCircularArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, Radius, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    args.push(this.Radius);
    args.push(this.IsConvex);
    return args;
  }
};
var IfcAlignment2DVerSegLine = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerSegLine(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    return args;
  }
};
var IfcAlignment2DVerSegParabolicArc = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
    this.ParabolaConstant = ParabolaConstant;
    this.IsConvex = IsConvex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    let ParabolaConstant = tape[ptr++];
    let IsConvex = tape[ptr++];
    return new IfcAlignment2DVerSegParabolicArc(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient, ParabolaConstant, IsConvex);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    args.push(this.ParabolaConstant);
    args.push(this.IsConvex);
    return args;
  }
};
var IfcAlignment2DVertical = class {
  constructor(expressID, type, Segments) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    return new IfcAlignment2DVertical(expressID, type, Segments);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    return args;
  }
};
var IfcAlignment2DVerticalSegment = class {
  constructor(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient) {
    this.expressID = expressID;
    this.type = type;
    this.TangentialContinuity = TangentialContinuity;
    this.StartTag = StartTag;
    this.EndTag = EndTag;
    this.StartDistAlong = StartDistAlong;
    this.HorizontalLength = HorizontalLength;
    this.StartHeight = StartHeight;
    this.StartGradient = StartGradient;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TangentialContinuity = tape[ptr++];
    let StartTag = tape[ptr++];
    let EndTag = tape[ptr++];
    let StartDistAlong = tape[ptr++];
    let HorizontalLength = tape[ptr++];
    let StartHeight = tape[ptr++];
    let StartGradient = tape[ptr++];
    return new IfcAlignment2DVerticalSegment(expressID, type, TangentialContinuity, StartTag, EndTag, StartDistAlong, HorizontalLength, StartHeight, StartGradient);
  }
  ToTape() {
    let args = [];
    args.push(this.TangentialContinuity);
    args.push(this.StartTag);
    args.push(this.EndTag);
    args.push(this.StartDistAlong);
    args.push(this.HorizontalLength);
    args.push(this.StartHeight);
    args.push(this.StartGradient);
    return args;
  }
};
var IfcAlignmentCurve = class {
  constructor(expressID, type, Horizontal, Vertical, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.Horizontal = Horizontal;
    this.Vertical = Vertical;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Horizontal = tape[ptr++];
    let Vertical = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcAlignmentCurve(expressID, type, Horizontal, Vertical, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.Horizontal);
    args.push(this.Vertical);
    args.push(this.Tag);
    return args;
  }
};
var IfcAnnotation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcAnnotation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcAnnotationFillArea = class {
  constructor(expressID, type, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcAnnotationFillArea(expressID, type, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.OuterBoundary);
    args.push(this.InnerBoundaries);
    return args;
  }
};
var IfcApplication = class {
  constructor(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier) {
    this.expressID = expressID;
    this.type = type;
    this.ApplicationDeveloper = ApplicationDeveloper;
    this.Version = Version;
    this.ApplicationFullName = ApplicationFullName;
    this.ApplicationIdentifier = ApplicationIdentifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ApplicationDeveloper = tape[ptr++];
    let Version = tape[ptr++];
    let ApplicationFullName = tape[ptr++];
    let ApplicationIdentifier = tape[ptr++];
    return new IfcApplication(expressID, type, ApplicationDeveloper, Version, ApplicationFullName, ApplicationIdentifier);
  }
  ToTape() {
    let args = [];
    args.push(this.ApplicationDeveloper);
    args.push(this.Version);
    args.push(this.ApplicationFullName);
    args.push(this.ApplicationIdentifier);
    return args;
  }
};
var IfcAppliedValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcAppliedValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AppliedValue);
    args.push(this.UnitBasis);
    args.push(this.ApplicableDate);
    args.push(this.FixedUntilDate);
    args.push(this.Category);
    args.push(this.Condition);
    args.push(this.ArithmeticOperator);
    args.push(this.Components);
    return args;
  }
};
var IfcApproval = class {
  constructor(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.TimeOfApproval = TimeOfApproval;
    this.Status = Status;
    this.Level = Level;
    this.Qualifier = Qualifier;
    this.RequestingApproval = RequestingApproval;
    this.GivingApproval = GivingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TimeOfApproval = tape[ptr++];
    let Status = tape[ptr++];
    let Level = tape[ptr++];
    let Qualifier = tape[ptr++];
    let RequestingApproval = tape[ptr++];
    let GivingApproval = tape[ptr++];
    return new IfcApproval(expressID, type, Identifier, Name, Description, TimeOfApproval, Status, Level, Qualifier, RequestingApproval, GivingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TimeOfApproval);
    args.push(this.Status);
    args.push(this.Level);
    args.push(this.Qualifier);
    args.push(this.RequestingApproval);
    args.push(this.GivingApproval);
    return args;
  }
};
var IfcApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatingApproval, RelatedApprovals) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingApproval = RelatingApproval;
    this.RelatedApprovals = RelatedApprovals;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    let RelatedApprovals = tape[ptr++];
    return new IfcApprovalRelationship(expressID, type, Name, Description, RelatingApproval, RelatedApprovals);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingApproval);
    args.push(this.RelatedApprovals);
    return args;
  }
};
var IfcArbitraryClosedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    return new IfcArbitraryClosedProfileDef(expressID, type, ProfileType, ProfileName, OuterCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.OuterCurve);
    return args;
  }
};
var IfcArbitraryOpenProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    return new IfcArbitraryOpenProfileDef(expressID, type, ProfileType, ProfileName, Curve);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Curve);
    return args;
  }
};
var IfcArbitraryProfileDefWithVoids = class {
  constructor(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.OuterCurve = OuterCurve;
    this.InnerCurves = InnerCurves;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let OuterCurve = tape[ptr++];
    let InnerCurves = tape[ptr++];
    return new IfcArbitraryProfileDefWithVoids(expressID, type, ProfileType, ProfileName, OuterCurve, InnerCurves);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.OuterCurve);
    args.push(this.InnerCurves);
    return args;
  }
};
var IfcAsset = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.OriginalValue = OriginalValue;
    this.CurrentValue = CurrentValue;
    this.TotalReplacementCost = TotalReplacementCost;
    this.Owner = Owner;
    this.User = User;
    this.ResponsiblePerson = ResponsiblePerson;
    this.IncorporationDate = IncorporationDate;
    this.DepreciatedValue = DepreciatedValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let OriginalValue = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let TotalReplacementCost = tape[ptr++];
    let Owner = tape[ptr++];
    let User = tape[ptr++];
    let ResponsiblePerson = tape[ptr++];
    let IncorporationDate = tape[ptr++];
    let DepreciatedValue = tape[ptr++];
    return new IfcAsset(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, OriginalValue, CurrentValue, TotalReplacementCost, Owner, User, ResponsiblePerson, IncorporationDate, DepreciatedValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.OriginalValue);
    args.push(this.CurrentValue);
    args.push(this.TotalReplacementCost);
    args.push(this.Owner);
    args.push(this.User);
    args.push(this.ResponsiblePerson);
    args.push(this.IncorporationDate);
    args.push(this.DepreciatedValue);
    return args;
  }
};
var IfcAsymmetricIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomFlangeWidth = BottomFlangeWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.BottomFlangeThickness = BottomFlangeThickness;
    this.BottomFlangeFilletRadius = BottomFlangeFilletRadius;
    this.TopFlangeWidth = TopFlangeWidth;
    this.TopFlangeThickness = TopFlangeThickness;
    this.TopFlangeFilletRadius = TopFlangeFilletRadius;
    this.BottomFlangeEdgeRadius = BottomFlangeEdgeRadius;
    this.BottomFlangeSlope = BottomFlangeSlope;
    this.TopFlangeEdgeRadius = TopFlangeEdgeRadius;
    this.TopFlangeSlope = TopFlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomFlangeWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let BottomFlangeThickness = tape[ptr++];
    let BottomFlangeFilletRadius = tape[ptr++];
    let TopFlangeWidth = tape[ptr++];
    let TopFlangeThickness = tape[ptr++];
    let TopFlangeFilletRadius = tape[ptr++];
    let BottomFlangeEdgeRadius = tape[ptr++];
    let BottomFlangeSlope = tape[ptr++];
    let TopFlangeEdgeRadius = tape[ptr++];
    let TopFlangeSlope = tape[ptr++];
    return new IfcAsymmetricIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomFlangeWidth, OverallDepth, WebThickness, BottomFlangeThickness, BottomFlangeFilletRadius, TopFlangeWidth, TopFlangeThickness, TopFlangeFilletRadius, BottomFlangeEdgeRadius, BottomFlangeSlope, TopFlangeEdgeRadius, TopFlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.BottomFlangeWidth);
    args.push(this.OverallDepth);
    args.push(this.WebThickness);
    args.push(this.BottomFlangeThickness);
    args.push(this.BottomFlangeFilletRadius);
    args.push(this.TopFlangeWidth);
    args.push(this.TopFlangeThickness);
    args.push(this.TopFlangeFilletRadius);
    args.push(this.BottomFlangeEdgeRadius);
    args.push(this.BottomFlangeSlope);
    args.push(this.TopFlangeEdgeRadius);
    args.push(this.TopFlangeSlope);
    return args;
  }
};
var IfcAudioVisualAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAudioVisualApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcAudioVisualApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcAxis1Placement = class {
  constructor(expressID, type, Location, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcAxis1Placement(expressID, type, Location, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Axis);
    return args;
  }
};
var IfcAxis2Placement2D = class {
  constructor(expressID, type, Location, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement2D(expressID, type, Location, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcAxis2Placement3D = class {
  constructor(expressID, type, Location, Axis, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Axis = Axis;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Axis = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcAxis2Placement3D(expressID, type, Location, Axis, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Axis);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcBSplineCurve = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineCurve(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    args.push(this.KnotMultiplicities);
    args.push(this.Knots);
    args.push(this.KnotSpec);
    return args;
  }
};
var IfcBSplineSurface = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBSplineSurface(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    return new IfcBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    args.push(this.UMultiplicities);
    args.push(this.VMultiplicities);
    args.push(this.UKnots);
    args.push(this.VKnots);
    args.push(this.KnotSpec);
    return args;
  }
};
var IfcBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBeamStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBearing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBearingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBearingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBlobTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.RasterFormat = RasterFormat;
    this.RasterCode = RasterCode;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let RasterFormat = tape[ptr++];
    let RasterCode = tape[ptr++];
    return new IfcBlobTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, RasterFormat, RasterCode);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.RasterFormat);
    args.push(this.RasterCode);
    return args;
  }
};
var IfcBlock = class {
  constructor(expressID, type, Position, XLength, YLength, ZLength) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.ZLength = ZLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let ZLength = tape[ptr++];
    return new IfcBlock(expressID, type, Position, XLength, YLength, ZLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.XLength);
    args.push(this.YLength);
    args.push(this.ZLength);
    return args;
  }
};
var IfcBoiler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoiler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBoilerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBoilerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBooleanClippingResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanClippingResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    args.push(this.FirstOperand);
    args.push(this.SecondOperand);
    return args;
  }
};
var IfcBooleanResult = class {
  constructor(expressID, type, Operator, FirstOperand, SecondOperand) {
    this.expressID = expressID;
    this.type = type;
    this.Operator = Operator;
    this.FirstOperand = FirstOperand;
    this.SecondOperand = SecondOperand;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Operator = tape[ptr++];
    let FirstOperand = tape[ptr++];
    let SecondOperand = tape[ptr++];
    return new IfcBooleanResult(expressID, type, Operator, FirstOperand, SecondOperand);
  }
  ToTape() {
    let args = [];
    args.push(this.Operator);
    args.push(this.FirstOperand);
    args.push(this.SecondOperand);
    return args;
  }
};
var IfcBoundaryCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcBoundaryCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcBoundaryEdgeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByLengthX = TranslationalStiffnessByLengthX;
    this.TranslationalStiffnessByLengthY = TranslationalStiffnessByLengthY;
    this.TranslationalStiffnessByLengthZ = TranslationalStiffnessByLengthZ;
    this.RotationalStiffnessByLengthX = RotationalStiffnessByLengthX;
    this.RotationalStiffnessByLengthY = RotationalStiffnessByLengthY;
    this.RotationalStiffnessByLengthZ = RotationalStiffnessByLengthZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByLengthX = tape[ptr++];
    let TranslationalStiffnessByLengthY = tape[ptr++];
    let TranslationalStiffnessByLengthZ = tape[ptr++];
    let RotationalStiffnessByLengthX = tape[ptr++];
    let RotationalStiffnessByLengthY = tape[ptr++];
    let RotationalStiffnessByLengthZ = tape[ptr++];
    return new IfcBoundaryEdgeCondition(expressID, type, Name, TranslationalStiffnessByLengthX, TranslationalStiffnessByLengthY, TranslationalStiffnessByLengthZ, RotationalStiffnessByLengthX, RotationalStiffnessByLengthY, RotationalStiffnessByLengthZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessByLengthX);
    args.push(this.TranslationalStiffnessByLengthY);
    args.push(this.TranslationalStiffnessByLengthZ);
    args.push(this.RotationalStiffnessByLengthX);
    args.push(this.RotationalStiffnessByLengthY);
    args.push(this.RotationalStiffnessByLengthZ);
    return args;
  }
};
var IfcBoundaryFaceCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessByAreaX = TranslationalStiffnessByAreaX;
    this.TranslationalStiffnessByAreaY = TranslationalStiffnessByAreaY;
    this.TranslationalStiffnessByAreaZ = TranslationalStiffnessByAreaZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessByAreaX = tape[ptr++];
    let TranslationalStiffnessByAreaY = tape[ptr++];
    let TranslationalStiffnessByAreaZ = tape[ptr++];
    return new IfcBoundaryFaceCondition(expressID, type, Name, TranslationalStiffnessByAreaX, TranslationalStiffnessByAreaY, TranslationalStiffnessByAreaZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessByAreaX);
    args.push(this.TranslationalStiffnessByAreaY);
    args.push(this.TranslationalStiffnessByAreaZ);
    return args;
  }
};
var IfcBoundaryNodeCondition = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    return new IfcBoundaryNodeCondition(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessX);
    args.push(this.TranslationalStiffnessY);
    args.push(this.TranslationalStiffnessZ);
    args.push(this.RotationalStiffnessX);
    args.push(this.RotationalStiffnessY);
    args.push(this.RotationalStiffnessZ);
    return args;
  }
};
var IfcBoundaryNodeConditionWarping = class {
  constructor(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TranslationalStiffnessX = TranslationalStiffnessX;
    this.TranslationalStiffnessY = TranslationalStiffnessY;
    this.TranslationalStiffnessZ = TranslationalStiffnessZ;
    this.RotationalStiffnessX = RotationalStiffnessX;
    this.RotationalStiffnessY = RotationalStiffnessY;
    this.RotationalStiffnessZ = RotationalStiffnessZ;
    this.WarpingStiffness = WarpingStiffness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TranslationalStiffnessX = tape[ptr++];
    let TranslationalStiffnessY = tape[ptr++];
    let TranslationalStiffnessZ = tape[ptr++];
    let RotationalStiffnessX = tape[ptr++];
    let RotationalStiffnessY = tape[ptr++];
    let RotationalStiffnessZ = tape[ptr++];
    let WarpingStiffness = tape[ptr++];
    return new IfcBoundaryNodeConditionWarping(expressID, type, Name, TranslationalStiffnessX, TranslationalStiffnessY, TranslationalStiffnessZ, RotationalStiffnessX, RotationalStiffnessY, RotationalStiffnessZ, WarpingStiffness);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TranslationalStiffnessX);
    args.push(this.TranslationalStiffnessY);
    args.push(this.TranslationalStiffnessZ);
    args.push(this.RotationalStiffnessX);
    args.push(this.RotationalStiffnessY);
    args.push(this.RotationalStiffnessZ);
    args.push(this.WarpingStiffness);
    return args;
  }
};
var IfcBoundedCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcBoundedCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundedSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcBoundedSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcBoundingBox = class {
  constructor(expressID, type, Corner, XDim, YDim, ZDim) {
    this.expressID = expressID;
    this.type = type;
    this.Corner = Corner;
    this.XDim = XDim;
    this.YDim = YDim;
    this.ZDim = ZDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Corner = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let ZDim = tape[ptr++];
    return new IfcBoundingBox(expressID, type, Corner, XDim, YDim, ZDim);
  }
  ToTape() {
    let args = [];
    args.push(this.Corner);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.ZDim);
    return args;
  }
};
var IfcBoxedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Enclosure) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Enclosure = Enclosure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Enclosure = tape[ptr++];
    return new IfcBoxedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Enclosure);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    args.push(this.Enclosure);
    return args;
  }
};
var IfcBridge = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridge(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBridgePart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBridgePart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuilding = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.ElevationOfRefHeight = ElevationOfRefHeight;
    this.ElevationOfTerrain = ElevationOfTerrain;
    this.BuildingAddress = BuildingAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let ElevationOfRefHeight = tape[ptr++];
    let ElevationOfTerrain = tape[ptr++];
    let BuildingAddress = tape[ptr++];
    return new IfcBuilding(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, ElevationOfRefHeight, ElevationOfTerrain, BuildingAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.ElevationOfRefHeight);
    args.push(this.ElevationOfTerrain);
    args.push(this.BuildingAddress);
    return args;
  }
};
var IfcBuildingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcBuildingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcBuildingElementPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementPartType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementPartType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementProxyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBuildingElementProxyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBuildingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcBuildingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcBuildingStorey = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.Elevation = Elevation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let Elevation = tape[ptr++];
    return new IfcBuildingStorey(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, Elevation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.Elevation);
    return args;
  }
};
var IfcBuildingSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcBuildingSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcBurner = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurner(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcBurnerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcBurnerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.WallThickness = WallThickness;
    this.Girth = Girth;
    this.InternalFilletRadius = InternalFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let WallThickness = tape[ptr++];
    let Girth = tape[ptr++];
    let InternalFilletRadius = tape[ptr++];
    return new IfcCShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, WallThickness, Girth, InternalFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.Width);
    args.push(this.WallThickness);
    args.push(this.Girth);
    args.push(this.InternalFilletRadius);
    return args;
  }
};
var IfcCableCarrierFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableCarrierSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableCarrierSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCableSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCableSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCaissonFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCaissonFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCaissonFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCartesianPoint = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcCartesianPoint(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcCartesianPointList = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcCartesianPointList(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCartesianPointList2D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList2D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    args.push(this.TagList);
    return args;
  }
};
var IfcCartesianPointList3D = class {
  constructor(expressID, type, CoordList, TagList) {
    this.expressID = expressID;
    this.type = type;
    this.CoordList = CoordList;
    this.TagList = TagList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordList = tape[ptr++];
    let TagList = tape[ptr++];
    return new IfcCartesianPointList3D(expressID, type, CoordList, TagList);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordList);
    args.push(this.TagList);
    return args;
  }
};
var IfcCartesianTransformationOperator = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    return args;
  }
};
var IfcCartesianTransformationOperator2D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcCartesianTransformationOperator2D(expressID, type, Axis1, Axis2, LocalOrigin, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    return args;
  }
};
var IfcCartesianTransformationOperator2DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Scale2 = Scale2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Scale2 = tape[ptr++];
    return new IfcCartesianTransformationOperator2DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Scale2);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Scale2);
    return args;
  }
};
var IfcCartesianTransformationOperator3D = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3D(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Axis3);
    return args;
  }
};
var IfcCartesianTransformationOperator3DnonUniform = class {
  constructor(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3) {
    this.expressID = expressID;
    this.type = type;
    this.Axis1 = Axis1;
    this.Axis2 = Axis2;
    this.LocalOrigin = LocalOrigin;
    this.Scale = Scale;
    this.Axis3 = Axis3;
    this.Scale2 = Scale2;
    this.Scale3 = Scale3;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Axis1 = tape[ptr++];
    let Axis2 = tape[ptr++];
    let LocalOrigin = tape[ptr++];
    let Scale = tape[ptr++];
    let Axis3 = tape[ptr++];
    let Scale2 = tape[ptr++];
    let Scale3 = tape[ptr++];
    return new IfcCartesianTransformationOperator3DnonUniform(expressID, type, Axis1, Axis2, LocalOrigin, Scale, Axis3, Scale2, Scale3);
  }
  ToTape() {
    let args = [];
    args.push(this.Axis1);
    args.push(this.Axis2);
    args.push(this.LocalOrigin);
    args.push(this.Scale);
    args.push(this.Axis3);
    args.push(this.Scale2);
    args.push(this.Scale3);
    return args;
  }
};
var IfcCenterLineProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Curve, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Curve = Curve;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Curve = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcCenterLineProfileDef(expressID, type, ProfileType, ProfileName, Curve, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Curve);
    args.push(this.Thickness);
    return args;
  }
};
var IfcChiller = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChiller(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChillerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChillerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChimney = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimney(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcChimneyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcChimneyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCircle = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircle(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcCircleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
    this.WallThickness = WallThickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let WallThickness = tape[ptr++];
    return new IfcCircleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius, WallThickness);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.WallThickness);
    return args;
  }
};
var IfcCircleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCircleProfileDef(expressID, type, ProfileType, ProfileName, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcCircularArcSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.Radius = Radius;
    this.IsCCW = IsCCW;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let Radius = tape[ptr++];
    let IsCCW = tape[ptr++];
    return new IfcCircularArcSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, Radius, IsCCW);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    args.push(this.Radius);
    args.push(this.IsCCW);
    return args;
  }
};
var IfcCivilElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcCivilElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcCivilElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcCivilElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcClassification = class {
  constructor(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens) {
    this.expressID = expressID;
    this.type = type;
    this.Source = Source;
    this.Edition = Edition;
    this.EditionDate = EditionDate;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.ReferenceTokens = ReferenceTokens;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Source = tape[ptr++];
    let Edition = tape[ptr++];
    let EditionDate = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let ReferenceTokens = tape[ptr++];
    return new IfcClassification(expressID, type, Source, Edition, EditionDate, Name, Description, Location, ReferenceTokens);
  }
  ToTape() {
    let args = [];
    args.push(this.Source);
    args.push(this.Edition);
    args.push(this.EditionDate);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Location);
    args.push(this.ReferenceTokens);
    return args;
  }
};
var IfcClassificationReference = class {
  constructor(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.ReferencedSource = ReferencedSource;
    this.Description = Description;
    this.Sort = Sort;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let ReferencedSource = tape[ptr++];
    let Description = tape[ptr++];
    let Sort = tape[ptr++];
    return new IfcClassificationReference(expressID, type, Location, Identification, Name, ReferencedSource, Description, Sort);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.ReferencedSource);
    args.push(this.Description);
    args.push(this.Sort);
    return args;
  }
};
var IfcClosedShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcClosedShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcCoil = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoil(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoilType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoilType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColourRgb = class {
  constructor(expressID, type, Name, Red, Green, Blue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Red = Red;
    this.Green = Green;
    this.Blue = Blue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Red = tape[ptr++];
    let Green = tape[ptr++];
    let Blue = tape[ptr++];
    return new IfcColourRgb(expressID, type, Name, Red, Green, Blue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Red);
    args.push(this.Green);
    args.push(this.Blue);
    return args;
  }
};
var IfcColourRgbList = class {
  constructor(expressID, type, ColourList) {
    this.expressID = expressID;
    this.type = type;
    this.ColourList = ColourList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ColourList = tape[ptr++];
    return new IfcColourRgbList(expressID, type, ColourList);
  }
  ToTape() {
    let args = [];
    args.push(this.ColourList);
    return args;
  }
};
var IfcColourSpecification = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcColourSpecification(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcColumn = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumn(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColumnStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcColumnType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcColumnType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCommunicationsAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCommunicationsApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCommunicationsApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcComplexProperty = class {
  constructor(expressID, type, Name, Description, UsageName, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcComplexProperty(expressID, type, Name, Description, UsageName, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.HasProperties);
    return args;
  }
};
var IfcComplexPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.TemplateType = TemplateType;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let TemplateType = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcComplexPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, UsageName, TemplateType, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.TemplateType);
    args.push(this.HasPropertyTemplates);
    return args;
  }
};
var IfcCompositeCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcCompositeCurveOnSurface = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcCompositeCurveOnSurface(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    return new IfcCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    args.push(this.SameSense);
    args.push(this.ParentCurve);
    return args;
  }
};
var IfcCompositeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Profiles, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Profiles = Profiles;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Profiles = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcCompositeProfileDef(expressID, type, ProfileType, ProfileName, Profiles, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Profiles);
    args.push(this.Label);
    return args;
  }
};
var IfcCompressor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCompressorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCompressorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCondenser = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenser(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCondenserType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCondenserType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConic = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcConic(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcConnectedFaceSet = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcConnectedFaceSet(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcConnectionCurveGeometry = class {
  constructor(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.CurveOnRelatingElement = CurveOnRelatingElement;
    this.CurveOnRelatedElement = CurveOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CurveOnRelatingElement = tape[ptr++];
    let CurveOnRelatedElement = tape[ptr++];
    return new IfcConnectionCurveGeometry(expressID, type, CurveOnRelatingElement, CurveOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.CurveOnRelatingElement);
    args.push(this.CurveOnRelatedElement);
    return args;
  }
};
var IfcConnectionGeometry = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcConnectionGeometry(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcConnectionPointEccentricity = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
    this.EccentricityInX = EccentricityInX;
    this.EccentricityInY = EccentricityInY;
    this.EccentricityInZ = EccentricityInZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    let EccentricityInX = tape[ptr++];
    let EccentricityInY = tape[ptr++];
    let EccentricityInZ = tape[ptr++];
    return new IfcConnectionPointEccentricity(expressID, type, PointOnRelatingElement, PointOnRelatedElement, EccentricityInX, EccentricityInY, EccentricityInZ);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    args.push(this.PointOnRelatedElement);
    args.push(this.EccentricityInX);
    args.push(this.EccentricityInY);
    args.push(this.EccentricityInZ);
    return args;
  }
};
var IfcConnectionPointGeometry = class {
  constructor(expressID, type, PointOnRelatingElement, PointOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.PointOnRelatingElement = PointOnRelatingElement;
    this.PointOnRelatedElement = PointOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PointOnRelatingElement = tape[ptr++];
    let PointOnRelatedElement = tape[ptr++];
    return new IfcConnectionPointGeometry(expressID, type, PointOnRelatingElement, PointOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.PointOnRelatingElement);
    args.push(this.PointOnRelatedElement);
    return args;
  }
};
var IfcConnectionSurfaceGeometry = class {
  constructor(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceOnRelatingElement = SurfaceOnRelatingElement;
    this.SurfaceOnRelatedElement = SurfaceOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceOnRelatingElement = tape[ptr++];
    let SurfaceOnRelatedElement = tape[ptr++];
    return new IfcConnectionSurfaceGeometry(expressID, type, SurfaceOnRelatingElement, SurfaceOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceOnRelatingElement);
    args.push(this.SurfaceOnRelatedElement);
    return args;
  }
};
var IfcConnectionVolumeGeometry = class {
  constructor(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.VolumeOnRelatingElement = VolumeOnRelatingElement;
    this.VolumeOnRelatedElement = VolumeOnRelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VolumeOnRelatingElement = tape[ptr++];
    let VolumeOnRelatedElement = tape[ptr++];
    return new IfcConnectionVolumeGeometry(expressID, type, VolumeOnRelatingElement, VolumeOnRelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.VolumeOnRelatingElement);
    args.push(this.VolumeOnRelatedElement);
    return args;
  }
};
var IfcConstraint = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    return new IfcConstraint(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    return args;
  }
};
var IfcConstructionEquipmentResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionEquipmentResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionEquipmentResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionMaterialResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionMaterialResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionMaterialResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionProductResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionProductResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcConstructionProductResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConstructionResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    return args;
  }
};
var IfcConstructionResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    return new IfcConstructionResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    return args;
  }
};
var IfcContext = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcContext(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcContextDependentUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcContextDependentUnit(expressID, type, Dimensions, UnitType, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    return args;
  }
};
var IfcControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    return new IfcControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    return args;
  }
};
var IfcController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcConversionBasedUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    return new IfcConversionBasedUnit(expressID, type, Dimensions, UnitType, Name, ConversionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    args.push(this.ConversionFactor);
    return args;
  }
};
var IfcConversionBasedUnitWithOffset = class {
  constructor(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Name = Name;
    this.ConversionFactor = ConversionFactor;
    this.ConversionOffset = ConversionOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Name = tape[ptr++];
    let ConversionFactor = tape[ptr++];
    let ConversionOffset = tape[ptr++];
    return new IfcConversionBasedUnitWithOffset(expressID, type, Dimensions, UnitType, Name, ConversionFactor, ConversionOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Name);
    args.push(this.ConversionFactor);
    args.push(this.ConversionOffset);
    return args;
  }
};
var IfcCooledBeam = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeam(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCooledBeamType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCooledBeamType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoolingTower = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTower(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoolingTowerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoolingTowerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoordinateOperation = class {
  constructor(expressID, type, SourceCRS, TargetCRS) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    return new IfcCoordinateOperation(expressID, type, SourceCRS, TargetCRS);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    args.push(this.TargetCRS);
    return args;
  }
};
var IfcCoordinateReferenceSystem = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    return new IfcCoordinateReferenceSystem(expressID, type, Name, Description, GeodeticDatum, VerticalDatum);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.GeodeticDatum);
    args.push(this.VerticalDatum);
    return args;
  }
};
var IfcCostItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.CostValues = CostValues;
    this.CostQuantities = CostQuantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let CostValues = tape[ptr++];
    let CostQuantities = tape[ptr++];
    return new IfcCostItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, CostValues, CostQuantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.CostValues);
    args.push(this.CostQuantities);
    return args;
  }
};
var IfcCostSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.SubmittedOn = SubmittedOn;
    this.UpdateDate = UpdateDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let SubmittedOn = tape[ptr++];
    let UpdateDate = tape[ptr++];
    return new IfcCostSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, SubmittedOn, UpdateDate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.SubmittedOn);
    args.push(this.UpdateDate);
    return args;
  }
};
var IfcCostValue = class {
  constructor(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AppliedValue = AppliedValue;
    this.UnitBasis = UnitBasis;
    this.ApplicableDate = ApplicableDate;
    this.FixedUntilDate = FixedUntilDate;
    this.Category = Category;
    this.Condition = Condition;
    this.ArithmeticOperator = ArithmeticOperator;
    this.Components = Components;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AppliedValue = tape[ptr++];
    let UnitBasis = tape[ptr++];
    let ApplicableDate = tape[ptr++];
    let FixedUntilDate = tape[ptr++];
    let Category = tape[ptr++];
    let Condition = tape[ptr++];
    let ArithmeticOperator = tape[ptr++];
    let Components = tape[ptr++];
    return new IfcCostValue(expressID, type, Name, Description, AppliedValue, UnitBasis, ApplicableDate, FixedUntilDate, Category, Condition, ArithmeticOperator, Components);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AppliedValue);
    args.push(this.UnitBasis);
    args.push(this.ApplicableDate);
    args.push(this.FixedUntilDate);
    args.push(this.Category);
    args.push(this.Condition);
    args.push(this.ArithmeticOperator);
    args.push(this.Components);
    return args;
  }
};
var IfcCovering = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCovering(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCoveringType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCoveringType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCrewResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCrewResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCrewResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCsgPrimitive3D = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcCsgPrimitive3D(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcCsgSolid = class {
  constructor(expressID, type, TreeRootExpression) {
    this.expressID = expressID;
    this.type = type;
    this.TreeRootExpression = TreeRootExpression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TreeRootExpression = tape[ptr++];
    return new IfcCsgSolid(expressID, type, TreeRootExpression);
  }
  ToTape() {
    let args = [];
    args.push(this.TreeRootExpression);
    return args;
  }
};
var IfcCurrencyRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMonetaryUnit = RelatingMonetaryUnit;
    this.RelatedMonetaryUnit = RelatedMonetaryUnit;
    this.ExchangeRate = ExchangeRate;
    this.RateDateTime = RateDateTime;
    this.RateSource = RateSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMonetaryUnit = tape[ptr++];
    let RelatedMonetaryUnit = tape[ptr++];
    let ExchangeRate = tape[ptr++];
    let RateDateTime = tape[ptr++];
    let RateSource = tape[ptr++];
    return new IfcCurrencyRelationship(expressID, type, Name, Description, RelatingMonetaryUnit, RelatedMonetaryUnit, ExchangeRate, RateDateTime, RateSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingMonetaryUnit);
    args.push(this.RelatedMonetaryUnit);
    args.push(this.ExchangeRate);
    args.push(this.RateDateTime);
    args.push(this.RateSource);
    return args;
  }
};
var IfcCurtainWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCurtainWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcCurtainWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcCurve = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcCurve(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcCurveBoundedPlane = class {
  constructor(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.OuterBoundary = OuterBoundary;
    this.InnerBoundaries = InnerBoundaries;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let OuterBoundary = tape[ptr++];
    let InnerBoundaries = tape[ptr++];
    return new IfcCurveBoundedPlane(expressID, type, BasisSurface, OuterBoundary, InnerBoundaries);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.OuterBoundary);
    args.push(this.InnerBoundaries);
    return args;
  }
};
var IfcCurveBoundedSurface = class {
  constructor(expressID, type, BasisSurface, Boundaries, ImplicitOuter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.Boundaries = Boundaries;
    this.ImplicitOuter = ImplicitOuter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let Boundaries = tape[ptr++];
    let ImplicitOuter = tape[ptr++];
    return new IfcCurveBoundedSurface(expressID, type, BasisSurface, Boundaries, ImplicitOuter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.Boundaries);
    args.push(this.ImplicitOuter);
    return args;
  }
};
var IfcCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    return args;
  }
};
var IfcCurveStyle = class {
  constructor(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveWidth = CurveWidth;
    this.CurveColour = CurveColour;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveWidth = tape[ptr++];
    let CurveColour = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcCurveStyle(expressID, type, Name, CurveFont, CurveWidth, CurveColour, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.CurveFont);
    args.push(this.CurveWidth);
    args.push(this.CurveColour);
    args.push(this.ModelOrDraughting);
    return args;
  }
};
var IfcCurveStyleFont = class {
  constructor(expressID, type, Name, PatternList) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PatternList = PatternList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PatternList = tape[ptr++];
    return new IfcCurveStyleFont(expressID, type, Name, PatternList);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.PatternList);
    return args;
  }
};
var IfcCurveStyleFontAndScaling = class {
  constructor(expressID, type, Name, CurveFont, CurveFontScaling) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.CurveFont = CurveFont;
    this.CurveFontScaling = CurveFontScaling;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let CurveFont = tape[ptr++];
    let CurveFontScaling = tape[ptr++];
    return new IfcCurveStyleFontAndScaling(expressID, type, Name, CurveFont, CurveFontScaling);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.CurveFont);
    args.push(this.CurveFontScaling);
    return args;
  }
};
var IfcCurveStyleFontPattern = class {
  constructor(expressID, type, VisibleSegmentLength, InvisibleSegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.VisibleSegmentLength = VisibleSegmentLength;
    this.InvisibleSegmentLength = InvisibleSegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VisibleSegmentLength = tape[ptr++];
    let InvisibleSegmentLength = tape[ptr++];
    return new IfcCurveStyleFontPattern(expressID, type, VisibleSegmentLength, InvisibleSegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.VisibleSegmentLength);
    args.push(this.InvisibleSegmentLength);
    return args;
  }
};
var IfcCylindricalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcCylindricalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDeepFoundation = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDeepFoundation(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDeepFoundationType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDeepFoundationType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDerivedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcDerivedProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.ParentProfile);
    args.push(this.Operator);
    args.push(this.Label);
    return args;
  }
};
var IfcDerivedUnit = class {
  constructor(expressID, type, Elements, UnitType, UserDefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
    this.UnitType = UnitType;
    this.UserDefinedType = UserDefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    let UnitType = tape[ptr++];
    let UserDefinedType = tape[ptr++];
    return new IfcDerivedUnit(expressID, type, Elements, UnitType, UserDefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    args.push(this.UnitType);
    args.push(this.UserDefinedType);
    return args;
  }
};
var IfcDerivedUnitElement = class {
  constructor(expressID, type, Unit, Exponent) {
    this.expressID = expressID;
    this.type = type;
    this.Unit = Unit;
    this.Exponent = Exponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Unit = tape[ptr++];
    let Exponent = tape[ptr++];
    return new IfcDerivedUnitElement(expressID, type, Unit, Exponent);
  }
  ToTape() {
    let args = [];
    args.push(this.Unit);
    args.push(this.Exponent);
    return args;
  }
};
var IfcDimensionalExponents = class {
  constructor(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent) {
    this.expressID = expressID;
    this.type = type;
    this.LengthExponent = LengthExponent;
    this.MassExponent = MassExponent;
    this.TimeExponent = TimeExponent;
    this.ElectricCurrentExponent = ElectricCurrentExponent;
    this.ThermodynamicTemperatureExponent = ThermodynamicTemperatureExponent;
    this.AmountOfSubstanceExponent = AmountOfSubstanceExponent;
    this.LuminousIntensityExponent = LuminousIntensityExponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LengthExponent = tape[ptr++];
    let MassExponent = tape[ptr++];
    let TimeExponent = tape[ptr++];
    let ElectricCurrentExponent = tape[ptr++];
    let ThermodynamicTemperatureExponent = tape[ptr++];
    let AmountOfSubstanceExponent = tape[ptr++];
    let LuminousIntensityExponent = tape[ptr++];
    return new IfcDimensionalExponents(expressID, type, LengthExponent, MassExponent, TimeExponent, ElectricCurrentExponent, ThermodynamicTemperatureExponent, AmountOfSubstanceExponent, LuminousIntensityExponent);
  }
  ToTape() {
    let args = [];
    args.push(this.LengthExponent);
    args.push(this.MassExponent);
    args.push(this.TimeExponent);
    args.push(this.ElectricCurrentExponent);
    args.push(this.ThermodynamicTemperatureExponent);
    args.push(this.AmountOfSubstanceExponent);
    args.push(this.LuminousIntensityExponent);
    return args;
  }
};
var IfcDirection = class {
  constructor(expressID, type, DirectionRatios) {
    this.expressID = expressID;
    this.type = type;
    this.DirectionRatios = DirectionRatios;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DirectionRatios = tape[ptr++];
    return new IfcDirection(expressID, type, DirectionRatios);
  }
  ToTape() {
    let args = [];
    args.push(this.DirectionRatios);
    return args;
  }
};
var IfcDiscreteAccessory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDiscreteAccessoryType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDiscreteAccessoryType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistanceExpression = class {
  constructor(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal) {
    this.expressID = expressID;
    this.type = type;
    this.DistanceAlong = DistanceAlong;
    this.OffsetLateral = OffsetLateral;
    this.OffsetVertical = OffsetVertical;
    this.OffsetLongitudinal = OffsetLongitudinal;
    this.AlongHorizontal = AlongHorizontal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DistanceAlong = tape[ptr++];
    let OffsetLateral = tape[ptr++];
    let OffsetVertical = tape[ptr++];
    let OffsetLongitudinal = tape[ptr++];
    let AlongHorizontal = tape[ptr++];
    return new IfcDistanceExpression(expressID, type, DistanceAlong, OffsetLateral, OffsetVertical, OffsetLongitudinal, AlongHorizontal);
  }
  ToTape() {
    let args = [];
    args.push(this.DistanceAlong);
    args.push(this.OffsetLateral);
    args.push(this.OffsetVertical);
    args.push(this.OffsetLongitudinal);
    args.push(this.AlongHorizontal);
    return args;
  }
};
var IfcDistributionChamberElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionChamberElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionChamberElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionCircuit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionCircuit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDistributionControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionFlowElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcDistributionFlowElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcDistributionFlowElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcDistributionFlowElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcDistributionPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.FlowDirection = FlowDirection;
    this.PredefinedType = PredefinedType;
    this.SystemType = SystemType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let FlowDirection = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let SystemType = tape[ptr++];
    return new IfcDistributionPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, FlowDirection, PredefinedType, SystemType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.FlowDirection);
    args.push(this.PredefinedType);
    args.push(this.SystemType);
    return args;
  }
};
var IfcDistributionSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDistributionSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDocumentInformation = class {
  constructor(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Location = Location;
    this.Purpose = Purpose;
    this.IntendedUse = IntendedUse;
    this.Scope = Scope;
    this.Revision = Revision;
    this.DocumentOwner = DocumentOwner;
    this.Editors = Editors;
    this.CreationTime = CreationTime;
    this.LastRevisionTime = LastRevisionTime;
    this.ElectronicFormat = ElectronicFormat;
    this.ValidFrom = ValidFrom;
    this.ValidUntil = ValidUntil;
    this.Confidentiality = Confidentiality;
    this.Status = Status;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Location = tape[ptr++];
    let Purpose = tape[ptr++];
    let IntendedUse = tape[ptr++];
    let Scope = tape[ptr++];
    let Revision = tape[ptr++];
    let DocumentOwner = tape[ptr++];
    let Editors = tape[ptr++];
    let CreationTime = tape[ptr++];
    let LastRevisionTime = tape[ptr++];
    let ElectronicFormat = tape[ptr++];
    let ValidFrom = tape[ptr++];
    let ValidUntil = tape[ptr++];
    let Confidentiality = tape[ptr++];
    let Status = tape[ptr++];
    return new IfcDocumentInformation(expressID, type, Identification, Name, Description, Location, Purpose, IntendedUse, Scope, Revision, DocumentOwner, Editors, CreationTime, LastRevisionTime, ElectronicFormat, ValidFrom, ValidUntil, Confidentiality, Status);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Location);
    args.push(this.Purpose);
    args.push(this.IntendedUse);
    args.push(this.Scope);
    args.push(this.Revision);
    args.push(this.DocumentOwner);
    args.push(this.Editors);
    args.push(this.CreationTime);
    args.push(this.LastRevisionTime);
    args.push(this.ElectronicFormat);
    args.push(this.ValidFrom);
    args.push(this.ValidUntil);
    args.push(this.Confidentiality);
    args.push(this.Status);
    return args;
  }
};
var IfcDocumentInformationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingDocument = RelatingDocument;
    this.RelatedDocuments = RelatedDocuments;
    this.RelationshipType = RelationshipType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    let RelatedDocuments = tape[ptr++];
    let RelationshipType = tape[ptr++];
    return new IfcDocumentInformationRelationship(expressID, type, Name, Description, RelatingDocument, RelatedDocuments, RelationshipType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingDocument);
    args.push(this.RelatedDocuments);
    args.push(this.RelationshipType);
    return args;
  }
};
var IfcDocumentReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, ReferencedDocument) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.ReferencedDocument = ReferencedDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ReferencedDocument = tape[ptr++];
    return new IfcDocumentReference(expressID, type, Location, Identification, Name, Description, ReferencedDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ReferencedDocument);
    return args;
  }
};
var IfcDoor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDoorLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.ThresholdDepth = ThresholdDepth;
    this.ThresholdThickness = ThresholdThickness;
    this.TransomThickness = TransomThickness;
    this.TransomOffset = TransomOffset;
    this.LiningOffset = LiningOffset;
    this.ThresholdOffset = ThresholdOffset;
    this.CasingThickness = CasingThickness;
    this.CasingDepth = CasingDepth;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let ThresholdDepth = tape[ptr++];
    let ThresholdThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let TransomOffset = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let ThresholdOffset = tape[ptr++];
    let CasingThickness = tape[ptr++];
    let CasingDepth = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcDoorLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, ThresholdDepth, ThresholdThickness, TransomThickness, TransomOffset, LiningOffset, ThresholdOffset, CasingThickness, CasingDepth, ShapeAspectStyle, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.LiningDepth);
    args.push(this.LiningThickness);
    args.push(this.ThresholdDepth);
    args.push(this.ThresholdThickness);
    args.push(this.TransomThickness);
    args.push(this.TransomOffset);
    args.push(this.LiningOffset);
    args.push(this.ThresholdOffset);
    args.push(this.CasingThickness);
    args.push(this.CasingDepth);
    args.push(this.ShapeAspectStyle);
    args.push(this.LiningToPanelOffsetX);
    args.push(this.LiningToPanelOffsetY);
    return args;
  }
};
var IfcDoorPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.PanelDepth = PanelDepth;
    this.PanelOperation = PanelOperation;
    this.PanelWidth = PanelWidth;
    this.PanelPosition = PanelPosition;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let PanelDepth = tape[ptr++];
    let PanelOperation = tape[ptr++];
    let PanelWidth = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcDoorPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, PanelDepth, PanelOperation, PanelWidth, PanelPosition, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.PanelDepth);
    args.push(this.PanelOperation);
    args.push(this.PanelWidth);
    args.push(this.PanelPosition);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcDoorStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, OperationType, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDoorStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.OperationType = OperationType;
    this.ConstructionType = ConstructionType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let OperationType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcDoorStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, OperationType, ConstructionType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.OperationType);
    args.push(this.ConstructionType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.Sizeable);
    return args;
  }
};
var IfcDoorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedOperationType = UserDefinedOperationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedOperationType = tape[ptr++];
    return new IfcDoorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, OperationType, ParameterTakesPrecedence, UserDefinedOperationType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.OperationType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.UserDefinedOperationType);
    return args;
  }
};
var IfcDraughtingPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcDraughtingPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcDraughtingPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcDuctFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSilencer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcDuctSilencerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcDuctSilencerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    return new IfcEdge(expressID, type, EdgeStart, EdgeEnd);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    return args;
  }
};
var IfcEdgeCurve = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeGeometry = EdgeGeometry;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeGeometry = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcEdgeCurve(expressID, type, EdgeStart, EdgeEnd, EdgeGeometry, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.EdgeGeometry);
    args.push(this.SameSense);
    return args;
  }
};
var IfcEdgeLoop = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcEdgeLoop(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    return args;
  }
};
var IfcElectricAppliance = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricAppliance(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricApplianceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricApplianceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricDistributionBoard = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoard(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricDistributionBoardType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricDistributionBoardType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricGenerator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGenerator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricGeneratorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricGeneratorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricMotor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricMotorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricMotorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricTimeControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElectricTimeControlType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElectricTimeControlType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcElementAssembly = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssembly(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.AssemblyPlace);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElementAssemblyType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcElementAssemblyType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcElementComponent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcElementComponent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcElementComponentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementComponentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcElementQuantity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.MethodOfMeasurement = MethodOfMeasurement;
    this.Quantities = Quantities;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MethodOfMeasurement = tape[ptr++];
    let Quantities = tape[ptr++];
    return new IfcElementQuantity(expressID, type, GlobalId, OwnerHistory, Name, Description, MethodOfMeasurement, Quantities);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MethodOfMeasurement);
    args.push(this.Quantities);
    return args;
  }
};
var IfcElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcElementarySurface = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcElementarySurface(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcEllipse = class {
  constructor(expressID, type, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipse(expressID, type, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.SemiAxis1);
    args.push(this.SemiAxis2);
    return args;
  }
};
var IfcEllipseProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.SemiAxis1 = SemiAxis1;
    this.SemiAxis2 = SemiAxis2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let SemiAxis1 = tape[ptr++];
    let SemiAxis2 = tape[ptr++];
    return new IfcEllipseProfileDef(expressID, type, ProfileType, ProfileName, Position, SemiAxis1, SemiAxis2);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.SemiAxis1);
    args.push(this.SemiAxis2);
    return args;
  }
};
var IfcEnergyConversionDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcEnergyConversionDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcEnergyConversionDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcEnergyConversionDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcEngine = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngine(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEngineType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEngineType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporativeCooler = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCooler(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporativeCoolerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporativeCoolerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvaporatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcEvaporatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcEvent$1 = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
    this.EventOccurenceTime = EventOccurenceTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    let EventOccurenceTime = tape[ptr++];
    return new IfcEvent$1(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType, EventTriggerType, UserDefinedEventTriggerType, EventOccurenceTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.PredefinedType);
    args.push(this.EventTriggerType);
    args.push(this.UserDefinedEventTriggerType);
    args.push(this.EventOccurenceTime);
    return args;
  }
};
var IfcEventTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ActualDate = ActualDate;
    this.EarlyDate = EarlyDate;
    this.LateDate = LateDate;
    this.ScheduleDate = ScheduleDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ActualDate = tape[ptr++];
    let EarlyDate = tape[ptr++];
    let LateDate = tape[ptr++];
    let ScheduleDate = tape[ptr++];
    return new IfcEventTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ActualDate, EarlyDate, LateDate, ScheduleDate);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.ActualDate);
    args.push(this.EarlyDate);
    args.push(this.LateDate);
    args.push(this.ScheduleDate);
    return args;
  }
};
var IfcEventType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.EventTriggerType = EventTriggerType;
    this.UserDefinedEventTriggerType = UserDefinedEventTriggerType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let EventTriggerType = tape[ptr++];
    let UserDefinedEventTriggerType = tape[ptr++];
    return new IfcEventType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, EventTriggerType, UserDefinedEventTriggerType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    args.push(this.EventTriggerType);
    args.push(this.UserDefinedEventTriggerType);
    return args;
  }
};
var IfcExtendedProperties = class {
  constructor(expressID, type, Name, Description, Properties2) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    return new IfcExtendedProperties(expressID, type, Name, Description, Properties2);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    return args;
  }
};
var IfcExternalInformation = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcExternalInformation(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcExternalReference = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternalReference(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternalReferenceRelationship = class {
  constructor(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingReference = RelatingReference;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingReference = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcExternalReferenceRelationship(expressID, type, Name, Description, RelatingReference, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingReference);
    args.push(this.RelatedResourceObjects);
    return args;
  }
};
var IfcExternalSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcExternalSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcExternalSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcExternalSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    return args;
  }
};
var IfcExternallyDefinedHatchStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedHatchStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternallyDefinedSurfaceStyle = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedSurfaceStyle(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExternallyDefinedTextFont = class {
  constructor(expressID, type, Location, Identification, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcExternallyDefinedTextFont(expressID, type, Location, Identification, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    return args;
  }
};
var IfcExtrudedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcExtrudedAreaSolid(expressID, type, SweptArea, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    return args;
  }
};
var IfcExtrudedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcExtrudedAreaSolidTapered(expressID, type, SweptArea, Position, ExtrudedDirection, Depth, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    args.push(this.EndSweptArea);
    return args;
  }
};
var IfcFace = class {
  constructor(expressID, type, Bounds) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    return new IfcFace(expressID, type, Bounds);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    return args;
  }
};
var IfcFaceBasedSurfaceModel = class {
  constructor(expressID, type, FbsmFaces) {
    this.expressID = expressID;
    this.type = type;
    this.FbsmFaces = FbsmFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let FbsmFaces = tape[ptr++];
    return new IfcFaceBasedSurfaceModel(expressID, type, FbsmFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.FbsmFaces);
    return args;
  }
};
var IfcFaceBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    args.push(this.Orientation);
    return args;
  }
};
var IfcFaceOuterBound = class {
  constructor(expressID, type, Bound, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Bound = Bound;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bound = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcFaceOuterBound(expressID, type, Bound, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Bound);
    args.push(this.Orientation);
    return args;
  }
};
var IfcFaceSurface = class {
  constructor(expressID, type, Bounds, FaceSurface, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.Bounds = Bounds;
    this.FaceSurface = FaceSurface;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Bounds = tape[ptr++];
    let FaceSurface = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcFaceSurface(expressID, type, Bounds, FaceSurface, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.Bounds);
    args.push(this.FaceSurface);
    args.push(this.SameSense);
    return args;
  }
};
var IfcFacetedBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcFacetedBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcFacetedBrepWithVoids = class {
  constructor(expressID, type, Outer, Voids) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
    this.Voids = Voids;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    let Voids = tape[ptr++];
    return new IfcFacetedBrepWithVoids(expressID, type, Outer, Voids);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    args.push(this.Voids);
    return args;
  }
};
var IfcFacility = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacility(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcFacilityPart = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcFacilityPart(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcFailureConnectionCondition = class {
  constructor(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TensionFailureX = TensionFailureX;
    this.TensionFailureY = TensionFailureY;
    this.TensionFailureZ = TensionFailureZ;
    this.CompressionFailureX = CompressionFailureX;
    this.CompressionFailureY = CompressionFailureY;
    this.CompressionFailureZ = CompressionFailureZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TensionFailureX = tape[ptr++];
    let TensionFailureY = tape[ptr++];
    let TensionFailureZ = tape[ptr++];
    let CompressionFailureX = tape[ptr++];
    let CompressionFailureY = tape[ptr++];
    let CompressionFailureZ = tape[ptr++];
    return new IfcFailureConnectionCondition(expressID, type, Name, TensionFailureX, TensionFailureY, TensionFailureZ, CompressionFailureX, CompressionFailureY, CompressionFailureZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TensionFailureX);
    args.push(this.TensionFailureY);
    args.push(this.TensionFailureZ);
    args.push(this.CompressionFailureX);
    args.push(this.CompressionFailureY);
    args.push(this.CompressionFailureZ);
    return args;
  }
};
var IfcFan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFanType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFanType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFeatureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFeatureElementAddition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementAddition(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFeatureElementSubtraction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFeatureElementSubtraction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFillAreaStyle = class {
  constructor(expressID, type, Name, FillStyles, ModelorDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FillStyles = FillStyles;
    this.ModelorDraughting = ModelorDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FillStyles = tape[ptr++];
    let ModelorDraughting = tape[ptr++];
    return new IfcFillAreaStyle(expressID, type, Name, FillStyles, ModelorDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.FillStyles);
    args.push(this.ModelorDraughting);
    return args;
  }
};
var IfcFillAreaStyleHatching = class {
  constructor(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle) {
    this.expressID = expressID;
    this.type = type;
    this.HatchLineAppearance = HatchLineAppearance;
    this.StartOfNextHatchLine = StartOfNextHatchLine;
    this.PointOfReferenceHatchLine = PointOfReferenceHatchLine;
    this.PatternStart = PatternStart;
    this.HatchLineAngle = HatchLineAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let HatchLineAppearance = tape[ptr++];
    let StartOfNextHatchLine = tape[ptr++];
    let PointOfReferenceHatchLine = tape[ptr++];
    let PatternStart = tape[ptr++];
    let HatchLineAngle = tape[ptr++];
    return new IfcFillAreaStyleHatching(expressID, type, HatchLineAppearance, StartOfNextHatchLine, PointOfReferenceHatchLine, PatternStart, HatchLineAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.HatchLineAppearance);
    args.push(this.StartOfNextHatchLine);
    args.push(this.PointOfReferenceHatchLine);
    args.push(this.PatternStart);
    args.push(this.HatchLineAngle);
    return args;
  }
};
var IfcFillAreaStyleTiles = class {
  constructor(expressID, type, TilingPattern, Tiles, TilingScale) {
    this.expressID = expressID;
    this.type = type;
    this.TilingPattern = TilingPattern;
    this.Tiles = Tiles;
    this.TilingScale = TilingScale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TilingPattern = tape[ptr++];
    let Tiles = tape[ptr++];
    let TilingScale = tape[ptr++];
    return new IfcFillAreaStyleTiles(expressID, type, TilingPattern, Tiles, TilingScale);
  }
  ToTape() {
    let args = [];
    args.push(this.TilingPattern);
    args.push(this.Tiles);
    args.push(this.TilingScale);
    return args;
  }
};
var IfcFilter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFilterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFilterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFireSuppressionTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFireSuppressionTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFireSuppressionTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFixedReferenceSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FixedReference = FixedReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FixedReference = tape[ptr++];
    return new IfcFixedReferenceSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, FixedReference);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Directrix);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.FixedReference);
    return args;
  }
};
var IfcFlowController = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowController(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowControllerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowControllerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowInstrument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrument(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowInstrumentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowInstrumentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMeter = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeter(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMeterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFlowMeterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFlowMovingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowMovingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowMovingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowMovingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowStorageDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowStorageDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowStorageDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowStorageDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFlowTreatmentDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFlowTreatmentDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFlowTreatmentDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFlowTreatmentDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFooting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFooting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFootingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFootingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFurnishingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcFurnishingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcFurnishingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcFurnishingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcFurniture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurniture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcFurnitureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.AssemblyPlace = AssemblyPlace;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let AssemblyPlace = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcFurnitureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, AssemblyPlace, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.AssemblyPlace);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeographicElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeographicElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGeographicElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGeometricCurveSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricCurveSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    return args;
  }
};
var IfcGeometricRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    return new IfcGeometricRepresentationContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    args.push(this.CoordinateSpaceDimension);
    args.push(this.Precision);
    args.push(this.WorldCoordinateSystem);
    args.push(this.TrueNorth);
    return args;
  }
};
var IfcGeometricRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcGeometricRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcGeometricRepresentationSubContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
    this.CoordinateSpaceDimension = CoordinateSpaceDimension;
    this.Precision = Precision;
    this.WorldCoordinateSystem = WorldCoordinateSystem;
    this.TrueNorth = TrueNorth;
    this.ParentContext = ParentContext;
    this.TargetScale = TargetScale;
    this.TargetView = TargetView;
    this.UserDefinedTargetView = UserDefinedTargetView;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    let CoordinateSpaceDimension = tape[ptr++];
    let Precision = tape[ptr++];
    let WorldCoordinateSystem = tape[ptr++];
    let TrueNorth = tape[ptr++];
    let ParentContext = tape[ptr++];
    let TargetScale = tape[ptr++];
    let TargetView = tape[ptr++];
    let UserDefinedTargetView = tape[ptr++];
    return new IfcGeometricRepresentationSubContext(expressID, type, ContextIdentifier, ContextType, CoordinateSpaceDimension, Precision, WorldCoordinateSystem, TrueNorth, ParentContext, TargetScale, TargetView, UserDefinedTargetView);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    args.push(this.CoordinateSpaceDimension);
    args.push(this.Precision);
    args.push(this.WorldCoordinateSystem);
    args.push(this.TrueNorth);
    args.push(this.ParentContext);
    args.push(this.TargetScale);
    args.push(this.TargetView);
    args.push(this.UserDefinedTargetView);
    return args;
  }
};
var IfcGeometricSet = class {
  constructor(expressID, type, Elements) {
    this.expressID = expressID;
    this.type = type;
    this.Elements = Elements;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Elements = tape[ptr++];
    return new IfcGeometricSet(expressID, type, Elements);
  }
  ToTape() {
    let args = [];
    args.push(this.Elements);
    return args;
  }
};
var IfcGrid = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.UAxes = UAxes;
    this.VAxes = VAxes;
    this.WAxes = WAxes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let UAxes = tape[ptr++];
    let VAxes = tape[ptr++];
    let WAxes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcGrid(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, UAxes, VAxes, WAxes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.UAxes);
    args.push(this.VAxes);
    args.push(this.WAxes);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcGridAxis = class {
  constructor(expressID, type, AxisTag, AxisCurve, SameSense) {
    this.expressID = expressID;
    this.type = type;
    this.AxisTag = AxisTag;
    this.AxisCurve = AxisCurve;
    this.SameSense = SameSense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let AxisTag = tape[ptr++];
    let AxisCurve = tape[ptr++];
    let SameSense = tape[ptr++];
    return new IfcGridAxis(expressID, type, AxisTag, AxisCurve, SameSense);
  }
  ToTape() {
    let args = [];
    args.push(this.AxisTag);
    args.push(this.AxisCurve);
    args.push(this.SameSense);
    return args;
  }
};
var IfcGridPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementLocation = PlacementLocation;
    this.PlacementRefDirection = PlacementRefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementLocation = tape[ptr++];
    let PlacementRefDirection = tape[ptr++];
    return new IfcGridPlacement(expressID, type, PlacementRelTo, PlacementLocation, PlacementRefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.PlacementLocation);
    args.push(this.PlacementRefDirection);
    return args;
  }
};
var IfcGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcHalfSpaceSolid = class {
  constructor(expressID, type, BaseSurface, AgreementFlag) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    return new IfcHalfSpaceSolid(expressID, type, BaseSurface, AgreementFlag);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    return args;
  }
};
var IfcHeatExchanger = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchanger(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHeatExchangerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHeatExchangerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHumidifier = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifier(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcHumidifierType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcHumidifierType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcIShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.OverallWidth = OverallWidth;
    this.OverallDepth = OverallDepth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let OverallDepth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcIShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, OverallWidth, OverallDepth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.OverallWidth);
    args.push(this.OverallDepth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.FlangeEdgeRadius);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcImageTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.URLReference = URLReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let URLReference = tape[ptr++];
    return new IfcImageTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, URLReference);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.URLReference);
    return args;
  }
};
var IfcIndexedColourMap = class {
  constructor(expressID, type, MappedTo, Opacity, Colours, ColourIndex) {
    this.expressID = expressID;
    this.type = type;
    this.MappedTo = MappedTo;
    this.Opacity = Opacity;
    this.Colours = Colours;
    this.ColourIndex = ColourIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappedTo = tape[ptr++];
    let Opacity = tape[ptr++];
    let Colours = tape[ptr++];
    let ColourIndex = tape[ptr++];
    return new IfcIndexedColourMap(expressID, type, MappedTo, Opacity, Colours, ColourIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.MappedTo);
    args.push(this.Opacity);
    args.push(this.Colours);
    args.push(this.ColourIndex);
    return args;
  }
};
var IfcIndexedPolyCurve = class {
  constructor(expressID, type, Points, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcIndexedPolyCurve(expressID, type, Points, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcIndexedPolygonalFace = class {
  constructor(expressID, type, CoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    return new IfcIndexedPolygonalFace(expressID, type, CoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    return args;
  }
};
var IfcIndexedPolygonalFaceWithVoids = class {
  constructor(expressID, type, CoordIndex, InnerCoordIndices) {
    this.expressID = expressID;
    this.type = type;
    this.CoordIndex = CoordIndex;
    this.InnerCoordIndices = InnerCoordIndices;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CoordIndex = tape[ptr++];
    let InnerCoordIndices = tape[ptr++];
    return new IfcIndexedPolygonalFaceWithVoids(expressID, type, CoordIndex, InnerCoordIndices);
  }
  ToTape() {
    let args = [];
    args.push(this.CoordIndex);
    args.push(this.InnerCoordIndices);
    return args;
  }
};
var IfcIndexedTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    return new IfcIndexedTextureMap(expressID, type, Maps, MappedTo, TexCoords);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.MappedTo);
    args.push(this.TexCoords);
    return args;
  }
};
var IfcIndexedTriangleTextureMap = class {
  constructor(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.MappedTo = MappedTo;
    this.TexCoords = TexCoords;
    this.TexCoordIndex = TexCoordIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let MappedTo = tape[ptr++];
    let TexCoords = tape[ptr++];
    let TexCoordIndex = tape[ptr++];
    return new IfcIndexedTriangleTextureMap(expressID, type, Maps, MappedTo, TexCoords, TexCoordIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.MappedTo);
    args.push(this.TexCoords);
    args.push(this.TexCoordIndex);
    return args;
  }
};
var IfcInterceptor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcInterceptorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcInterceptorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcIntersectionCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcIntersectionCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcInventory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.Jurisdiction = Jurisdiction;
    this.ResponsiblePersons = ResponsiblePersons;
    this.LastUpdateDate = LastUpdateDate;
    this.CurrentValue = CurrentValue;
    this.OriginalValue = OriginalValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Jurisdiction = tape[ptr++];
    let ResponsiblePersons = tape[ptr++];
    let LastUpdateDate = tape[ptr++];
    let CurrentValue = tape[ptr++];
    let OriginalValue = tape[ptr++];
    return new IfcInventory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, Jurisdiction, ResponsiblePersons, LastUpdateDate, CurrentValue, OriginalValue);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.Jurisdiction);
    args.push(this.ResponsiblePersons);
    args.push(this.LastUpdateDate);
    args.push(this.CurrentValue);
    args.push(this.OriginalValue);
    return args;
  }
};
var IfcIrregularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcIrregularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    args.push(this.Values);
    return args;
  }
};
var IfcIrregularTimeSeriesValue = class {
  constructor(expressID, type, TimeStamp, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.TimeStamp = TimeStamp;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TimeStamp = tape[ptr++];
    let ListValues = tape[ptr++];
    return new IfcIrregularTimeSeriesValue(expressID, type, TimeStamp, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.TimeStamp);
    args.push(this.ListValues);
    return args;
  }
};
var IfcJunctionBox = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBox(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcJunctionBoxType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcJunctionBoxType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.Width = Width;
    this.Thickness = Thickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.LegSlope = LegSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let Width = tape[ptr++];
    let Thickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let LegSlope = tape[ptr++];
    return new IfcLShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, Width, Thickness, FilletRadius, EdgeRadius, LegSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.Width);
    args.push(this.Thickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    args.push(this.LegSlope);
    return args;
  }
};
var IfcLaborResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLaborResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLaborResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLagTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.LagValue = LagValue;
    this.DurationType = DurationType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let LagValue = tape[ptr++];
    let DurationType = tape[ptr++];
    return new IfcLagTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, LagValue, DurationType);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.LagValue);
    args.push(this.DurationType);
    return args;
  }
};
var IfcLamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLibraryInformation = class {
  constructor(expressID, type, Name, Version, Publisher, VersionDate, Location, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Version = Version;
    this.Publisher = Publisher;
    this.VersionDate = VersionDate;
    this.Location = Location;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Version = tape[ptr++];
    let Publisher = tape[ptr++];
    let VersionDate = tape[ptr++];
    let Location = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcLibraryInformation(expressID, type, Name, Version, Publisher, VersionDate, Location, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Version);
    args.push(this.Publisher);
    args.push(this.VersionDate);
    args.push(this.Location);
    args.push(this.Description);
    return args;
  }
};
var IfcLibraryReference = class {
  constructor(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Language = Language;
    this.ReferencedLibrary = ReferencedLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Language = tape[ptr++];
    let ReferencedLibrary = tape[ptr++];
    return new IfcLibraryReference(expressID, type, Location, Identification, Name, Description, Language, ReferencedLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Language);
    args.push(this.ReferencedLibrary);
    return args;
  }
};
var IfcLightDistributionData = class {
  constructor(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity) {
    this.expressID = expressID;
    this.type = type;
    this.MainPlaneAngle = MainPlaneAngle;
    this.SecondaryPlaneAngle = SecondaryPlaneAngle;
    this.LuminousIntensity = LuminousIntensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MainPlaneAngle = tape[ptr++];
    let SecondaryPlaneAngle = tape[ptr++];
    let LuminousIntensity = tape[ptr++];
    return new IfcLightDistributionData(expressID, type, MainPlaneAngle, SecondaryPlaneAngle, LuminousIntensity);
  }
  ToTape() {
    let args = [];
    args.push(this.MainPlaneAngle);
    args.push(this.SecondaryPlaneAngle);
    args.push(this.LuminousIntensity);
    return args;
  }
};
var IfcLightFixture = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixture(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLightFixtureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcLightFixtureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcLightIntensityDistribution = class {
  constructor(expressID, type, LightDistributionCurve, DistributionData) {
    this.expressID = expressID;
    this.type = type;
    this.LightDistributionCurve = LightDistributionCurve;
    this.DistributionData = DistributionData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LightDistributionCurve = tape[ptr++];
    let DistributionData = tape[ptr++];
    return new IfcLightIntensityDistribution(expressID, type, LightDistributionCurve, DistributionData);
  }
  ToTape() {
    let args = [];
    args.push(this.LightDistributionCurve);
    args.push(this.DistributionData);
    return args;
  }
};
var IfcLightSource = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSource(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    return args;
  }
};
var IfcLightSourceAmbient = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    return new IfcLightSourceAmbient(expressID, type, Name, LightColour, AmbientIntensity, Intensity);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    return args;
  }
};
var IfcLightSourceDirectional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcLightSourceDirectional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Orientation);
    return args;
  }
};
var IfcLightSourceGoniometric = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.ColourAppearance = ColourAppearance;
    this.ColourTemperature = ColourTemperature;
    this.LuminousFlux = LuminousFlux;
    this.LightEmissionSource = LightEmissionSource;
    this.LightDistributionDataSource = LightDistributionDataSource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let ColourAppearance = tape[ptr++];
    let ColourTemperature = tape[ptr++];
    let LuminousFlux = tape[ptr++];
    let LightEmissionSource = tape[ptr++];
    let LightDistributionDataSource = tape[ptr++];
    return new IfcLightSourceGoniometric(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, ColourAppearance, ColourTemperature, LuminousFlux, LightEmissionSource, LightDistributionDataSource);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.ColourAppearance);
    args.push(this.ColourTemperature);
    args.push(this.LuminousFlux);
    args.push(this.LightEmissionSource);
    args.push(this.LightDistributionDataSource);
    return args;
  }
};
var IfcLightSourcePositional = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    return new IfcLightSourcePositional(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.ConstantAttenuation);
    args.push(this.DistanceAttenuation);
    args.push(this.QuadricAttenuation);
    return args;
  }
};
var IfcLightSourceSpot = class {
  constructor(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LightColour = LightColour;
    this.AmbientIntensity = AmbientIntensity;
    this.Intensity = Intensity;
    this.Position = Position;
    this.Radius = Radius;
    this.ConstantAttenuation = ConstantAttenuation;
    this.DistanceAttenuation = DistanceAttenuation;
    this.QuadricAttenuation = QuadricAttenuation;
    this.Orientation = Orientation;
    this.ConcentrationExponent = ConcentrationExponent;
    this.SpreadAngle = SpreadAngle;
    this.BeamWidthAngle = BeamWidthAngle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LightColour = tape[ptr++];
    let AmbientIntensity = tape[ptr++];
    let Intensity = tape[ptr++];
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    let ConstantAttenuation = tape[ptr++];
    let DistanceAttenuation = tape[ptr++];
    let QuadricAttenuation = tape[ptr++];
    let Orientation = tape[ptr++];
    let ConcentrationExponent = tape[ptr++];
    let SpreadAngle = tape[ptr++];
    let BeamWidthAngle = tape[ptr++];
    return new IfcLightSourceSpot(expressID, type, Name, LightColour, AmbientIntensity, Intensity, Position, Radius, ConstantAttenuation, DistanceAttenuation, QuadricAttenuation, Orientation, ConcentrationExponent, SpreadAngle, BeamWidthAngle);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LightColour);
    args.push(this.AmbientIntensity);
    args.push(this.Intensity);
    args.push(this.Position);
    args.push(this.Radius);
    args.push(this.ConstantAttenuation);
    args.push(this.DistanceAttenuation);
    args.push(this.QuadricAttenuation);
    args.push(this.Orientation);
    args.push(this.ConcentrationExponent);
    args.push(this.SpreadAngle);
    args.push(this.BeamWidthAngle);
    return args;
  }
};
var IfcLine = class {
  constructor(expressID, type, Pnt, Dir) {
    this.expressID = expressID;
    this.type = type;
    this.Pnt = Pnt;
    this.Dir = Dir;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Pnt = tape[ptr++];
    let Dir = tape[ptr++];
    return new IfcLine(expressID, type, Pnt, Dir);
  }
  ToTape() {
    let args = [];
    args.push(this.Pnt);
    args.push(this.Dir);
    return args;
  }
};
var IfcLineSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    return new IfcLineSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    return args;
  }
};
var IfcLinearPlacement = class {
  constructor(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.PlacementMeasuredAlong = PlacementMeasuredAlong;
    this.Distance = Distance;
    this.Orientation = Orientation;
    this.CartesianPosition = CartesianPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let PlacementMeasuredAlong = tape[ptr++];
    let Distance = tape[ptr++];
    let Orientation = tape[ptr++];
    let CartesianPosition = tape[ptr++];
    return new IfcLinearPlacement(expressID, type, PlacementRelTo, PlacementMeasuredAlong, Distance, Orientation, CartesianPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.PlacementMeasuredAlong);
    args.push(this.Distance);
    args.push(this.Orientation);
    args.push(this.CartesianPosition);
    return args;
  }
};
var IfcLinearPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcLinearPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Axis);
    return args;
  }
};
var IfcLocalPlacement = class {
  constructor(expressID, type, PlacementRelTo, RelativePlacement) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
    this.RelativePlacement = RelativePlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    let RelativePlacement = tape[ptr++];
    return new IfcLocalPlacement(expressID, type, PlacementRelTo, RelativePlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    args.push(this.RelativePlacement);
    return args;
  }
};
var IfcLoop = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcLoop(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcManifoldSolidBrep = class {
  constructor(expressID, type, Outer) {
    this.expressID = expressID;
    this.type = type;
    this.Outer = Outer;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Outer = tape[ptr++];
    return new IfcManifoldSolidBrep(expressID, type, Outer);
  }
  ToTape() {
    let args = [];
    args.push(this.Outer);
    return args;
  }
};
var IfcMapConversion = class {
  constructor(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale) {
    this.expressID = expressID;
    this.type = type;
    this.SourceCRS = SourceCRS;
    this.TargetCRS = TargetCRS;
    this.Eastings = Eastings;
    this.Northings = Northings;
    this.OrthogonalHeight = OrthogonalHeight;
    this.XAxisAbscissa = XAxisAbscissa;
    this.XAxisOrdinate = XAxisOrdinate;
    this.Scale = Scale;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SourceCRS = tape[ptr++];
    let TargetCRS = tape[ptr++];
    let Eastings = tape[ptr++];
    let Northings = tape[ptr++];
    let OrthogonalHeight = tape[ptr++];
    let XAxisAbscissa = tape[ptr++];
    let XAxisOrdinate = tape[ptr++];
    let Scale = tape[ptr++];
    return new IfcMapConversion(expressID, type, SourceCRS, TargetCRS, Eastings, Northings, OrthogonalHeight, XAxisAbscissa, XAxisOrdinate, Scale);
  }
  ToTape() {
    let args = [];
    args.push(this.SourceCRS);
    args.push(this.TargetCRS);
    args.push(this.Eastings);
    args.push(this.Northings);
    args.push(this.OrthogonalHeight);
    args.push(this.XAxisAbscissa);
    args.push(this.XAxisOrdinate);
    args.push(this.Scale);
    return args;
  }
};
var IfcMappedItem = class {
  constructor(expressID, type, MappingSource, MappingTarget) {
    this.expressID = expressID;
    this.type = type;
    this.MappingSource = MappingSource;
    this.MappingTarget = MappingTarget;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingSource = tape[ptr++];
    let MappingTarget = tape[ptr++];
    return new IfcMappedItem(expressID, type, MappingSource, MappingTarget);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingSource);
    args.push(this.MappingTarget);
    return args;
  }
};
var IfcMaterial = class {
  constructor(expressID, type, Name, Description, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterial(expressID, type, Name, Description, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialClassificationRelationship = class {
  constructor(expressID, type, MaterialClassifications, ClassifiedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialClassifications = MaterialClassifications;
    this.ClassifiedMaterial = ClassifiedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialClassifications = tape[ptr++];
    let ClassifiedMaterial = tape[ptr++];
    return new IfcMaterialClassificationRelationship(expressID, type, MaterialClassifications, ClassifiedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialClassifications);
    args.push(this.ClassifiedMaterial);
    return args;
  }
};
var IfcMaterialConstituent = class {
  constructor(expressID, type, Name, Description, Material, Fraction, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Fraction = Fraction;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Fraction = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialConstituent(expressID, type, Name, Description, Material, Fraction, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Fraction);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialConstituentSet = class {
  constructor(expressID, type, Name, Description, MaterialConstituents) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialConstituents = MaterialConstituents;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialConstituents = tape[ptr++];
    return new IfcMaterialConstituentSet(expressID, type, Name, Description, MaterialConstituents);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MaterialConstituents);
    return args;
  }
};
var IfcMaterialDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcMaterialDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMaterialDefinitionRepresentation = class {
  constructor(expressID, type, Name, Description, Representations, RepresentedMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
    this.RepresentedMaterial = RepresentedMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    let RepresentedMaterial = tape[ptr++];
    return new IfcMaterialDefinitionRepresentation(expressID, type, Name, Description, Representations, RepresentedMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    args.push(this.RepresentedMaterial);
    return args;
  }
};
var IfcMaterialLayer = class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    return new IfcMaterialLayer(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    args.push(this.LayerThickness);
    args.push(this.IsVentilated);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    args.push(this.Priority);
    return args;
  }
};
var IfcMaterialLayerSet = class {
  constructor(expressID, type, MaterialLayers, LayerSetName, Description) {
    this.expressID = expressID;
    this.type = type;
    this.MaterialLayers = MaterialLayers;
    this.LayerSetName = LayerSetName;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MaterialLayers = tape[ptr++];
    let LayerSetName = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcMaterialLayerSet(expressID, type, MaterialLayers, LayerSetName, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.MaterialLayers);
    args.push(this.LayerSetName);
    args.push(this.Description);
    return args;
  }
};
var IfcMaterialLayerSetUsage = class {
  constructor(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForLayerSet = ForLayerSet;
    this.LayerSetDirection = LayerSetDirection;
    this.DirectionSense = DirectionSense;
    this.OffsetFromReferenceLine = OffsetFromReferenceLine;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForLayerSet = tape[ptr++];
    let LayerSetDirection = tape[ptr++];
    let DirectionSense = tape[ptr++];
    let OffsetFromReferenceLine = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialLayerSetUsage(expressID, type, ForLayerSet, LayerSetDirection, DirectionSense, OffsetFromReferenceLine, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForLayerSet);
    args.push(this.LayerSetDirection);
    args.push(this.DirectionSense);
    args.push(this.OffsetFromReferenceLine);
    args.push(this.ReferenceExtent);
    return args;
  }
};
var IfcMaterialLayerWithOffsets = class {
  constructor(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Material = Material;
    this.LayerThickness = LayerThickness;
    this.IsVentilated = IsVentilated;
    this.Name = Name;
    this.Description = Description;
    this.Category = Category;
    this.Priority = Priority;
    this.OffsetDirection = OffsetDirection;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Material = tape[ptr++];
    let LayerThickness = tape[ptr++];
    let IsVentilated = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Category = tape[ptr++];
    let Priority = tape[ptr++];
    let OffsetDirection = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialLayerWithOffsets(expressID, type, Material, LayerThickness, IsVentilated, Name, Description, Category, Priority, OffsetDirection, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Material);
    args.push(this.LayerThickness);
    args.push(this.IsVentilated);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Category);
    args.push(this.Priority);
    args.push(this.OffsetDirection);
    args.push(this.OffsetValues);
    return args;
  }
};
var IfcMaterialList = class {
  constructor(expressID, type, Materials) {
    this.expressID = expressID;
    this.type = type;
    this.Materials = Materials;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Materials = tape[ptr++];
    return new IfcMaterialList(expressID, type, Materials);
  }
  ToTape() {
    let args = [];
    args.push(this.Materials);
    return args;
  }
};
var IfcMaterialProfile = class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    return new IfcMaterialProfile(expressID, type, Name, Description, Material, Profile, Priority, Category);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Profile);
    args.push(this.Priority);
    args.push(this.Category);
    return args;
  }
};
var IfcMaterialProfileSet = class {
  constructor(expressID, type, Name, Description, MaterialProfiles, CompositeProfile) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.MaterialProfiles = MaterialProfiles;
    this.CompositeProfile = CompositeProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let MaterialProfiles = tape[ptr++];
    let CompositeProfile = tape[ptr++];
    return new IfcMaterialProfileSet(expressID, type, Name, Description, MaterialProfiles, CompositeProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.MaterialProfiles);
    args.push(this.CompositeProfile);
    return args;
  }
};
var IfcMaterialProfileSetUsage = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    return new IfcMaterialProfileSetUsage(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    args.push(this.CardinalPoint);
    args.push(this.ReferenceExtent);
    return args;
  }
};
var IfcMaterialProfileSetUsageTapering = class {
  constructor(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint) {
    this.expressID = expressID;
    this.type = type;
    this.ForProfileSet = ForProfileSet;
    this.CardinalPoint = CardinalPoint;
    this.ReferenceExtent = ReferenceExtent;
    this.ForProfileEndSet = ForProfileEndSet;
    this.CardinalEndPoint = CardinalEndPoint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ForProfileSet = tape[ptr++];
    let CardinalPoint = tape[ptr++];
    let ReferenceExtent = tape[ptr++];
    let ForProfileEndSet = tape[ptr++];
    let CardinalEndPoint = tape[ptr++];
    return new IfcMaterialProfileSetUsageTapering(expressID, type, ForProfileSet, CardinalPoint, ReferenceExtent, ForProfileEndSet, CardinalEndPoint);
  }
  ToTape() {
    let args = [];
    args.push(this.ForProfileSet);
    args.push(this.CardinalPoint);
    args.push(this.ReferenceExtent);
    args.push(this.ForProfileEndSet);
    args.push(this.CardinalEndPoint);
    return args;
  }
};
var IfcMaterialProfileWithOffsets = class {
  constructor(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Material = Material;
    this.Profile = Profile;
    this.Priority = Priority;
    this.Category = Category;
    this.OffsetValues = OffsetValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Material = tape[ptr++];
    let Profile = tape[ptr++];
    let Priority = tape[ptr++];
    let Category = tape[ptr++];
    let OffsetValues = tape[ptr++];
    return new IfcMaterialProfileWithOffsets(expressID, type, Name, Description, Material, Profile, Priority, Category, OffsetValues);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Material);
    args.push(this.Profile);
    args.push(this.Priority);
    args.push(this.Category);
    args.push(this.OffsetValues);
    return args;
  }
};
var IfcMaterialProperties = class {
  constructor(expressID, type, Name, Description, Properties2, Material) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.Material = Material;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let Material = tape[ptr++];
    return new IfcMaterialProperties(expressID, type, Name, Description, Properties2, Material);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    args.push(this.Material);
    return args;
  }
};
var IfcMaterialRelationship = class {
  constructor(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingMaterial = RelatingMaterial;
    this.RelatedMaterials = RelatedMaterials;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    let RelatedMaterials = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcMaterialRelationship(expressID, type, Name, Description, RelatingMaterial, RelatedMaterials, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingMaterial);
    args.push(this.RelatedMaterials);
    args.push(this.Expression);
    return args;
  }
};
var IfcMaterialUsageDefinition = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcMaterialUsageDefinition(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcMeasureWithUnit = class {
  constructor(expressID, type, ValueComponent, UnitComponent) {
    this.expressID = expressID;
    this.type = type;
    this.ValueComponent = ValueComponent;
    this.UnitComponent = UnitComponent;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ValueComponent = tape[ptr++];
    let UnitComponent = tape[ptr++];
    return new IfcMeasureWithUnit(expressID, type, ValueComponent, UnitComponent);
  }
  ToTape() {
    let args = [];
    args.push(this.ValueComponent);
    args.push(this.UnitComponent);
    return args;
  }
};
var IfcMechanicalFastener = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMechanicalFastener(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NominalDiameter, NominalLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.NominalDiameter);
    args.push(this.NominalLength);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMechanicalFastenerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.NominalLength = NominalLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let NominalLength = tape[ptr++];
    return new IfcMechanicalFastenerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, NominalLength);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.NominalLength);
    return args;
  }
};
var IfcMedicalDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMedicalDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMedicalDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMemberStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMemberType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMemberType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMetric = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.Benchmark = Benchmark;
    this.ValueSource = ValueSource;
    this.DataValue = DataValue;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let Benchmark = tape[ptr++];
    let ValueSource = tape[ptr++];
    let DataValue = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcMetric(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, Benchmark, ValueSource, DataValue, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    args.push(this.Benchmark);
    args.push(this.ValueSource);
    args.push(this.DataValue);
    args.push(this.ReferencePath);
    return args;
  }
};
var IfcMirroredProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.ParentProfile = ParentProfile;
    this.Operator = Operator;
    this.Label = Label;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let ParentProfile = tape[ptr++];
    let Operator = tape[ptr++];
    let Label = tape[ptr++];
    return new IfcMirroredProfileDef(expressID, type, ProfileType, ProfileName, ParentProfile, Operator, Label);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.ParentProfile);
    args.push(this.Operator);
    args.push(this.Label);
    return args;
  }
};
var IfcMonetaryUnit = class {
  constructor(expressID, type, Currency) {
    this.expressID = expressID;
    this.type = type;
    this.Currency = Currency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Currency = tape[ptr++];
    return new IfcMonetaryUnit(expressID, type, Currency);
  }
  ToTape() {
    let args = [];
    args.push(this.Currency);
    return args;
  }
};
var IfcMotorConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcMotorConnectionType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcMotorConnectionType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcNamedUnit = class {
  constructor(expressID, type, Dimensions, UnitType) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    return new IfcNamedUnit(expressID, type, Dimensions, UnitType);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    return args;
  }
};
var IfcObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcObjectDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcObjectDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcObjectPlacement = class {
  constructor(expressID, type, PlacementRelTo) {
    this.expressID = expressID;
    this.type = type;
    this.PlacementRelTo = PlacementRelTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let PlacementRelTo = tape[ptr++];
    return new IfcObjectPlacement(expressID, type, PlacementRelTo);
  }
  ToTape() {
    let args = [];
    args.push(this.PlacementRelTo);
    return args;
  }
};
var IfcObjective = class {
  constructor(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ConstraintGrade = ConstraintGrade;
    this.ConstraintSource = ConstraintSource;
    this.CreatingActor = CreatingActor;
    this.CreationTime = CreationTime;
    this.UserDefinedGrade = UserDefinedGrade;
    this.BenchmarkValues = BenchmarkValues;
    this.LogicalAggregator = LogicalAggregator;
    this.ObjectiveQualifier = ObjectiveQualifier;
    this.UserDefinedQualifier = UserDefinedQualifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConstraintGrade = tape[ptr++];
    let ConstraintSource = tape[ptr++];
    let CreatingActor = tape[ptr++];
    let CreationTime = tape[ptr++];
    let UserDefinedGrade = tape[ptr++];
    let BenchmarkValues = tape[ptr++];
    let LogicalAggregator = tape[ptr++];
    let ObjectiveQualifier = tape[ptr++];
    let UserDefinedQualifier = tape[ptr++];
    return new IfcObjective(expressID, type, Name, Description, ConstraintGrade, ConstraintSource, CreatingActor, CreationTime, UserDefinedGrade, BenchmarkValues, LogicalAggregator, ObjectiveQualifier, UserDefinedQualifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConstraintGrade);
    args.push(this.ConstraintSource);
    args.push(this.CreatingActor);
    args.push(this.CreationTime);
    args.push(this.UserDefinedGrade);
    args.push(this.BenchmarkValues);
    args.push(this.LogicalAggregator);
    args.push(this.ObjectiveQualifier);
    args.push(this.UserDefinedQualifier);
    return args;
  }
};
var IfcOccupant = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheActor = TheActor;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheActor = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOccupant(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheActor, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheActor);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOffsetCurve = class {
  constructor(expressID, type, BasisCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    return new IfcOffsetCurve(expressID, type, BasisCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    return args;
  }
};
var IfcOffsetCurve2D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOffsetCurve2D(expressID, type, BasisCurve, Distance, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Distance);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcOffsetCurve3D = class {
  constructor(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Distance = Distance;
    this.SelfIntersect = SelfIntersect;
    this.RefDirection = RefDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Distance = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let RefDirection = tape[ptr++];
    return new IfcOffsetCurve3D(expressID, type, BasisCurve, Distance, SelfIntersect, RefDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Distance);
    args.push(this.SelfIntersect);
    args.push(this.RefDirection);
    return args;
  }
};
var IfcOffsetCurveByDistances = class {
  constructor(expressID, type, BasisCurve, OffsetValues, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.OffsetValues = OffsetValues;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let OffsetValues = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcOffsetCurveByDistances(expressID, type, BasisCurve, OffsetValues, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.OffsetValues);
    args.push(this.Tag);
    return args;
  }
};
var IfcOpenShell = class {
  constructor(expressID, type, CfsFaces) {
    this.expressID = expressID;
    this.type = type;
    this.CfsFaces = CfsFaces;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let CfsFaces = tape[ptr++];
    return new IfcOpenShell(expressID, type, CfsFaces);
  }
  ToTape() {
    let args = [];
    args.push(this.CfsFaces);
    return args;
  }
};
var IfcOpeningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOpeningStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOpeningStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOrganization = class {
  constructor(expressID, type, Identification, Name, Description, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.Name = Name;
    this.Description = Description;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcOrganization(expressID, type, Identification, Name, Description, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Roles);
    args.push(this.Addresses);
    return args;
  }
};
var IfcOrganizationRelationship = class {
  constructor(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOrganization = RelatingOrganization;
    this.RelatedOrganizations = RelatedOrganizations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOrganization = tape[ptr++];
    let RelatedOrganizations = tape[ptr++];
    return new IfcOrganizationRelationship(expressID, type, Name, Description, RelatingOrganization, RelatedOrganizations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingOrganization);
    args.push(this.RelatedOrganizations);
    return args;
  }
};
var IfcOrientationExpression = class {
  constructor(expressID, type, LateralAxisDirection, VerticalAxisDirection) {
    this.expressID = expressID;
    this.type = type;
    this.LateralAxisDirection = LateralAxisDirection;
    this.VerticalAxisDirection = VerticalAxisDirection;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LateralAxisDirection = tape[ptr++];
    let VerticalAxisDirection = tape[ptr++];
    return new IfcOrientationExpression(expressID, type, LateralAxisDirection, VerticalAxisDirection);
  }
  ToTape() {
    let args = [];
    args.push(this.LateralAxisDirection);
    args.push(this.VerticalAxisDirection);
    return args;
  }
};
var IfcOrientedEdge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.EdgeElement = EdgeElement;
    this.Orientation = Orientation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let EdgeElement = tape[ptr++];
    let Orientation = tape[ptr++];
    return new IfcOrientedEdge(expressID, type, EdgeStart, EdgeEnd, EdgeElement, Orientation);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.EdgeElement);
    args.push(this.Orientation);
    return args;
  }
};
var IfcOuterBoundaryCurve = class {
  constructor(expressID, type, Segments, SelfIntersect) {
    this.expressID = expressID;
    this.type = type;
    this.Segments = Segments;
    this.SelfIntersect = SelfIntersect;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Segments = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    return new IfcOuterBoundaryCurve(expressID, type, Segments, SelfIntersect);
  }
  ToTape() {
    let args = [];
    args.push(this.Segments);
    args.push(this.SelfIntersect);
    return args;
  }
};
var IfcOutlet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutlet(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOutletType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcOutletType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcOwnerHistory = class {
  constructor(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate) {
    this.expressID = expressID;
    this.type = type;
    this.OwningUser = OwningUser;
    this.OwningApplication = OwningApplication;
    this.State = State;
    this.ChangeAction = ChangeAction;
    this.LastModifiedDate = LastModifiedDate;
    this.LastModifyingUser = LastModifyingUser;
    this.LastModifyingApplication = LastModifyingApplication;
    this.CreationDate = CreationDate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let OwningUser = tape[ptr++];
    let OwningApplication = tape[ptr++];
    let State = tape[ptr++];
    let ChangeAction = tape[ptr++];
    let LastModifiedDate = tape[ptr++];
    let LastModifyingUser = tape[ptr++];
    let LastModifyingApplication = tape[ptr++];
    let CreationDate = tape[ptr++];
    return new IfcOwnerHistory(expressID, type, OwningUser, OwningApplication, State, ChangeAction, LastModifiedDate, LastModifyingUser, LastModifyingApplication, CreationDate);
  }
  ToTape() {
    let args = [];
    args.push(this.OwningUser);
    args.push(this.OwningApplication);
    args.push(this.State);
    args.push(this.ChangeAction);
    args.push(this.LastModifiedDate);
    args.push(this.LastModifyingUser);
    args.push(this.LastModifyingApplication);
    args.push(this.CreationDate);
    return args;
  }
};
var IfcParameterizedProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcParameterizedProfileDef(expressID, type, ProfileType, ProfileName, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    return args;
  }
};
var IfcPath = class {
  constructor(expressID, type, EdgeList) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeList = EdgeList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeList = tape[ptr++];
    return new IfcPath(expressID, type, EdgeList);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeList);
    return args;
  }
};
var IfcPcurve = class {
  constructor(expressID, type, BasisSurface, ReferenceCurve) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.ReferenceCurve = ReferenceCurve;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let ReferenceCurve = tape[ptr++];
    return new IfcPcurve(expressID, type, BasisSurface, ReferenceCurve);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.ReferenceCurve);
    return args;
  }
};
var IfcPerformanceHistory = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LifeCyclePhase = LifeCyclePhase;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LifeCyclePhase = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPerformanceHistory(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LifeCyclePhase, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LifeCyclePhase);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPermeableCoveringProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcPermeableCoveringProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.OperationType);
    args.push(this.PanelPosition);
    args.push(this.FrameDepth);
    args.push(this.FrameThickness);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcPermit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcPermit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcPerson = class {
  constructor(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses) {
    this.expressID = expressID;
    this.type = type;
    this.Identification = Identification;
    this.FamilyName = FamilyName;
    this.GivenName = GivenName;
    this.MiddleNames = MiddleNames;
    this.PrefixTitles = PrefixTitles;
    this.SuffixTitles = SuffixTitles;
    this.Roles = Roles;
    this.Addresses = Addresses;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identification = tape[ptr++];
    let FamilyName = tape[ptr++];
    let GivenName = tape[ptr++];
    let MiddleNames = tape[ptr++];
    let PrefixTitles = tape[ptr++];
    let SuffixTitles = tape[ptr++];
    let Roles = tape[ptr++];
    let Addresses = tape[ptr++];
    return new IfcPerson(expressID, type, Identification, FamilyName, GivenName, MiddleNames, PrefixTitles, SuffixTitles, Roles, Addresses);
  }
  ToTape() {
    let args = [];
    args.push(this.Identification);
    args.push(this.FamilyName);
    args.push(this.GivenName);
    args.push(this.MiddleNames);
    args.push(this.PrefixTitles);
    args.push(this.SuffixTitles);
    args.push(this.Roles);
    args.push(this.Addresses);
    return args;
  }
};
var IfcPersonAndOrganization = class {
  constructor(expressID, type, ThePerson, TheOrganization, Roles) {
    this.expressID = expressID;
    this.type = type;
    this.ThePerson = ThePerson;
    this.TheOrganization = TheOrganization;
    this.Roles = Roles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ThePerson = tape[ptr++];
    let TheOrganization = tape[ptr++];
    let Roles = tape[ptr++];
    return new IfcPersonAndOrganization(expressID, type, ThePerson, TheOrganization, Roles);
  }
  ToTape() {
    let args = [];
    args.push(this.ThePerson);
    args.push(this.TheOrganization);
    args.push(this.Roles);
    return args;
  }
};
var IfcPhysicalComplexQuantity = class {
  constructor(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.HasQuantities = HasQuantities;
    this.Discrimination = Discrimination;
    this.Quality = Quality;
    this.Usage = Usage;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasQuantities = tape[ptr++];
    let Discrimination = tape[ptr++];
    let Quality = tape[ptr++];
    let Usage = tape[ptr++];
    return new IfcPhysicalComplexQuantity(expressID, type, Name, Description, HasQuantities, Discrimination, Quality, Usage);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.HasQuantities);
    args.push(this.Discrimination);
    args.push(this.Quality);
    args.push(this.Usage);
    return args;
  }
};
var IfcPhysicalQuantity = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPhysicalQuantity(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPhysicalSimpleQuantity = class {
  constructor(expressID, type, Name, Description, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPhysicalSimpleQuantity(expressID, type, Name, Description, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    return args;
  }
};
var IfcPile = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
    this.ConstructionType = ConstructionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ConstructionType = tape[ptr++];
    return new IfcPile(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType, ConstructionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    args.push(this.ConstructionType);
    return args;
  }
};
var IfcPileType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPileType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeFitting = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFitting(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeFittingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeFittingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeSegment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPipeSegmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPipeSegmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPixelTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
    this.Width = Width;
    this.Height = Height;
    this.ColourComponents = ColourComponents;
    this.Pixel = Pixel;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    let Width = tape[ptr++];
    let Height = tape[ptr++];
    let ColourComponents = tape[ptr++];
    let Pixel = tape[ptr++];
    return new IfcPixelTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter, Width, Height, ColourComponents, Pixel);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    args.push(this.Width);
    args.push(this.Height);
    args.push(this.ColourComponents);
    args.push(this.Pixel);
    return args;
  }
};
var IfcPlacement = class {
  constructor(expressID, type, Location) {
    this.expressID = expressID;
    this.type = type;
    this.Location = Location;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Location = tape[ptr++];
    return new IfcPlacement(expressID, type, Location);
  }
  ToTape() {
    let args = [];
    args.push(this.Location);
    return args;
  }
};
var IfcPlanarBox = class {
  constructor(expressID, type, SizeInX, SizeInY, Placement) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
    this.Placement = Placement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    let Placement = tape[ptr++];
    return new IfcPlanarBox(expressID, type, SizeInX, SizeInY, Placement);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    args.push(this.SizeInY);
    args.push(this.Placement);
    return args;
  }
};
var IfcPlanarExtent = class {
  constructor(expressID, type, SizeInX, SizeInY) {
    this.expressID = expressID;
    this.type = type;
    this.SizeInX = SizeInX;
    this.SizeInY = SizeInY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SizeInX = tape[ptr++];
    let SizeInY = tape[ptr++];
    return new IfcPlanarExtent(expressID, type, SizeInX, SizeInY);
  }
  ToTape() {
    let args = [];
    args.push(this.SizeInX);
    args.push(this.SizeInY);
    return args;
  }
};
var IfcPlane$1 = class {
  constructor(expressID, type, Position) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    return new IfcPlane$1(expressID, type, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    return args;
  }
};
var IfcPlate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlate(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPlateStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPlateType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPlateType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPoint = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPoint(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPointOnCurve = class {
  constructor(expressID, type, BasisCurve, PointParameter) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.PointParameter = PointParameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let PointParameter = tape[ptr++];
    return new IfcPointOnCurve(expressID, type, BasisCurve, PointParameter);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.PointParameter);
    return args;
  }
};
var IfcPointOnSurface = class {
  constructor(expressID, type, BasisSurface, PointParameterU, PointParameterV) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.PointParameterU = PointParameterU;
    this.PointParameterV = PointParameterV;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let PointParameterU = tape[ptr++];
    let PointParameterV = tape[ptr++];
    return new IfcPointOnSurface(expressID, type, BasisSurface, PointParameterU, PointParameterV);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.PointParameterU);
    args.push(this.PointParameterV);
    return args;
  }
};
var IfcPolyLoop = class {
  constructor(expressID, type, Polygon) {
    this.expressID = expressID;
    this.type = type;
    this.Polygon = Polygon;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Polygon = tape[ptr++];
    return new IfcPolyLoop(expressID, type, Polygon);
  }
  ToTape() {
    let args = [];
    args.push(this.Polygon);
    return args;
  }
};
var IfcPolygonalBoundedHalfSpace = class {
  constructor(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.BaseSurface = BaseSurface;
    this.AgreementFlag = AgreementFlag;
    this.Position = Position;
    this.PolygonalBoundary = PolygonalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BaseSurface = tape[ptr++];
    let AgreementFlag = tape[ptr++];
    let Position = tape[ptr++];
    let PolygonalBoundary = tape[ptr++];
    return new IfcPolygonalBoundedHalfSpace(expressID, type, BaseSurface, AgreementFlag, Position, PolygonalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.BaseSurface);
    args.push(this.AgreementFlag);
    args.push(this.Position);
    args.push(this.PolygonalBoundary);
    return args;
  }
};
var IfcPolygonalFaceSet = class {
  constructor(expressID, type, Coordinates, Closed, Faces, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Closed = Closed;
    this.Faces = Faces;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Closed = tape[ptr++];
    let Faces = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcPolygonalFaceSet(expressID, type, Coordinates, Closed, Faces, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Closed);
    args.push(this.Faces);
    args.push(this.PnIndex);
    return args;
  }
};
var IfcPolyline = class {
  constructor(expressID, type, Points) {
    this.expressID = expressID;
    this.type = type;
    this.Points = Points;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Points = tape[ptr++];
    return new IfcPolyline(expressID, type, Points);
  }
  ToTape() {
    let args = [];
    args.push(this.Points);
    return args;
  }
};
var IfcPort = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPort(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcPositioningElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcPositioningElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcPostalAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.InternalLocation = InternalLocation;
    this.AddressLines = AddressLines;
    this.PostalBox = PostalBox;
    this.Town = Town;
    this.Region = Region;
    this.PostalCode = PostalCode;
    this.Country = Country;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let InternalLocation = tape[ptr++];
    let AddressLines = tape[ptr++];
    let PostalBox = tape[ptr++];
    let Town = tape[ptr++];
    let Region = tape[ptr++];
    let PostalCode = tape[ptr++];
    let Country = tape[ptr++];
    return new IfcPostalAddress(expressID, type, Purpose, Description, UserDefinedPurpose, InternalLocation, AddressLines, PostalBox, Town, Region, PostalCode, Country);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    args.push(this.InternalLocation);
    args.push(this.AddressLines);
    args.push(this.PostalBox);
    args.push(this.Town);
    args.push(this.Region);
    args.push(this.PostalCode);
    args.push(this.Country);
    return args;
  }
};
var IfcPreDefinedColour = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedColour(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedCurveFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedCurveFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedItem = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedItem(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPreDefinedProperties = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPreDefinedProperties(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPreDefinedPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPreDefinedPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPreDefinedTextFont = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPreDefinedTextFont(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPresentationLayerAssignment = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    return new IfcPresentationLayerAssignment(expressID, type, Name, Description, AssignedItems, Identifier);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AssignedItems);
    args.push(this.Identifier);
    return args;
  }
};
var IfcPresentationLayerWithStyle = class {
  constructor(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.AssignedItems = AssignedItems;
    this.Identifier = Identifier;
    this.LayerOn = LayerOn;
    this.LayerFrozen = LayerFrozen;
    this.LayerBlocked = LayerBlocked;
    this.LayerStyles = LayerStyles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let AssignedItems = tape[ptr++];
    let Identifier = tape[ptr++];
    let LayerOn = tape[ptr++];
    let LayerFrozen = tape[ptr++];
    let LayerBlocked = tape[ptr++];
    let LayerStyles = tape[ptr++];
    return new IfcPresentationLayerWithStyle(expressID, type, Name, Description, AssignedItems, Identifier, LayerOn, LayerFrozen, LayerBlocked, LayerStyles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.AssignedItems);
    args.push(this.Identifier);
    args.push(this.LayerOn);
    args.push(this.LayerFrozen);
    args.push(this.LayerBlocked);
    args.push(this.LayerStyles);
    return args;
  }
};
var IfcPresentationStyle = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcPresentationStyle(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcPresentationStyleAssignment = class {
  constructor(expressID, type, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Styles = tape[ptr++];
    return new IfcPresentationStyleAssignment(expressID, type, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Styles);
    return args;
  }
};
var IfcProcedure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedure(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProcedureType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProcedureType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcProductDefinitionShape = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductDefinitionShape(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    return args;
  }
};
var IfcProductRepresentation = class {
  constructor(expressID, type, Name, Description, Representations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Representations = Representations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Representations = tape[ptr++];
    return new IfcProductRepresentation(expressID, type, Name, Description, Representations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Representations);
    return args;
  }
};
var IfcProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    return new IfcProfileDef(expressID, type, ProfileType, ProfileName);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    return args;
  }
};
var IfcProfileProperties = class {
  constructor(expressID, type, Name, Description, Properties2, ProfileDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Properties = Properties2;
    this.ProfileDefinition = ProfileDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Properties2 = tape[ptr++];
    let ProfileDefinition = tape[ptr++];
    return new IfcProfileProperties(expressID, type, Name, Description, Properties2, ProfileDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Properties);
    args.push(this.ProfileDefinition);
    return args;
  }
};
var IfcProject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProject(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcProjectLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
    this.Phase = Phase;
    this.RepresentationContexts = RepresentationContexts;
    this.UnitsInContext = UnitsInContext;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    let Phase = tape[ptr++];
    let RepresentationContexts = tape[ptr++];
    let UnitsInContext = tape[ptr++];
    return new IfcProjectLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName, Phase, RepresentationContexts, UnitsInContext);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    args.push(this.Phase);
    args.push(this.RepresentationContexts);
    args.push(this.UnitsInContext);
    return args;
  }
};
var IfcProjectOrder = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.PredefinedType = PredefinedType;
    this.Status = Status;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Status = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcProjectOrder(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, PredefinedType, Status, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.PredefinedType);
    args.push(this.Status);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcProjectedCRS = class {
  constructor(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.GeodeticDatum = GeodeticDatum;
    this.VerticalDatum = VerticalDatum;
    this.MapProjection = MapProjection;
    this.MapZone = MapZone;
    this.MapUnit = MapUnit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let GeodeticDatum = tape[ptr++];
    let VerticalDatum = tape[ptr++];
    let MapProjection = tape[ptr++];
    let MapZone = tape[ptr++];
    let MapUnit = tape[ptr++];
    return new IfcProjectedCRS(expressID, type, Name, Description, GeodeticDatum, VerticalDatum, MapProjection, MapZone, MapUnit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.GeodeticDatum);
    args.push(this.VerticalDatum);
    args.push(this.MapProjection);
    args.push(this.MapZone);
    args.push(this.MapUnit);
    return args;
  }
};
var IfcProjectionElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProjectionElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyAbstraction = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcPropertyAbstraction(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcPropertyBoundedValue = class {
  constructor(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UpperBoundValue = UpperBoundValue;
    this.LowerBoundValue = LowerBoundValue;
    this.Unit = Unit;
    this.SetPointValue = SetPointValue;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UpperBoundValue = tape[ptr++];
    let LowerBoundValue = tape[ptr++];
    let Unit = tape[ptr++];
    let SetPointValue = tape[ptr++];
    return new IfcPropertyBoundedValue(expressID, type, Name, Description, UpperBoundValue, LowerBoundValue, Unit, SetPointValue);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UpperBoundValue);
    args.push(this.LowerBoundValue);
    args.push(this.Unit);
    args.push(this.SetPointValue);
    return args;
  }
};
var IfcPropertyDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyDependencyRelationship = class {
  constructor(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DependingProperty = DependingProperty;
    this.DependantProperty = DependantProperty;
    this.Expression = Expression;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DependingProperty = tape[ptr++];
    let DependantProperty = tape[ptr++];
    let Expression = tape[ptr++];
    return new IfcPropertyDependencyRelationship(expressID, type, Name, Description, DependingProperty, DependantProperty, Expression);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DependingProperty);
    args.push(this.DependantProperty);
    args.push(this.Expression);
    return args;
  }
};
var IfcPropertyEnumeratedValue = class {
  constructor(expressID, type, Name, Description, EnumerationValues, EnumerationReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.EnumerationValues = EnumerationValues;
    this.EnumerationReference = EnumerationReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let EnumerationReference = tape[ptr++];
    return new IfcPropertyEnumeratedValue(expressID, type, Name, Description, EnumerationValues, EnumerationReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.EnumerationValues);
    args.push(this.EnumerationReference);
    return args;
  }
};
var IfcPropertyEnumeration = class {
  constructor(expressID, type, Name, EnumerationValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.EnumerationValues = EnumerationValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let EnumerationValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyEnumeration(expressID, type, Name, EnumerationValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.EnumerationValues);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyListValue = class {
  constructor(expressID, type, Name, Description, ListValues, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.ListValues = ListValues;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ListValues = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertyListValue(expressID, type, Name, Description, ListValues, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ListValues);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyReferenceValue = class {
  constructor(expressID, type, Name, Description, UsageName, PropertyReference) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.UsageName = UsageName;
    this.PropertyReference = PropertyReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let UsageName = tape[ptr++];
    let PropertyReference = tape[ptr++];
    return new IfcPropertyReferenceValue(expressID, type, Name, Description, UsageName, PropertyReference);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.UsageName);
    args.push(this.PropertyReference);
    return args;
  }
};
var IfcPropertySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.HasProperties = HasProperties;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let HasProperties = tape[ptr++];
    return new IfcPropertySet(expressID, type, GlobalId, OwnerHistory, Name, Description, HasProperties);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.HasProperties);
    return args;
  }
};
var IfcPropertySetDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertySetDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertySetTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.ApplicableEntity = ApplicableEntity;
    this.HasPropertyTemplates = HasPropertyTemplates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let ApplicableEntity = tape[ptr++];
    let HasPropertyTemplates = tape[ptr++];
    return new IfcPropertySetTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, ApplicableEntity, HasPropertyTemplates);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TemplateType);
    args.push(this.ApplicableEntity);
    args.push(this.HasPropertyTemplates);
    return args;
  }
};
var IfcPropertySingleValue = class {
  constructor(expressID, type, Name, Description, NominalValue, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.NominalValue = NominalValue;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let NominalValue = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcPropertySingleValue(expressID, type, Name, Description, NominalValue, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.NominalValue);
    args.push(this.Unit);
    return args;
  }
};
var IfcPropertyTableValue = class {
  constructor(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.DefiningValues = DefiningValues;
    this.DefinedValues = DefinedValues;
    this.Expression = Expression;
    this.DefiningUnit = DefiningUnit;
    this.DefinedUnit = DefinedUnit;
    this.CurveInterpolation = CurveInterpolation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefiningValues = tape[ptr++];
    let DefinedValues = tape[ptr++];
    let Expression = tape[ptr++];
    let DefiningUnit = tape[ptr++];
    let DefinedUnit = tape[ptr++];
    let CurveInterpolation = tape[ptr++];
    return new IfcPropertyTableValue(expressID, type, Name, Description, DefiningValues, DefinedValues, Expression, DefiningUnit, DefinedUnit, CurveInterpolation);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DefiningValues);
    args.push(this.DefinedValues);
    args.push(this.Expression);
    args.push(this.DefiningUnit);
    args.push(this.DefinedUnit);
    args.push(this.CurveInterpolation);
    return args;
  }
};
var IfcPropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcPropertyTemplateDefinition = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcPropertyTemplateDefinition(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcProtectiveDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceTrippingUnitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceTrippingUnitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProtectiveDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcProtectiveDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcProxy = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.ProxyType = ProxyType;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let ProxyType = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcProxy(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, ProxyType, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.ProxyType);
    args.push(this.Tag);
    return args;
  }
};
var IfcPump = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPump(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcPumpType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcPumpType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcQuantityArea = class {
  constructor(expressID, type, Name, Description, Unit, AreaValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.AreaValue = AreaValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let AreaValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityArea(expressID, type, Name, Description, Unit, AreaValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.AreaValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityCount = class {
  constructor(expressID, type, Name, Description, Unit, CountValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.CountValue = CountValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let CountValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityCount(expressID, type, Name, Description, Unit, CountValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.CountValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityLength = class {
  constructor(expressID, type, Name, Description, Unit, LengthValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.LengthValue = LengthValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let LengthValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityLength(expressID, type, Name, Description, Unit, LengthValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.LengthValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantitySet = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcQuantitySet(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcQuantityTime = class {
  constructor(expressID, type, Name, Description, Unit, TimeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.TimeValue = TimeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityTime(expressID, type, Name, Description, Unit, TimeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.TimeValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityVolume = class {
  constructor(expressID, type, Name, Description, Unit, VolumeValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.VolumeValue = VolumeValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let VolumeValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityVolume(expressID, type, Name, Description, Unit, VolumeValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.VolumeValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcQuantityWeight = class {
  constructor(expressID, type, Name, Description, Unit, WeightValue, Formula) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.WeightValue = WeightValue;
    this.Formula = Formula;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let WeightValue = tape[ptr++];
    let Formula = tape[ptr++];
    return new IfcQuantityWeight(expressID, type, Name, Description, Unit, WeightValue, Formula);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.WeightValue);
    args.push(this.Formula);
    return args;
  }
};
var IfcRailing = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailing(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRailingType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRailingType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRamp = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRamp(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRampType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRampType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRationalBSplineCurveWithKnots = class {
  constructor(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.Degree = Degree;
    this.ControlPointsList = ControlPointsList;
    this.CurveForm = CurveForm;
    this.ClosedCurve = ClosedCurve;
    this.SelfIntersect = SelfIntersect;
    this.KnotMultiplicities = KnotMultiplicities;
    this.Knots = Knots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Degree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let CurveForm = tape[ptr++];
    let ClosedCurve = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let KnotMultiplicities = tape[ptr++];
    let Knots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineCurveWithKnots(expressID, type, Degree, ControlPointsList, CurveForm, ClosedCurve, SelfIntersect, KnotMultiplicities, Knots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.Degree);
    args.push(this.ControlPointsList);
    args.push(this.CurveForm);
    args.push(this.ClosedCurve);
    args.push(this.SelfIntersect);
    args.push(this.KnotMultiplicities);
    args.push(this.Knots);
    args.push(this.KnotSpec);
    args.push(this.WeightsData);
    return args;
  }
};
var IfcRationalBSplineSurfaceWithKnots = class {
  constructor(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData) {
    this.expressID = expressID;
    this.type = type;
    this.UDegree = UDegree;
    this.VDegree = VDegree;
    this.ControlPointsList = ControlPointsList;
    this.SurfaceForm = SurfaceForm;
    this.UClosed = UClosed;
    this.VClosed = VClosed;
    this.SelfIntersect = SelfIntersect;
    this.UMultiplicities = UMultiplicities;
    this.VMultiplicities = VMultiplicities;
    this.UKnots = UKnots;
    this.VKnots = VKnots;
    this.KnotSpec = KnotSpec;
    this.WeightsData = WeightsData;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let UDegree = tape[ptr++];
    let VDegree = tape[ptr++];
    let ControlPointsList = tape[ptr++];
    let SurfaceForm = tape[ptr++];
    let UClosed = tape[ptr++];
    let VClosed = tape[ptr++];
    let SelfIntersect = tape[ptr++];
    let UMultiplicities = tape[ptr++];
    let VMultiplicities = tape[ptr++];
    let UKnots = tape[ptr++];
    let VKnots = tape[ptr++];
    let KnotSpec = tape[ptr++];
    let WeightsData = tape[ptr++];
    return new IfcRationalBSplineSurfaceWithKnots(expressID, type, UDegree, VDegree, ControlPointsList, SurfaceForm, UClosed, VClosed, SelfIntersect, UMultiplicities, VMultiplicities, UKnots, VKnots, KnotSpec, WeightsData);
  }
  ToTape() {
    let args = [];
    args.push(this.UDegree);
    args.push(this.VDegree);
    args.push(this.ControlPointsList);
    args.push(this.SurfaceForm);
    args.push(this.UClosed);
    args.push(this.VClosed);
    args.push(this.SelfIntersect);
    args.push(this.UMultiplicities);
    args.push(this.VMultiplicities);
    args.push(this.UKnots);
    args.push(this.VKnots);
    args.push(this.KnotSpec);
    args.push(this.WeightsData);
    return args;
  }
};
var IfcRectangleHollowProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.WallThickness = WallThickness;
    this.InnerFilletRadius = InnerFilletRadius;
    this.OuterFilletRadius = OuterFilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let WallThickness = tape[ptr++];
    let InnerFilletRadius = tape[ptr++];
    let OuterFilletRadius = tape[ptr++];
    return new IfcRectangleHollowProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, WallThickness, InnerFilletRadius, OuterFilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.WallThickness);
    args.push(this.InnerFilletRadius);
    args.push(this.OuterFilletRadius);
    return args;
  }
};
var IfcRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    return new IfcRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    return args;
  }
};
var IfcRectangularPyramid = class {
  constructor(expressID, type, Position, XLength, YLength, Height) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.XLength = XLength;
    this.YLength = YLength;
    this.Height = Height;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let XLength = tape[ptr++];
    let YLength = tape[ptr++];
    let Height = tape[ptr++];
    return new IfcRectangularPyramid(expressID, type, Position, XLength, YLength, Height);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.XLength);
    args.push(this.YLength);
    args.push(this.Height);
    return args;
  }
};
var IfcRectangularTrimmedSurface = class {
  constructor(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense) {
    this.expressID = expressID;
    this.type = type;
    this.BasisSurface = BasisSurface;
    this.U1 = U1;
    this.V1 = V1;
    this.U2 = U2;
    this.V2 = V2;
    this.Usense = Usense;
    this.Vsense = Vsense;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisSurface = tape[ptr++];
    let U1 = tape[ptr++];
    let V1 = tape[ptr++];
    let U2 = tape[ptr++];
    let V2 = tape[ptr++];
    let Usense = tape[ptr++];
    let Vsense = tape[ptr++];
    return new IfcRectangularTrimmedSurface(expressID, type, BasisSurface, U1, V1, U2, V2, Usense, Vsense);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisSurface);
    args.push(this.U1);
    args.push(this.V1);
    args.push(this.U2);
    args.push(this.V2);
    args.push(this.Usense);
    args.push(this.Vsense);
    return args;
  }
};
var IfcRecurrencePattern = class {
  constructor(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods) {
    this.expressID = expressID;
    this.type = type;
    this.RecurrenceType = RecurrenceType;
    this.DayComponent = DayComponent;
    this.WeekdayComponent = WeekdayComponent;
    this.MonthComponent = MonthComponent;
    this.Position = Position;
    this.Interval = Interval;
    this.Occurrences = Occurrences;
    this.TimePeriods = TimePeriods;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RecurrenceType = tape[ptr++];
    let DayComponent = tape[ptr++];
    let WeekdayComponent = tape[ptr++];
    let MonthComponent = tape[ptr++];
    let Position = tape[ptr++];
    let Interval = tape[ptr++];
    let Occurrences = tape[ptr++];
    let TimePeriods = tape[ptr++];
    return new IfcRecurrencePattern(expressID, type, RecurrenceType, DayComponent, WeekdayComponent, MonthComponent, Position, Interval, Occurrences, TimePeriods);
  }
  ToTape() {
    let args = [];
    args.push(this.RecurrenceType);
    args.push(this.DayComponent);
    args.push(this.WeekdayComponent);
    args.push(this.MonthComponent);
    args.push(this.Position);
    args.push(this.Interval);
    args.push(this.Occurrences);
    args.push(this.TimePeriods);
    return args;
  }
};
var IfcReference = class {
  constructor(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference) {
    this.expressID = expressID;
    this.type = type;
    this.TypeIdentifier = TypeIdentifier;
    this.AttributeIdentifier = AttributeIdentifier;
    this.InstanceName = InstanceName;
    this.ListPositions = ListPositions;
    this.InnerReference = InnerReference;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TypeIdentifier = tape[ptr++];
    let AttributeIdentifier = tape[ptr++];
    let InstanceName = tape[ptr++];
    let ListPositions = tape[ptr++];
    let InnerReference = tape[ptr++];
    return new IfcReference(expressID, type, TypeIdentifier, AttributeIdentifier, InstanceName, ListPositions, InnerReference);
  }
  ToTape() {
    let args = [];
    args.push(this.TypeIdentifier);
    args.push(this.AttributeIdentifier);
    args.push(this.InstanceName);
    args.push(this.ListPositions);
    args.push(this.InnerReference);
    return args;
  }
};
var IfcReferent = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.RestartDistance = RestartDistance;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let RestartDistance = tape[ptr++];
    return new IfcReferent(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, RestartDistance);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.RestartDistance);
    return args;
  }
};
var IfcRegularTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
    this.TimeStep = TimeStep;
    this.Values = Values;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    let TimeStep = tape[ptr++];
    let Values = tape[ptr++];
    return new IfcRegularTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit, TimeStep, Values);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    args.push(this.TimeStep);
    args.push(this.Values);
    return args;
  }
};
var IfcReinforcementBarProperties = class {
  constructor(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount) {
    this.expressID = expressID;
    this.type = type;
    this.TotalCrossSectionArea = TotalCrossSectionArea;
    this.SteelGrade = SteelGrade;
    this.BarSurface = BarSurface;
    this.EffectiveDepth = EffectiveDepth;
    this.NominalBarDiameter = NominalBarDiameter;
    this.BarCount = BarCount;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TotalCrossSectionArea = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let BarSurface = tape[ptr++];
    let EffectiveDepth = tape[ptr++];
    let NominalBarDiameter = tape[ptr++];
    let BarCount = tape[ptr++];
    return new IfcReinforcementBarProperties(expressID, type, TotalCrossSectionArea, SteelGrade, BarSurface, EffectiveDepth, NominalBarDiameter, BarCount);
  }
  ToTape() {
    let args = [];
    args.push(this.TotalCrossSectionArea);
    args.push(this.SteelGrade);
    args.push(this.BarSurface);
    args.push(this.EffectiveDepth);
    args.push(this.NominalBarDiameter);
    args.push(this.BarCount);
    return args;
  }
};
var IfcReinforcementDefinitionProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.DefinitionType = DefinitionType;
    this.ReinforcementSectionDefinitions = ReinforcementSectionDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let DefinitionType = tape[ptr++];
    let ReinforcementSectionDefinitions = tape[ptr++];
    return new IfcReinforcementDefinitionProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, DefinitionType, ReinforcementSectionDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.DefinitionType);
    args.push(this.ReinforcementSectionDefinitions);
    return args;
  }
};
var IfcReinforcingBar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.PredefinedType = PredefinedType;
    this.BarSurface = BarSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let BarSurface = tape[ptr++];
    return new IfcReinforcingBar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, NominalDiameter, CrossSectionArea, BarLength, PredefinedType, BarSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.BarLength);
    args.push(this.PredefinedType);
    args.push(this.BarSurface);
    return args;
  }
};
var IfcReinforcingBarType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.BarLength = BarLength;
    this.BarSurface = BarSurface;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let BarLength = tape[ptr++];
    let BarSurface = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingBarType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, BarLength, BarSurface, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.BarLength);
    args.push(this.BarSurface);
    args.push(this.BendingShapeCode);
    args.push(this.BendingParameters);
    return args;
  }
};
var IfcReinforcingElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    return new IfcReinforcingElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    return args;
  }
};
var IfcReinforcingElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcReinforcingElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcReinforcingMesh = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcReinforcingMesh(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.MeshLength);
    args.push(this.MeshWidth);
    args.push(this.LongitudinalBarNominalDiameter);
    args.push(this.TransverseBarNominalDiameter);
    args.push(this.LongitudinalBarCrossSectionArea);
    args.push(this.TransverseBarCrossSectionArea);
    args.push(this.LongitudinalBarSpacing);
    args.push(this.TransverseBarSpacing);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcReinforcingMeshType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.MeshLength = MeshLength;
    this.MeshWidth = MeshWidth;
    this.LongitudinalBarNominalDiameter = LongitudinalBarNominalDiameter;
    this.TransverseBarNominalDiameter = TransverseBarNominalDiameter;
    this.LongitudinalBarCrossSectionArea = LongitudinalBarCrossSectionArea;
    this.TransverseBarCrossSectionArea = TransverseBarCrossSectionArea;
    this.LongitudinalBarSpacing = LongitudinalBarSpacing;
    this.TransverseBarSpacing = TransverseBarSpacing;
    this.BendingShapeCode = BendingShapeCode;
    this.BendingParameters = BendingParameters;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let MeshLength = tape[ptr++];
    let MeshWidth = tape[ptr++];
    let LongitudinalBarNominalDiameter = tape[ptr++];
    let TransverseBarNominalDiameter = tape[ptr++];
    let LongitudinalBarCrossSectionArea = tape[ptr++];
    let TransverseBarCrossSectionArea = tape[ptr++];
    let LongitudinalBarSpacing = tape[ptr++];
    let TransverseBarSpacing = tape[ptr++];
    let BendingShapeCode = tape[ptr++];
    let BendingParameters = tape[ptr++];
    return new IfcReinforcingMeshType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, MeshLength, MeshWidth, LongitudinalBarNominalDiameter, TransverseBarNominalDiameter, LongitudinalBarCrossSectionArea, TransverseBarCrossSectionArea, LongitudinalBarSpacing, TransverseBarSpacing, BendingShapeCode, BendingParameters);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.MeshLength);
    args.push(this.MeshWidth);
    args.push(this.LongitudinalBarNominalDiameter);
    args.push(this.TransverseBarNominalDiameter);
    args.push(this.LongitudinalBarCrossSectionArea);
    args.push(this.TransverseBarCrossSectionArea);
    args.push(this.LongitudinalBarSpacing);
    args.push(this.TransverseBarSpacing);
    args.push(this.BendingShapeCode);
    args.push(this.BendingParameters);
    return args;
  }
};
var IfcRelAggregates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAggregates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingObject);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelAssigns = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    return new IfcRelAssigns(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    return args;
  }
};
var IfcRelAssignsToActor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingActor = RelatingActor;
    this.ActingRole = ActingRole;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingActor = tape[ptr++];
    let ActingRole = tape[ptr++];
    return new IfcRelAssignsToActor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingActor, ActingRole);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingActor);
    args.push(this.ActingRole);
    return args;
  }
};
var IfcRelAssignsToControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingControl = RelatingControl;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingControl = tape[ptr++];
    return new IfcRelAssignsToControl(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingControl);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingControl);
    return args;
  }
};
var IfcRelAssignsToGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    return new IfcRelAssignsToGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingGroup);
    return args;
  }
};
var IfcRelAssignsToGroupByFactor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingGroup = RelatingGroup;
    this.Factor = Factor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingGroup = tape[ptr++];
    let Factor = tape[ptr++];
    return new IfcRelAssignsToGroupByFactor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingGroup, Factor);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingGroup);
    args.push(this.Factor);
    return args;
  }
};
var IfcRelAssignsToProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProcess = RelatingProcess;
    this.QuantityInProcess = QuantityInProcess;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let QuantityInProcess = tape[ptr++];
    return new IfcRelAssignsToProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProcess, QuantityInProcess);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingProcess);
    args.push(this.QuantityInProcess);
    return args;
  }
};
var IfcRelAssignsToProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingProduct = RelatingProduct;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingProduct = tape[ptr++];
    return new IfcRelAssignsToProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingProduct);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingProduct);
    return args;
  }
};
var IfcRelAssignsToResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatedObjectsType = RelatedObjectsType;
    this.RelatingResource = RelatingResource;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatedObjectsType = tape[ptr++];
    let RelatingResource = tape[ptr++];
    return new IfcRelAssignsToResource(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatedObjectsType, RelatingResource);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatedObjectsType);
    args.push(this.RelatingResource);
    return args;
  }
};
var IfcRelAssociates = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelAssociates(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelAssociatesApproval = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcRelAssociatesApproval(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingApproval);
    return args;
  }
};
var IfcRelAssociatesClassification = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingClassification = RelatingClassification;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingClassification = tape[ptr++];
    return new IfcRelAssociatesClassification(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingClassification);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingClassification);
    return args;
  }
};
var IfcRelAssociatesConstraint = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.Intent = Intent;
    this.RelatingConstraint = RelatingConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let Intent = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    return new IfcRelAssociatesConstraint(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, Intent, RelatingConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.Intent);
    args.push(this.RelatingConstraint);
    return args;
  }
};
var IfcRelAssociatesDocument = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingDocument = RelatingDocument;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingDocument = tape[ptr++];
    return new IfcRelAssociatesDocument(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingDocument);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingDocument);
    return args;
  }
};
var IfcRelAssociatesLibrary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingLibrary = RelatingLibrary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingLibrary = tape[ptr++];
    return new IfcRelAssociatesLibrary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingLibrary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingLibrary);
    return args;
  }
};
var IfcRelAssociatesMaterial = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingMaterial = RelatingMaterial;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingMaterial = tape[ptr++];
    return new IfcRelAssociatesMaterial(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingMaterial);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingMaterial);
    return args;
  }
};
var IfcRelConnects = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelConnects(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelConnectsElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    return args;
  }
};
var IfcRelConnectsPathElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RelatingPriorities = RelatingPriorities;
    this.RelatedPriorities = RelatedPriorities;
    this.RelatedConnectionType = RelatedConnectionType;
    this.RelatingConnectionType = RelatingConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RelatingPriorities = tape[ptr++];
    let RelatedPriorities = tape[ptr++];
    let RelatedConnectionType = tape[ptr++];
    let RelatingConnectionType = tape[ptr++];
    return new IfcRelConnectsPathElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RelatingPriorities, RelatedPriorities, RelatedConnectionType, RelatingConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.RelatingPriorities);
    args.push(this.RelatedPriorities);
    args.push(this.RelatedConnectionType);
    args.push(this.RelatingConnectionType);
    return args;
  }
};
var IfcRelConnectsPortToElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedElement = RelatedElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedElement = tape[ptr++];
    return new IfcRelConnectsPortToElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPort);
    args.push(this.RelatedElement);
    return args;
  }
};
var IfcRelConnectsPorts = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPort = RelatingPort;
    this.RelatedPort = RelatedPort;
    this.RealizingElement = RealizingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPort = tape[ptr++];
    let RelatedPort = tape[ptr++];
    let RealizingElement = tape[ptr++];
    return new IfcRelConnectsPorts(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPort, RelatedPort, RealizingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPort);
    args.push(this.RelatedPort);
    args.push(this.RealizingElement);
    return args;
  }
};
var IfcRelConnectsStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedStructuralActivity = RelatedStructuralActivity;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedStructuralActivity = tape[ptr++];
    return new IfcRelConnectsStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedStructuralActivity);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedStructuralActivity);
    return args;
  }
};
var IfcRelConnectsStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcRelConnectsStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingStructuralMember);
    args.push(this.RelatedStructuralConnection);
    args.push(this.AppliedCondition);
    args.push(this.AdditionalConditions);
    args.push(this.SupportedLength);
    args.push(this.ConditionCoordinateSystem);
    return args;
  }
};
var IfcRelConnectsWithEccentricity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingStructuralMember = RelatingStructuralMember;
    this.RelatedStructuralConnection = RelatedStructuralConnection;
    this.AppliedCondition = AppliedCondition;
    this.AdditionalConditions = AdditionalConditions;
    this.SupportedLength = SupportedLength;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
    this.ConnectionConstraint = ConnectionConstraint;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingStructuralMember = tape[ptr++];
    let RelatedStructuralConnection = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let AdditionalConditions = tape[ptr++];
    let SupportedLength = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    let ConnectionConstraint = tape[ptr++];
    return new IfcRelConnectsWithEccentricity(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingStructuralMember, RelatedStructuralConnection, AppliedCondition, AdditionalConditions, SupportedLength, ConditionCoordinateSystem, ConnectionConstraint);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingStructuralMember);
    args.push(this.RelatedStructuralConnection);
    args.push(this.AppliedCondition);
    args.push(this.AdditionalConditions);
    args.push(this.SupportedLength);
    args.push(this.ConditionCoordinateSystem);
    args.push(this.ConnectionConstraint);
    return args;
  }
};
var IfcRelConnectsWithRealizingElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ConnectionGeometry = ConnectionGeometry;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.RealizingElements = RealizingElements;
    this.ConnectionType = ConnectionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let RealizingElements = tape[ptr++];
    let ConnectionType = tape[ptr++];
    return new IfcRelConnectsWithRealizingElements(expressID, type, GlobalId, OwnerHistory, Name, Description, ConnectionGeometry, RelatingElement, RelatedElement, RealizingElements, ConnectionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ConnectionGeometry);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.RealizingElements);
    args.push(this.ConnectionType);
    return args;
  }
};
var IfcRelContainedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelContainedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedElements);
    args.push(this.RelatingStructure);
    return args;
  }
};
var IfcRelCoversBldgElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversBldgElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingBuildingElement);
    args.push(this.RelatedCoverings);
    return args;
  }
};
var IfcRelCoversSpaces = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedCoverings = RelatedCoverings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedCoverings = tape[ptr++];
    return new IfcRelCoversSpaces(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedCoverings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedCoverings);
    return args;
  }
};
var IfcRelDeclares = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingContext = RelatingContext;
    this.RelatedDefinitions = RelatedDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingContext = tape[ptr++];
    let RelatedDefinitions = tape[ptr++];
    return new IfcRelDeclares(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingContext, RelatedDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingContext);
    args.push(this.RelatedDefinitions);
    return args;
  }
};
var IfcRelDecomposes = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDecomposes(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelDefines = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelDefines(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRelDefinesByObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingObject = RelatingObject;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingObject = tape[ptr++];
    return new IfcRelDefinesByObject(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingObject);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingObject);
    return args;
  }
};
var IfcRelDefinesByProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingPropertyDefinition = RelatingPropertyDefinition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingPropertyDefinition = tape[ptr++];
    return new IfcRelDefinesByProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingPropertyDefinition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingPropertyDefinition);
    return args;
  }
};
var IfcRelDefinesByTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedPropertySets = RelatedPropertySets;
    this.RelatingTemplate = RelatingTemplate;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedPropertySets = tape[ptr++];
    let RelatingTemplate = tape[ptr++];
    return new IfcRelDefinesByTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedPropertySets, RelatingTemplate);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedPropertySets);
    args.push(this.RelatingTemplate);
    return args;
  }
};
var IfcRelDefinesByType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedObjects = RelatedObjects;
    this.RelatingType = RelatingType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    let RelatingType = tape[ptr++];
    return new IfcRelDefinesByType(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedObjects, RelatingType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedObjects);
    args.push(this.RelatingType);
    return args;
  }
};
var IfcRelFillsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingOpeningElement = RelatingOpeningElement;
    this.RelatedBuildingElement = RelatedBuildingElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingOpeningElement = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    return new IfcRelFillsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingOpeningElement, RelatedBuildingElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingOpeningElement);
    args.push(this.RelatedBuildingElement);
    return args;
  }
};
var IfcRelFlowControlElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedControlElements = RelatedControlElements;
    this.RelatingFlowElement = RelatingFlowElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedControlElements = tape[ptr++];
    let RelatingFlowElement = tape[ptr++];
    return new IfcRelFlowControlElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedControlElements, RelatingFlowElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedControlElements);
    args.push(this.RelatingFlowElement);
    return args;
  }
};
var IfcRelInterferesElements = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedElement = RelatedElement;
    this.InterferenceGeometry = InterferenceGeometry;
    this.InterferenceType = InterferenceType;
    this.ImpliedOrder = ImpliedOrder;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedElement = tape[ptr++];
    let InterferenceGeometry = tape[ptr++];
    let InterferenceType = tape[ptr++];
    let ImpliedOrder = tape[ptr++];
    return new IfcRelInterferesElements(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedElement, InterferenceGeometry, InterferenceType, ImpliedOrder);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedElement);
    args.push(this.InterferenceGeometry);
    args.push(this.InterferenceType);
    args.push(this.ImpliedOrder);
    return args;
  }
};
var IfcRelNests = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingObject = RelatingObject;
    this.RelatedObjects = RelatedObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingObject = tape[ptr++];
    let RelatedObjects = tape[ptr++];
    return new IfcRelNests(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingObject, RelatedObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingObject);
    args.push(this.RelatedObjects);
    return args;
  }
};
var IfcRelPositions = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingPositioningElement = RelatingPositioningElement;
    this.RelatedProducts = RelatedProducts;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingPositioningElement = tape[ptr++];
    let RelatedProducts = tape[ptr++];
    return new IfcRelPositions(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingPositioningElement, RelatedProducts);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingPositioningElement);
    args.push(this.RelatedProducts);
    return args;
  }
};
var IfcRelProjectsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingElement = RelatingElement;
    this.RelatedFeatureElement = RelatedFeatureElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingElement = tape[ptr++];
    let RelatedFeatureElement = tape[ptr++];
    return new IfcRelProjectsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingElement, RelatedFeatureElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingElement);
    args.push(this.RelatedFeatureElement);
    return args;
  }
};
var IfcRelReferencedInSpatialStructure = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatedElements = RelatedElements;
    this.RelatingStructure = RelatingStructure;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedElements = tape[ptr++];
    let RelatingStructure = tape[ptr++];
    return new IfcRelReferencedInSpatialStructure(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatedElements, RelatingStructure);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedElements);
    args.push(this.RelatingStructure);
    return args;
  }
};
var IfcRelSequence = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingProcess = RelatingProcess;
    this.RelatedProcess = RelatedProcess;
    this.TimeLag = TimeLag;
    this.SequenceType = SequenceType;
    this.UserDefinedSequenceType = UserDefinedSequenceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingProcess = tape[ptr++];
    let RelatedProcess = tape[ptr++];
    let TimeLag = tape[ptr++];
    let SequenceType = tape[ptr++];
    let UserDefinedSequenceType = tape[ptr++];
    return new IfcRelSequence(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingProcess, RelatedProcess, TimeLag, SequenceType, UserDefinedSequenceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingProcess);
    args.push(this.RelatedProcess);
    args.push(this.TimeLag);
    args.push(this.SequenceType);
    args.push(this.UserDefinedSequenceType);
    return args;
  }
};
var IfcRelServicesBuildings = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSystem = RelatingSystem;
    this.RelatedBuildings = RelatedBuildings;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSystem = tape[ptr++];
    let RelatedBuildings = tape[ptr++];
    return new IfcRelServicesBuildings(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSystem, RelatedBuildings);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSystem);
    args.push(this.RelatedBuildings);
    return args;
  }
};
var IfcRelSpaceBoundary = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    return args;
  }
};
var IfcRelSpaceBoundary1stLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary1stLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    args.push(this.ParentBoundary);
    return args;
  }
};
var IfcRelSpaceBoundary2ndLevel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingSpace = RelatingSpace;
    this.RelatedBuildingElement = RelatedBuildingElement;
    this.ConnectionGeometry = ConnectionGeometry;
    this.PhysicalOrVirtualBoundary = PhysicalOrVirtualBoundary;
    this.InternalOrExternalBoundary = InternalOrExternalBoundary;
    this.ParentBoundary = ParentBoundary;
    this.CorrespondingBoundary = CorrespondingBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingSpace = tape[ptr++];
    let RelatedBuildingElement = tape[ptr++];
    let ConnectionGeometry = tape[ptr++];
    let PhysicalOrVirtualBoundary = tape[ptr++];
    let InternalOrExternalBoundary = tape[ptr++];
    let ParentBoundary = tape[ptr++];
    let CorrespondingBoundary = tape[ptr++];
    return new IfcRelSpaceBoundary2ndLevel(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingSpace, RelatedBuildingElement, ConnectionGeometry, PhysicalOrVirtualBoundary, InternalOrExternalBoundary, ParentBoundary, CorrespondingBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingSpace);
    args.push(this.RelatedBuildingElement);
    args.push(this.ConnectionGeometry);
    args.push(this.PhysicalOrVirtualBoundary);
    args.push(this.InternalOrExternalBoundary);
    args.push(this.ParentBoundary);
    args.push(this.CorrespondingBoundary);
    return args;
  }
};
var IfcRelVoidsElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.RelatingBuildingElement = RelatingBuildingElement;
    this.RelatedOpeningElement = RelatedOpeningElement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingBuildingElement = tape[ptr++];
    let RelatedOpeningElement = tape[ptr++];
    return new IfcRelVoidsElement(expressID, type, GlobalId, OwnerHistory, Name, Description, RelatingBuildingElement, RelatedOpeningElement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingBuildingElement);
    args.push(this.RelatedOpeningElement);
    return args;
  }
};
var IfcRelationship = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRelationship(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcReparametrisedCompositeCurveSegment = class {
  constructor(expressID, type, Transition, SameSense, ParentCurve, ParamLength) {
    this.expressID = expressID;
    this.type = type;
    this.Transition = Transition;
    this.SameSense = SameSense;
    this.ParentCurve = ParentCurve;
    this.ParamLength = ParamLength;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Transition = tape[ptr++];
    let SameSense = tape[ptr++];
    let ParentCurve = tape[ptr++];
    let ParamLength = tape[ptr++];
    return new IfcReparametrisedCompositeCurveSegment(expressID, type, Transition, SameSense, ParentCurve, ParamLength);
  }
  ToTape() {
    let args = [];
    args.push(this.Transition);
    args.push(this.SameSense);
    args.push(this.ParentCurve);
    args.push(this.ParamLength);
    return args;
  }
};
var IfcRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcRepresentationContext = class {
  constructor(expressID, type, ContextIdentifier, ContextType) {
    this.expressID = expressID;
    this.type = type;
    this.ContextIdentifier = ContextIdentifier;
    this.ContextType = ContextType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextIdentifier = tape[ptr++];
    let ContextType = tape[ptr++];
    return new IfcRepresentationContext(expressID, type, ContextIdentifier, ContextType);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextIdentifier);
    args.push(this.ContextType);
    return args;
  }
};
var IfcRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcRepresentationMap = class {
  constructor(expressID, type, MappingOrigin, MappedRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.MappingOrigin = MappingOrigin;
    this.MappedRepresentation = MappedRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let MappingOrigin = tape[ptr++];
    let MappedRepresentation = tape[ptr++];
    return new IfcRepresentationMap(expressID, type, MappingOrigin, MappedRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.MappingOrigin);
    args.push(this.MappedRepresentation);
    return args;
  }
};
var IfcResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    return new IfcResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    return args;
  }
};
var IfcResourceApprovalRelationship = class {
  constructor(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatedResourceObjects = RelatedResourceObjects;
    this.RelatingApproval = RelatingApproval;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    let RelatingApproval = tape[ptr++];
    return new IfcResourceApprovalRelationship(expressID, type, Name, Description, RelatedResourceObjects, RelatingApproval);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatedResourceObjects);
    args.push(this.RelatingApproval);
    return args;
  }
};
var IfcResourceConstraintRelationship = class {
  constructor(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.RelatingConstraint = RelatingConstraint;
    this.RelatedResourceObjects = RelatedResourceObjects;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let RelatingConstraint = tape[ptr++];
    let RelatedResourceObjects = tape[ptr++];
    return new IfcResourceConstraintRelationship(expressID, type, Name, Description, RelatingConstraint, RelatedResourceObjects);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.RelatingConstraint);
    args.push(this.RelatedResourceObjects);
    return args;
  }
};
var IfcResourceLevelRelationship = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcResourceLevelRelationship(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcResourceTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.ScheduleWork = ScheduleWork;
    this.ScheduleUsage = ScheduleUsage;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.ScheduleContour = ScheduleContour;
    this.LevelingDelay = LevelingDelay;
    this.IsOverAllocated = IsOverAllocated;
    this.StatusTime = StatusTime;
    this.ActualWork = ActualWork;
    this.ActualUsage = ActualUsage;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingWork = RemainingWork;
    this.RemainingUsage = RemainingUsage;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let ScheduleWork = tape[ptr++];
    let ScheduleUsage = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let ScheduleContour = tape[ptr++];
    let LevelingDelay = tape[ptr++];
    let IsOverAllocated = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualWork = tape[ptr++];
    let ActualUsage = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingWork = tape[ptr++];
    let RemainingUsage = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcResourceTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, ScheduleWork, ScheduleUsage, ScheduleStart, ScheduleFinish, ScheduleContour, LevelingDelay, IsOverAllocated, StatusTime, ActualWork, ActualUsage, ActualStart, ActualFinish, RemainingWork, RemainingUsage, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.ScheduleWork);
    args.push(this.ScheduleUsage);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.ScheduleContour);
    args.push(this.LevelingDelay);
    args.push(this.IsOverAllocated);
    args.push(this.StatusTime);
    args.push(this.ActualWork);
    args.push(this.ActualUsage);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingWork);
    args.push(this.RemainingUsage);
    args.push(this.Completion);
    return args;
  }
};
var IfcRevolvedAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    return new IfcRevolvedAreaSolid(expressID, type, SweptArea, Position, Axis, Angle);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Axis);
    args.push(this.Angle);
    return args;
  }
};
var IfcRevolvedAreaSolidTapered = class {
  constructor(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Axis = Axis;
    this.Angle = Angle;
    this.EndSweptArea = EndSweptArea;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Axis = tape[ptr++];
    let Angle = tape[ptr++];
    let EndSweptArea = tape[ptr++];
    return new IfcRevolvedAreaSolidTapered(expressID, type, SweptArea, Position, Axis, Angle, EndSweptArea);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Axis);
    args.push(this.Angle);
    args.push(this.EndSweptArea);
    return args;
  }
};
var IfcRightCircularCone = class {
  constructor(expressID, type, Position, Height, BottomRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.BottomRadius = BottomRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let BottomRadius = tape[ptr++];
    return new IfcRightCircularCone(expressID, type, Position, Height, BottomRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Height);
    args.push(this.BottomRadius);
    return args;
  }
};
var IfcRightCircularCylinder = class {
  constructor(expressID, type, Position, Height, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Height = Height;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Height = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcRightCircularCylinder(expressID, type, Position, Height, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Height);
    args.push(this.Radius);
    return args;
  }
};
var IfcRoof = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoof(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRoofType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcRoofType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcRoot = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcRoot(expressID, type, GlobalId, OwnerHistory, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcRoundedRectangleProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.XDim = XDim;
    this.YDim = YDim;
    this.RoundingRadius = RoundingRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let XDim = tape[ptr++];
    let YDim = tape[ptr++];
    let RoundingRadius = tape[ptr++];
    return new IfcRoundedRectangleProfileDef(expressID, type, ProfileType, ProfileName, Position, XDim, YDim, RoundingRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.XDim);
    args.push(this.YDim);
    args.push(this.RoundingRadius);
    return args;
  }
};
var IfcSIUnit = class {
  constructor(expressID, type, Dimensions, UnitType, Prefix, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Dimensions = Dimensions;
    this.UnitType = UnitType;
    this.Prefix = Prefix;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Dimensions = tape[ptr++];
    let UnitType = tape[ptr++];
    let Prefix = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcSIUnit(expressID, type, Dimensions, UnitType, Prefix, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Dimensions);
    args.push(this.UnitType);
    args.push(this.Prefix);
    args.push(this.Name);
    return args;
  }
};
var IfcSanitaryTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSanitaryTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSanitaryTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSchedulingTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    return new IfcSchedulingTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    return args;
  }
};
var IfcSeamCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSeamCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcSectionProperties = class {
  constructor(expressID, type, SectionType, StartProfile, EndProfile) {
    this.expressID = expressID;
    this.type = type;
    this.SectionType = SectionType;
    this.StartProfile = StartProfile;
    this.EndProfile = EndProfile;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SectionType = tape[ptr++];
    let StartProfile = tape[ptr++];
    let EndProfile = tape[ptr++];
    return new IfcSectionProperties(expressID, type, SectionType, StartProfile, EndProfile);
  }
  ToTape() {
    let args = [];
    args.push(this.SectionType);
    args.push(this.StartProfile);
    args.push(this.EndProfile);
    return args;
  }
};
var IfcSectionReinforcementProperties = class {
  constructor(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions) {
    this.expressID = expressID;
    this.type = type;
    this.LongitudinalStartPosition = LongitudinalStartPosition;
    this.LongitudinalEndPosition = LongitudinalEndPosition;
    this.TransversePosition = TransversePosition;
    this.ReinforcementRole = ReinforcementRole;
    this.SectionDefinition = SectionDefinition;
    this.CrossSectionReinforcementDefinitions = CrossSectionReinforcementDefinitions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LongitudinalStartPosition = tape[ptr++];
    let LongitudinalEndPosition = tape[ptr++];
    let TransversePosition = tape[ptr++];
    let ReinforcementRole = tape[ptr++];
    let SectionDefinition = tape[ptr++];
    let CrossSectionReinforcementDefinitions = tape[ptr++];
    return new IfcSectionReinforcementProperties(expressID, type, LongitudinalStartPosition, LongitudinalEndPosition, TransversePosition, ReinforcementRole, SectionDefinition, CrossSectionReinforcementDefinitions);
  }
  ToTape() {
    let args = [];
    args.push(this.LongitudinalStartPosition);
    args.push(this.LongitudinalEndPosition);
    args.push(this.TransversePosition);
    args.push(this.ReinforcementRole);
    args.push(this.SectionDefinition);
    args.push(this.CrossSectionReinforcementDefinitions);
    return args;
  }
};
var IfcSectionedSolid = class {
  constructor(expressID, type, Directrix, CrossSections) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    return new IfcSectionedSolid(expressID, type, Directrix, CrossSections);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.CrossSections);
    return args;
  }
};
var IfcSectionedSolidHorizontal = class {
  constructor(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
    this.FixedAxisVertical = FixedAxisVertical;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    let FixedAxisVertical = tape[ptr++];
    return new IfcSectionedSolidHorizontal(expressID, type, Directrix, CrossSections, CrossSectionPositions, FixedAxisVertical);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.CrossSections);
    args.push(this.CrossSectionPositions);
    args.push(this.FixedAxisVertical);
    return args;
  }
};
var IfcSectionedSpine = class {
  constructor(expressID, type, SpineCurve, CrossSections, CrossSectionPositions) {
    this.expressID = expressID;
    this.type = type;
    this.SpineCurve = SpineCurve;
    this.CrossSections = CrossSections;
    this.CrossSectionPositions = CrossSectionPositions;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SpineCurve = tape[ptr++];
    let CrossSections = tape[ptr++];
    let CrossSectionPositions = tape[ptr++];
    return new IfcSectionedSpine(expressID, type, SpineCurve, CrossSections, CrossSectionPositions);
  }
  ToTape() {
    let args = [];
    args.push(this.SpineCurve);
    args.push(this.CrossSections);
    args.push(this.CrossSectionPositions);
    return args;
  }
};
var IfcSensor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSensorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSensorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShadingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShadingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcShadingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcShapeAspect = class {
  constructor(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape) {
    this.expressID = expressID;
    this.type = type;
    this.ShapeRepresentations = ShapeRepresentations;
    this.Name = Name;
    this.Description = Description;
    this.ProductDefinitional = ProductDefinitional;
    this.PartOfProductDefinitionShape = PartOfProductDefinitionShape;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ShapeRepresentations = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ProductDefinitional = tape[ptr++];
    let PartOfProductDefinitionShape = tape[ptr++];
    return new IfcShapeAspect(expressID, type, ShapeRepresentations, Name, Description, ProductDefinitional, PartOfProductDefinitionShape);
  }
  ToTape() {
    let args = [];
    args.push(this.ShapeRepresentations);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ProductDefinitional);
    args.push(this.PartOfProductDefinitionShape);
    return args;
  }
};
var IfcShapeModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcShapeRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcShapeRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcShellBasedSurfaceModel = class {
  constructor(expressID, type, SbsmBoundary) {
    this.expressID = expressID;
    this.type = type;
    this.SbsmBoundary = SbsmBoundary;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SbsmBoundary = tape[ptr++];
    return new IfcShellBasedSurfaceModel(expressID, type, SbsmBoundary);
  }
  ToTape() {
    let args = [];
    args.push(this.SbsmBoundary);
    return args;
  }
};
var IfcSimpleProperty = class {
  constructor(expressID, type, Name, Description) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    return new IfcSimpleProperty(expressID, type, Name, Description);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    return args;
  }
};
var IfcSimplePropertyTemplate = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.TemplateType = TemplateType;
    this.PrimaryMeasureType = PrimaryMeasureType;
    this.SecondaryMeasureType = SecondaryMeasureType;
    this.Enumerators = Enumerators;
    this.PrimaryUnit = PrimaryUnit;
    this.SecondaryUnit = SecondaryUnit;
    this.Expression = Expression;
    this.AccessState = AccessState;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let TemplateType = tape[ptr++];
    let PrimaryMeasureType = tape[ptr++];
    let SecondaryMeasureType = tape[ptr++];
    let Enumerators = tape[ptr++];
    let PrimaryUnit = tape[ptr++];
    let SecondaryUnit = tape[ptr++];
    let Expression = tape[ptr++];
    let AccessState = tape[ptr++];
    return new IfcSimplePropertyTemplate(expressID, type, GlobalId, OwnerHistory, Name, Description, TemplateType, PrimaryMeasureType, SecondaryMeasureType, Enumerators, PrimaryUnit, SecondaryUnit, Expression, AccessState);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.TemplateType);
    args.push(this.PrimaryMeasureType);
    args.push(this.SecondaryMeasureType);
    args.push(this.Enumerators);
    args.push(this.PrimaryUnit);
    args.push(this.SecondaryUnit);
    args.push(this.Expression);
    args.push(this.AccessState);
    return args;
  }
};
var IfcSite = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.RefLatitude = RefLatitude;
    this.RefLongitude = RefLongitude;
    this.RefElevation = RefElevation;
    this.LandTitleNumber = LandTitleNumber;
    this.SiteAddress = SiteAddress;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let RefLatitude = tape[ptr++];
    let RefLongitude = tape[ptr++];
    let RefElevation = tape[ptr++];
    let LandTitleNumber = tape[ptr++];
    let SiteAddress = tape[ptr++];
    return new IfcSite(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, RefLatitude, RefLongitude, RefElevation, LandTitleNumber, SiteAddress);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.RefLatitude);
    args.push(this.RefLongitude);
    args.push(this.RefElevation);
    args.push(this.LandTitleNumber);
    args.push(this.SiteAddress);
    return args;
  }
};
var IfcSlab = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlab(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlabType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSlabType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSlippageConnectionCondition = class {
  constructor(expressID, type, Name, SlippageX, SlippageY, SlippageZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SlippageX = SlippageX;
    this.SlippageY = SlippageY;
    this.SlippageZ = SlippageZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SlippageX = tape[ptr++];
    let SlippageY = tape[ptr++];
    let SlippageZ = tape[ptr++];
    return new IfcSlippageConnectionCondition(expressID, type, Name, SlippageX, SlippageY, SlippageZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.SlippageX);
    args.push(this.SlippageY);
    args.push(this.SlippageZ);
    return args;
  }
};
var IfcSolarDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSolarDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSolarDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSolidModel = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcSolidModel(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSpace = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
    this.PredefinedType = PredefinedType;
    this.ElevationWithFlooring = ElevationWithFlooring;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ElevationWithFlooring = tape[ptr++];
    return new IfcSpace(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType, PredefinedType, ElevationWithFlooring);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    args.push(this.PredefinedType);
    args.push(this.ElevationWithFlooring);
    return args;
  }
};
var IfcSpaceHeater = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeater(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpaceHeaterType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpaceHeaterType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpaceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpaceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcSpatialElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    return args;
  }
};
var IfcSpatialElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcSpatialStructureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.CompositionType = CompositionType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let CompositionType = tape[ptr++];
    return new IfcSpatialStructureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, CompositionType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.CompositionType);
    return args;
  }
};
var IfcSpatialStructureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    return new IfcSpatialStructureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    return args;
  }
};
var IfcSpatialZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.LongName = LongName;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let LongName = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSpatialZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, LongName, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.LongName);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSpatialZoneType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcSpatialZoneType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.LongName);
    return args;
  }
};
var IfcSphere = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphere(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcSphericalSurface = class {
  constructor(expressID, type, Position, Radius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.Radius = Radius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let Radius = tape[ptr++];
    return new IfcSphericalSurface(expressID, type, Position, Radius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.Radius);
    return args;
  }
};
var IfcStackTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStackTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStackTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStair = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStair(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairFlight = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.NumberOfRisers = NumberOfRisers;
    this.NumberOfTreads = NumberOfTreads;
    this.RiserHeight = RiserHeight;
    this.TreadLength = TreadLength;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let NumberOfRisers = tape[ptr++];
    let NumberOfTreads = tape[ptr++];
    let RiserHeight = tape[ptr++];
    let TreadLength = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlight(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, NumberOfRisers, NumberOfTreads, RiserHeight, TreadLength, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.NumberOfRisers);
    args.push(this.NumberOfTreads);
    args.push(this.RiserHeight);
    args.push(this.TreadLength);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairFlightType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairFlightType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStairType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStairType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    return args;
  }
};
var IfcStructuralActivity = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralActivity(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralAnalysisModel = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.OrientationOf2DPlane = OrientationOf2DPlane;
    this.LoadedBy = LoadedBy;
    this.HasResults = HasResults;
    this.SharedPlacement = SharedPlacement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let OrientationOf2DPlane = tape[ptr++];
    let LoadedBy = tape[ptr++];
    let HasResults = tape[ptr++];
    let SharedPlacement = tape[ptr++];
    return new IfcStructuralAnalysisModel(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, OrientationOf2DPlane, LoadedBy, HasResults, SharedPlacement);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.OrientationOf2DPlane);
    args.push(this.LoadedBy);
    args.push(this.HasResults);
    args.push(this.SharedPlacement);
    return args;
  }
};
var IfcStructuralConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    return args;
  }
};
var IfcStructuralConnectionCondition = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralConnectionCondition(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralCurveAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralCurveConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Axis = Axis;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Axis = tape[ptr++];
    return new IfcStructuralCurveMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Axis);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Axis);
    return args;
  }
};
var IfcStructuralCurveReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralCurveReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralItem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralItem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcStructuralLinearAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralLinearAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralLoad = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoad(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
    this.SelfWeightCoefficients = SelfWeightCoefficients;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    let SelfWeightCoefficients = tape[ptr++];
    return new IfcStructuralLoadCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose, SelfWeightCoefficients);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.ActionType);
    args.push(this.ActionSource);
    args.push(this.Coefficient);
    args.push(this.Purpose);
    args.push(this.SelfWeightCoefficients);
    return args;
  }
};
var IfcStructuralLoadConfiguration = class {
  constructor(expressID, type, Name, Values, Locations) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Values = Values;
    this.Locations = Locations;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Values = tape[ptr++];
    let Locations = tape[ptr++];
    return new IfcStructuralLoadConfiguration(expressID, type, Name, Values, Locations);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Values);
    args.push(this.Locations);
    return args;
  }
};
var IfcStructuralLoadGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.PredefinedType = PredefinedType;
    this.ActionType = ActionType;
    this.ActionSource = ActionSource;
    this.Coefficient = Coefficient;
    this.Purpose = Purpose;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let ActionType = tape[ptr++];
    let ActionSource = tape[ptr++];
    let Coefficient = tape[ptr++];
    let Purpose = tape[ptr++];
    return new IfcStructuralLoadGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, PredefinedType, ActionType, ActionSource, Coefficient, Purpose);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.PredefinedType);
    args.push(this.ActionType);
    args.push(this.ActionSource);
    args.push(this.Coefficient);
    args.push(this.Purpose);
    return args;
  }
};
var IfcStructuralLoadLinearForce = class {
  constructor(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.LinearForceX = LinearForceX;
    this.LinearForceY = LinearForceY;
    this.LinearForceZ = LinearForceZ;
    this.LinearMomentX = LinearMomentX;
    this.LinearMomentY = LinearMomentY;
    this.LinearMomentZ = LinearMomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let LinearForceX = tape[ptr++];
    let LinearForceY = tape[ptr++];
    let LinearForceZ = tape[ptr++];
    let LinearMomentX = tape[ptr++];
    let LinearMomentY = tape[ptr++];
    let LinearMomentZ = tape[ptr++];
    return new IfcStructuralLoadLinearForce(expressID, type, Name, LinearForceX, LinearForceY, LinearForceZ, LinearMomentX, LinearMomentY, LinearMomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.LinearForceX);
    args.push(this.LinearForceY);
    args.push(this.LinearForceZ);
    args.push(this.LinearMomentX);
    args.push(this.LinearMomentY);
    args.push(this.LinearMomentZ);
    return args;
  }
};
var IfcStructuralLoadOrResult = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadOrResult(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadPlanarForce = class {
  constructor(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.PlanarForceX = PlanarForceX;
    this.PlanarForceY = PlanarForceY;
    this.PlanarForceZ = PlanarForceZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let PlanarForceX = tape[ptr++];
    let PlanarForceY = tape[ptr++];
    let PlanarForceZ = tape[ptr++];
    return new IfcStructuralLoadPlanarForce(expressID, type, Name, PlanarForceX, PlanarForceY, PlanarForceZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.PlanarForceX);
    args.push(this.PlanarForceY);
    args.push(this.PlanarForceZ);
    return args;
  }
};
var IfcStructuralLoadSingleDisplacement = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacement(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DisplacementX);
    args.push(this.DisplacementY);
    args.push(this.DisplacementZ);
    args.push(this.RotationalDisplacementRX);
    args.push(this.RotationalDisplacementRY);
    args.push(this.RotationalDisplacementRZ);
    return args;
  }
};
var IfcStructuralLoadSingleDisplacementDistortion = class {
  constructor(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DisplacementX = DisplacementX;
    this.DisplacementY = DisplacementY;
    this.DisplacementZ = DisplacementZ;
    this.RotationalDisplacementRX = RotationalDisplacementRX;
    this.RotationalDisplacementRY = RotationalDisplacementRY;
    this.RotationalDisplacementRZ = RotationalDisplacementRZ;
    this.Distortion = Distortion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DisplacementX = tape[ptr++];
    let DisplacementY = tape[ptr++];
    let DisplacementZ = tape[ptr++];
    let RotationalDisplacementRX = tape[ptr++];
    let RotationalDisplacementRY = tape[ptr++];
    let RotationalDisplacementRZ = tape[ptr++];
    let Distortion = tape[ptr++];
    return new IfcStructuralLoadSingleDisplacementDistortion(expressID, type, Name, DisplacementX, DisplacementY, DisplacementZ, RotationalDisplacementRX, RotationalDisplacementRY, RotationalDisplacementRZ, Distortion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DisplacementX);
    args.push(this.DisplacementY);
    args.push(this.DisplacementZ);
    args.push(this.RotationalDisplacementRX);
    args.push(this.RotationalDisplacementRY);
    args.push(this.RotationalDisplacementRZ);
    args.push(this.Distortion);
    return args;
  }
};
var IfcStructuralLoadSingleForce = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    return new IfcStructuralLoadSingleForce(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.ForceX);
    args.push(this.ForceY);
    args.push(this.ForceZ);
    args.push(this.MomentX);
    args.push(this.MomentY);
    args.push(this.MomentZ);
    return args;
  }
};
var IfcStructuralLoadSingleForceWarping = class {
  constructor(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.ForceX = ForceX;
    this.ForceY = ForceY;
    this.ForceZ = ForceZ;
    this.MomentX = MomentX;
    this.MomentY = MomentY;
    this.MomentZ = MomentZ;
    this.WarpingMoment = WarpingMoment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let ForceX = tape[ptr++];
    let ForceY = tape[ptr++];
    let ForceZ = tape[ptr++];
    let MomentX = tape[ptr++];
    let MomentY = tape[ptr++];
    let MomentZ = tape[ptr++];
    let WarpingMoment = tape[ptr++];
    return new IfcStructuralLoadSingleForceWarping(expressID, type, Name, ForceX, ForceY, ForceZ, MomentX, MomentY, MomentZ, WarpingMoment);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.ForceX);
    args.push(this.ForceY);
    args.push(this.ForceZ);
    args.push(this.MomentX);
    args.push(this.MomentY);
    args.push(this.MomentZ);
    args.push(this.WarpingMoment);
    return args;
  }
};
var IfcStructuralLoadStatic = class {
  constructor(expressID, type, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    return new IfcStructuralLoadStatic(expressID, type, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    return args;
  }
};
var IfcStructuralLoadTemperature = class {
  constructor(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DeltaTConstant = DeltaTConstant;
    this.DeltaTY = DeltaTY;
    this.DeltaTZ = DeltaTZ;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DeltaTConstant = tape[ptr++];
    let DeltaTY = tape[ptr++];
    let DeltaTZ = tape[ptr++];
    return new IfcStructuralLoadTemperature(expressID, type, Name, DeltaTConstant, DeltaTY, DeltaTZ);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DeltaTConstant);
    args.push(this.DeltaTY);
    args.push(this.DeltaTZ);
    return args;
  }
};
var IfcStructuralMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    return new IfcStructuralMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    return args;
  }
};
var IfcStructuralPlanarAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralPlanarAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralPointAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    return new IfcStructuralPointAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    return args;
  }
};
var IfcStructuralPointConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
    this.ConditionCoordinateSystem = ConditionCoordinateSystem;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    let ConditionCoordinateSystem = tape[ptr++];
    return new IfcStructuralPointConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition, ConditionCoordinateSystem);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    args.push(this.ConditionCoordinateSystem);
    return args;
  }
};
var IfcStructuralPointReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralPointReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    return new IfcStructuralReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    return args;
  }
};
var IfcStructuralResultGroup = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.TheoryType = TheoryType;
    this.ResultForLoadGroup = ResultForLoadGroup;
    this.IsLinear = IsLinear;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let TheoryType = tape[ptr++];
    let ResultForLoadGroup = tape[ptr++];
    let IsLinear = tape[ptr++];
    return new IfcStructuralResultGroup(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, TheoryType, ResultForLoadGroup, IsLinear);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.TheoryType);
    args.push(this.ResultForLoadGroup);
    args.push(this.IsLinear);
    return args;
  }
};
var IfcStructuralSurfaceAction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.DestabilizingLoad = DestabilizingLoad;
    this.ProjectedOrTrue = ProjectedOrTrue;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let DestabilizingLoad = tape[ptr++];
    let ProjectedOrTrue = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceAction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, DestabilizingLoad, ProjectedOrTrue, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.DestabilizingLoad);
    args.push(this.ProjectedOrTrue);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStructuralSurfaceConnection = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedCondition = AppliedCondition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedCondition = tape[ptr++];
    return new IfcStructuralSurfaceConnection(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedCondition);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedCondition);
    return args;
  }
};
var IfcStructuralSurfaceMember = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMember(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Thickness);
    return args;
  }
};
var IfcStructuralSurfaceMemberVarying = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.PredefinedType = PredefinedType;
    this.Thickness = Thickness;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let Thickness = tape[ptr++];
    return new IfcStructuralSurfaceMemberVarying(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, PredefinedType, Thickness);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.PredefinedType);
    args.push(this.Thickness);
    return args;
  }
};
var IfcStructuralSurfaceReaction = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.AppliedLoad = AppliedLoad;
    this.GlobalOrLocal = GlobalOrLocal;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let AppliedLoad = tape[ptr++];
    let GlobalOrLocal = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcStructuralSurfaceReaction(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, AppliedLoad, GlobalOrLocal, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.AppliedLoad);
    args.push(this.GlobalOrLocal);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcStyleModel = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyleModel(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcStyledItem = class {
  constructor(expressID, type, Item, Styles, Name) {
    this.expressID = expressID;
    this.type = type;
    this.Item = Item;
    this.Styles = Styles;
    this.Name = Name;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Item = tape[ptr++];
    let Styles = tape[ptr++];
    let Name = tape[ptr++];
    return new IfcStyledItem(expressID, type, Item, Styles, Name);
  }
  ToTape() {
    let args = [];
    args.push(this.Item);
    args.push(this.Styles);
    args.push(this.Name);
    return args;
  }
};
var IfcStyledRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcStyledRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcSubContractResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Usage = Usage;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Usage = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Usage, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Usage);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSubContractResourceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
    this.BaseCosts = BaseCosts;
    this.BaseQuantity = BaseQuantity;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    let BaseCosts = tape[ptr++];
    let BaseQuantity = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSubContractResourceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType, BaseCosts, BaseQuantity, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    args.push(this.BaseCosts);
    args.push(this.BaseQuantity);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSubedge = class {
  constructor(expressID, type, EdgeStart, EdgeEnd, ParentEdge) {
    this.expressID = expressID;
    this.type = type;
    this.EdgeStart = EdgeStart;
    this.EdgeEnd = EdgeEnd;
    this.ParentEdge = ParentEdge;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let EdgeStart = tape[ptr++];
    let EdgeEnd = tape[ptr++];
    let ParentEdge = tape[ptr++];
    return new IfcSubedge(expressID, type, EdgeStart, EdgeEnd, ParentEdge);
  }
  ToTape() {
    let args = [];
    args.push(this.EdgeStart);
    args.push(this.EdgeEnd);
    args.push(this.ParentEdge);
    return args;
  }
};
var IfcSurface = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcSurface(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcSurfaceCurve = class {
  constructor(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.Curve3D = Curve3D;
    this.AssociatedGeometry = AssociatedGeometry;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Curve3D = tape[ptr++];
    let AssociatedGeometry = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcSurfaceCurve(expressID, type, Curve3D, AssociatedGeometry, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.Curve3D);
    args.push(this.AssociatedGeometry);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcSurfaceCurveSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
    this.Directrix = Directrix;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.ReferenceSurface = ReferenceSurface;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    let Directrix = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let ReferenceSurface = tape[ptr++];
    return new IfcSurfaceCurveSweptAreaSolid(expressID, type, SweptArea, Position, Directrix, StartParam, EndParam, ReferenceSurface);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    args.push(this.Directrix);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.ReferenceSurface);
    return args;
  }
};
var IfcSurfaceFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSurfaceFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSurfaceOfLinearExtrusion = class {
  constructor(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.ExtrudedDirection = ExtrudedDirection;
    this.Depth = Depth;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let ExtrudedDirection = tape[ptr++];
    let Depth = tape[ptr++];
    return new IfcSurfaceOfLinearExtrusion(expressID, type, SweptCurve, Position, ExtrudedDirection, Depth);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    args.push(this.ExtrudedDirection);
    args.push(this.Depth);
    return args;
  }
};
var IfcSurfaceOfRevolution = class {
  constructor(expressID, type, SweptCurve, Position, AxisPosition) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
    this.AxisPosition = AxisPosition;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    let AxisPosition = tape[ptr++];
    return new IfcSurfaceOfRevolution(expressID, type, SweptCurve, Position, AxisPosition);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    args.push(this.AxisPosition);
    return args;
  }
};
var IfcSurfaceReinforcementArea = class {
  constructor(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.SurfaceReinforcement1 = SurfaceReinforcement1;
    this.SurfaceReinforcement2 = SurfaceReinforcement2;
    this.ShearReinforcement = ShearReinforcement;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let SurfaceReinforcement1 = tape[ptr++];
    let SurfaceReinforcement2 = tape[ptr++];
    let ShearReinforcement = tape[ptr++];
    return new IfcSurfaceReinforcementArea(expressID, type, Name, SurfaceReinforcement1, SurfaceReinforcement2, ShearReinforcement);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.SurfaceReinforcement1);
    args.push(this.SurfaceReinforcement2);
    args.push(this.ShearReinforcement);
    return args;
  }
};
var IfcSurfaceStyle = class {
  constructor(expressID, type, Name, Side, Styles) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Side = Side;
    this.Styles = Styles;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Side = tape[ptr++];
    let Styles = tape[ptr++];
    return new IfcSurfaceStyle(expressID, type, Name, Side, Styles);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Side);
    args.push(this.Styles);
    return args;
  }
};
var IfcSurfaceStyleLighting = class {
  constructor(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour) {
    this.expressID = expressID;
    this.type = type;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.DiffuseReflectionColour = DiffuseReflectionColour;
    this.TransmissionColour = TransmissionColour;
    this.ReflectanceColour = ReflectanceColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let DiffuseTransmissionColour = tape[ptr++];
    let DiffuseReflectionColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let ReflectanceColour = tape[ptr++];
    return new IfcSurfaceStyleLighting(expressID, type, DiffuseTransmissionColour, DiffuseReflectionColour, TransmissionColour, ReflectanceColour);
  }
  ToTape() {
    let args = [];
    args.push(this.DiffuseTransmissionColour);
    args.push(this.DiffuseReflectionColour);
    args.push(this.TransmissionColour);
    args.push(this.ReflectanceColour);
    return args;
  }
};
var IfcSurfaceStyleRefraction = class {
  constructor(expressID, type, RefractionIndex, DispersionFactor) {
    this.expressID = expressID;
    this.type = type;
    this.RefractionIndex = RefractionIndex;
    this.DispersionFactor = DispersionFactor;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RefractionIndex = tape[ptr++];
    let DispersionFactor = tape[ptr++];
    return new IfcSurfaceStyleRefraction(expressID, type, RefractionIndex, DispersionFactor);
  }
  ToTape() {
    let args = [];
    args.push(this.RefractionIndex);
    args.push(this.DispersionFactor);
    return args;
  }
};
var IfcSurfaceStyleRendering = class {
  constructor(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
    this.DiffuseColour = DiffuseColour;
    this.TransmissionColour = TransmissionColour;
    this.DiffuseTransmissionColour = DiffuseTransmissionColour;
    this.ReflectionColour = ReflectionColour;
    this.SpecularColour = SpecularColour;
    this.SpecularHighlight = SpecularHighlight;
    this.ReflectanceMethod = ReflectanceMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    let DiffuseColour = tape[ptr++];
    let TransmissionColour = tape[ptr++];
    let DiffuseTransmissionColour = tape[ptr++];
    let ReflectionColour = tape[ptr++];
    let SpecularColour = tape[ptr++];
    let SpecularHighlight = tape[ptr++];
    let ReflectanceMethod = tape[ptr++];
    return new IfcSurfaceStyleRendering(expressID, type, SurfaceColour, Transparency, DiffuseColour, TransmissionColour, DiffuseTransmissionColour, ReflectionColour, SpecularColour, SpecularHighlight, ReflectanceMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    args.push(this.Transparency);
    args.push(this.DiffuseColour);
    args.push(this.TransmissionColour);
    args.push(this.DiffuseTransmissionColour);
    args.push(this.ReflectionColour);
    args.push(this.SpecularColour);
    args.push(this.SpecularHighlight);
    args.push(this.ReflectanceMethod);
    return args;
  }
};
var IfcSurfaceStyleShading = class {
  constructor(expressID, type, SurfaceColour, Transparency) {
    this.expressID = expressID;
    this.type = type;
    this.SurfaceColour = SurfaceColour;
    this.Transparency = Transparency;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SurfaceColour = tape[ptr++];
    let Transparency = tape[ptr++];
    return new IfcSurfaceStyleShading(expressID, type, SurfaceColour, Transparency);
  }
  ToTape() {
    let args = [];
    args.push(this.SurfaceColour);
    args.push(this.Transparency);
    return args;
  }
};
var IfcSurfaceStyleWithTextures = class {
  constructor(expressID, type, Textures) {
    this.expressID = expressID;
    this.type = type;
    this.Textures = Textures;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Textures = tape[ptr++];
    return new IfcSurfaceStyleWithTextures(expressID, type, Textures);
  }
  ToTape() {
    let args = [];
    args.push(this.Textures);
    return args;
  }
};
var IfcSurfaceTexture = class {
  constructor(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.RepeatS = RepeatS;
    this.RepeatT = RepeatT;
    this.Mode = Mode;
    this.TextureTransform = TextureTransform;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RepeatS = tape[ptr++];
    let RepeatT = tape[ptr++];
    let Mode = tape[ptr++];
    let TextureTransform = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcSurfaceTexture(expressID, type, RepeatS, RepeatT, Mode, TextureTransform, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.RepeatS);
    args.push(this.RepeatT);
    args.push(this.Mode);
    args.push(this.TextureTransform);
    args.push(this.Parameter);
    return args;
  }
};
var IfcSweptAreaSolid = class {
  constructor(expressID, type, SweptArea, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptArea = SweptArea;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptArea = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptAreaSolid(expressID, type, SweptArea, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptArea);
    args.push(this.Position);
    return args;
  }
};
var IfcSweptDiskSolid = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    return new IfcSweptDiskSolid(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.Radius);
    args.push(this.InnerRadius);
    args.push(this.StartParam);
    args.push(this.EndParam);
    return args;
  }
};
var IfcSweptDiskSolidPolygonal = class {
  constructor(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Directrix = Directrix;
    this.Radius = Radius;
    this.InnerRadius = InnerRadius;
    this.StartParam = StartParam;
    this.EndParam = EndParam;
    this.FilletRadius = FilletRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Directrix = tape[ptr++];
    let Radius = tape[ptr++];
    let InnerRadius = tape[ptr++];
    let StartParam = tape[ptr++];
    let EndParam = tape[ptr++];
    let FilletRadius = tape[ptr++];
    return new IfcSweptDiskSolidPolygonal(expressID, type, Directrix, Radius, InnerRadius, StartParam, EndParam, FilletRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Directrix);
    args.push(this.Radius);
    args.push(this.InnerRadius);
    args.push(this.StartParam);
    args.push(this.EndParam);
    args.push(this.FilletRadius);
    return args;
  }
};
var IfcSweptSurface = class {
  constructor(expressID, type, SweptCurve, Position) {
    this.expressID = expressID;
    this.type = type;
    this.SweptCurve = SweptCurve;
    this.Position = Position;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let SweptCurve = tape[ptr++];
    let Position = tape[ptr++];
    return new IfcSweptSurface(expressID, type, SweptCurve, Position);
  }
  ToTape() {
    let args = [];
    args.push(this.SweptCurve);
    args.push(this.Position);
    return args;
  }
};
var IfcSwitchingDevice = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDevice(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSwitchingDeviceType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSwitchingDeviceType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSystem = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    return new IfcSystem(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    return args;
  }
};
var IfcSystemFurnitureElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcSystemFurnitureElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcSystemFurnitureElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.FlangeEdgeRadius = FlangeEdgeRadius;
    this.WebEdgeRadius = WebEdgeRadius;
    this.WebSlope = WebSlope;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let FlangeEdgeRadius = tape[ptr++];
    let WebEdgeRadius = tape[ptr++];
    let WebSlope = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcTShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, FlangeEdgeRadius, WebEdgeRadius, WebSlope, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.FlangeEdgeRadius);
    args.push(this.WebEdgeRadius);
    args.push(this.WebSlope);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcTable = class {
  constructor(expressID, type, Name, Rows, Columns) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Rows = Rows;
    this.Columns = Columns;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Rows = tape[ptr++];
    let Columns = tape[ptr++];
    return new IfcTable(expressID, type, Name, Rows, Columns);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Rows);
    args.push(this.Columns);
    return args;
  }
};
var IfcTableColumn = class {
  constructor(expressID, type, Identifier, Name, Description, Unit, ReferencePath) {
    this.expressID = expressID;
    this.type = type;
    this.Identifier = Identifier;
    this.Name = Name;
    this.Description = Description;
    this.Unit = Unit;
    this.ReferencePath = ReferencePath;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Identifier = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let Unit = tape[ptr++];
    let ReferencePath = tape[ptr++];
    return new IfcTableColumn(expressID, type, Identifier, Name, Description, Unit, ReferencePath);
  }
  ToTape() {
    let args = [];
    args.push(this.Identifier);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.Unit);
    args.push(this.ReferencePath);
    return args;
  }
};
var IfcTableRow = class {
  constructor(expressID, type, RowCells, IsHeading) {
    this.expressID = expressID;
    this.type = type;
    this.RowCells = RowCells;
    this.IsHeading = IsHeading;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let RowCells = tape[ptr++];
    let IsHeading = tape[ptr++];
    return new IfcTableRow(expressID, type, RowCells, IsHeading);
  }
  ToTape() {
    let args = [];
    args.push(this.RowCells);
    args.push(this.IsHeading);
    return args;
  }
};
var IfcTank = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTank(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTankType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTankType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTask = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.Status = Status;
    this.WorkMethod = WorkMethod;
    this.IsMilestone = IsMilestone;
    this.Priority = Priority;
    this.TaskTime = TaskTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let Status = tape[ptr++];
    let WorkMethod = tape[ptr++];
    let IsMilestone = tape[ptr++];
    let Priority = tape[ptr++];
    let TaskTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTask(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, LongDescription, Status, WorkMethod, IsMilestone, Priority, TaskTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.Status);
    args.push(this.WorkMethod);
    args.push(this.IsMilestone);
    args.push(this.Priority);
    args.push(this.TaskTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTaskTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    return new IfcTaskTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.DurationType);
    args.push(this.ScheduleDuration);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.EarlyStart);
    args.push(this.EarlyFinish);
    args.push(this.LateStart);
    args.push(this.LateFinish);
    args.push(this.FreeFloat);
    args.push(this.TotalFloat);
    args.push(this.IsCritical);
    args.push(this.StatusTime);
    args.push(this.ActualDuration);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingTime);
    args.push(this.Completion);
    return args;
  }
};
var IfcTaskTimeRecurring = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.DurationType = DurationType;
    this.ScheduleDuration = ScheduleDuration;
    this.ScheduleStart = ScheduleStart;
    this.ScheduleFinish = ScheduleFinish;
    this.EarlyStart = EarlyStart;
    this.EarlyFinish = EarlyFinish;
    this.LateStart = LateStart;
    this.LateFinish = LateFinish;
    this.FreeFloat = FreeFloat;
    this.TotalFloat = TotalFloat;
    this.IsCritical = IsCritical;
    this.StatusTime = StatusTime;
    this.ActualDuration = ActualDuration;
    this.ActualStart = ActualStart;
    this.ActualFinish = ActualFinish;
    this.RemainingTime = RemainingTime;
    this.Completion = Completion;
    this.Recurrence = Recurrence;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let DurationType = tape[ptr++];
    let ScheduleDuration = tape[ptr++];
    let ScheduleStart = tape[ptr++];
    let ScheduleFinish = tape[ptr++];
    let EarlyStart = tape[ptr++];
    let EarlyFinish = tape[ptr++];
    let LateStart = tape[ptr++];
    let LateFinish = tape[ptr++];
    let FreeFloat = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let IsCritical = tape[ptr++];
    let StatusTime = tape[ptr++];
    let ActualDuration = tape[ptr++];
    let ActualStart = tape[ptr++];
    let ActualFinish = tape[ptr++];
    let RemainingTime = tape[ptr++];
    let Completion = tape[ptr++];
    let Recurrence = tape[ptr++];
    return new IfcTaskTimeRecurring(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, DurationType, ScheduleDuration, ScheduleStart, ScheduleFinish, EarlyStart, EarlyFinish, LateStart, LateFinish, FreeFloat, TotalFloat, IsCritical, StatusTime, ActualDuration, ActualStart, ActualFinish, RemainingTime, Completion, Recurrence);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.DurationType);
    args.push(this.ScheduleDuration);
    args.push(this.ScheduleStart);
    args.push(this.ScheduleFinish);
    args.push(this.EarlyStart);
    args.push(this.EarlyFinish);
    args.push(this.LateStart);
    args.push(this.LateFinish);
    args.push(this.FreeFloat);
    args.push(this.TotalFloat);
    args.push(this.IsCritical);
    args.push(this.StatusTime);
    args.push(this.ActualDuration);
    args.push(this.ActualStart);
    args.push(this.ActualFinish);
    args.push(this.RemainingTime);
    args.push(this.Completion);
    args.push(this.Recurrence);
    return args;
  }
};
var IfcTaskType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
    this.PredefinedType = PredefinedType;
    this.WorkMethod = WorkMethod;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let WorkMethod = tape[ptr++];
    return new IfcTaskType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType, PredefinedType, WorkMethod);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    args.push(this.PredefinedType);
    args.push(this.WorkMethod);
    return args;
  }
};
var IfcTelecomAddress = class {
  constructor(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs) {
    this.expressID = expressID;
    this.type = type;
    this.Purpose = Purpose;
    this.Description = Description;
    this.UserDefinedPurpose = UserDefinedPurpose;
    this.TelephoneNumbers = TelephoneNumbers;
    this.FacsimileNumbers = FacsimileNumbers;
    this.PagerNumber = PagerNumber;
    this.ElectronicMailAddresses = ElectronicMailAddresses;
    this.WWWHomePageURL = WWWHomePageURL;
    this.MessagingIDs = MessagingIDs;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Purpose = tape[ptr++];
    let Description = tape[ptr++];
    let UserDefinedPurpose = tape[ptr++];
    let TelephoneNumbers = tape[ptr++];
    let FacsimileNumbers = tape[ptr++];
    let PagerNumber = tape[ptr++];
    let ElectronicMailAddresses = tape[ptr++];
    let WWWHomePageURL = tape[ptr++];
    let MessagingIDs = tape[ptr++];
    return new IfcTelecomAddress(expressID, type, Purpose, Description, UserDefinedPurpose, TelephoneNumbers, FacsimileNumbers, PagerNumber, ElectronicMailAddresses, WWWHomePageURL, MessagingIDs);
  }
  ToTape() {
    let args = [];
    args.push(this.Purpose);
    args.push(this.Description);
    args.push(this.UserDefinedPurpose);
    args.push(this.TelephoneNumbers);
    args.push(this.FacsimileNumbers);
    args.push(this.PagerNumber);
    args.push(this.ElectronicMailAddresses);
    args.push(this.WWWHomePageURL);
    args.push(this.MessagingIDs);
    return args;
  }
};
var IfcTendon = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.TensionForce = TensionForce;
    this.PreStress = PreStress;
    this.FrictionCoefficient = FrictionCoefficient;
    this.AnchorageSlip = AnchorageSlip;
    this.MinCurvatureRadius = MinCurvatureRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let TensionForce = tape[ptr++];
    let PreStress = tape[ptr++];
    let FrictionCoefficient = tape[ptr++];
    let AnchorageSlip = tape[ptr++];
    let MinCurvatureRadius = tape[ptr++];
    return new IfcTendon(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType, NominalDiameter, CrossSectionArea, TensionForce, PreStress, FrictionCoefficient, AnchorageSlip, MinCurvatureRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.TensionForce);
    args.push(this.PreStress);
    args.push(this.FrictionCoefficient);
    args.push(this.AnchorageSlip);
    args.push(this.MinCurvatureRadius);
    return args;
  }
};
var IfcTendonAnchor = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonAnchorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonAnchorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonConduit = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.SteelGrade = SteelGrade;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let SteelGrade = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduit(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, SteelGrade, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.SteelGrade);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonConduitType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTendonConduitType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTendonType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.NominalDiameter = NominalDiameter;
    this.CrossSectionArea = CrossSectionArea;
    this.SheathDiameter = SheathDiameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let NominalDiameter = tape[ptr++];
    let CrossSectionArea = tape[ptr++];
    let SheathDiameter = tape[ptr++];
    return new IfcTendonType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, NominalDiameter, CrossSectionArea, SheathDiameter);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.NominalDiameter);
    args.push(this.CrossSectionArea);
    args.push(this.SheathDiameter);
    return args;
  }
};
var IfcTessellatedFaceSet = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTessellatedFaceSet(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcTessellatedItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcTessellatedItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTextLiteral = class {
  constructor(expressID, type, Literal, Placement, Path) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    return new IfcTextLiteral(expressID, type, Literal, Placement, Path);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    args.push(this.Placement);
    args.push(this.Path);
    return args;
  }
};
var IfcTextLiteralWithExtent = class {
  constructor(expressID, type, Literal, Placement, Path, Extent, BoxAlignment) {
    this.expressID = expressID;
    this.type = type;
    this.Literal = Literal;
    this.Placement = Placement;
    this.Path = Path;
    this.Extent = Extent;
    this.BoxAlignment = BoxAlignment;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Literal = tape[ptr++];
    let Placement = tape[ptr++];
    let Path = tape[ptr++];
    let Extent = tape[ptr++];
    let BoxAlignment = tape[ptr++];
    return new IfcTextLiteralWithExtent(expressID, type, Literal, Placement, Path, Extent, BoxAlignment);
  }
  ToTape() {
    let args = [];
    args.push(this.Literal);
    args.push(this.Placement);
    args.push(this.Path);
    args.push(this.Extent);
    args.push(this.BoxAlignment);
    return args;
  }
};
var IfcTextStyle = class {
  constructor(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.TextCharacterAppearance = TextCharacterAppearance;
    this.TextStyle = TextStyle;
    this.TextFontStyle = TextFontStyle;
    this.ModelOrDraughting = ModelOrDraughting;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let TextCharacterAppearance = tape[ptr++];
    let TextStyle = tape[ptr++];
    let TextFontStyle = tape[ptr++];
    let ModelOrDraughting = tape[ptr++];
    return new IfcTextStyle(expressID, type, Name, TextCharacterAppearance, TextStyle, TextFontStyle, ModelOrDraughting);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.TextCharacterAppearance);
    args.push(this.TextStyle);
    args.push(this.TextFontStyle);
    args.push(this.ModelOrDraughting);
    return args;
  }
};
var IfcTextStyleFontModel = class {
  constructor(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.FontFamily = FontFamily;
    this.FontStyle = FontStyle;
    this.FontVariant = FontVariant;
    this.FontWeight = FontWeight;
    this.FontSize = FontSize;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let FontFamily = tape[ptr++];
    let FontStyle = tape[ptr++];
    let FontVariant = tape[ptr++];
    let FontWeight = tape[ptr++];
    let FontSize = tape[ptr++];
    return new IfcTextStyleFontModel(expressID, type, Name, FontFamily, FontStyle, FontVariant, FontWeight, FontSize);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.FontFamily);
    args.push(this.FontStyle);
    args.push(this.FontVariant);
    args.push(this.FontWeight);
    args.push(this.FontSize);
    return args;
  }
};
var IfcTextStyleForDefinedFont = class {
  constructor(expressID, type, Colour, BackgroundColour) {
    this.expressID = expressID;
    this.type = type;
    this.Colour = Colour;
    this.BackgroundColour = BackgroundColour;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Colour = tape[ptr++];
    let BackgroundColour = tape[ptr++];
    return new IfcTextStyleForDefinedFont(expressID, type, Colour, BackgroundColour);
  }
  ToTape() {
    let args = [];
    args.push(this.Colour);
    args.push(this.BackgroundColour);
    return args;
  }
};
var IfcTextStyleTextModel = class {
  constructor(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight) {
    this.expressID = expressID;
    this.type = type;
    this.TextIndent = TextIndent;
    this.TextAlign = TextAlign;
    this.TextDecoration = TextDecoration;
    this.LetterSpacing = LetterSpacing;
    this.WordSpacing = WordSpacing;
    this.TextTransform = TextTransform;
    this.LineHeight = LineHeight;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TextIndent = tape[ptr++];
    let TextAlign = tape[ptr++];
    let TextDecoration = tape[ptr++];
    let LetterSpacing = tape[ptr++];
    let WordSpacing = tape[ptr++];
    let TextTransform = tape[ptr++];
    let LineHeight = tape[ptr++];
    return new IfcTextStyleTextModel(expressID, type, TextIndent, TextAlign, TextDecoration, LetterSpacing, WordSpacing, TextTransform, LineHeight);
  }
  ToTape() {
    let args = [];
    args.push(this.TextIndent);
    args.push(this.TextAlign);
    args.push(this.TextDecoration);
    args.push(this.LetterSpacing);
    args.push(this.WordSpacing);
    args.push(this.TextTransform);
    args.push(this.LineHeight);
    return args;
  }
};
var IfcTextureCoordinate = class {
  constructor(expressID, type, Maps) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    return new IfcTextureCoordinate(expressID, type, Maps);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    return args;
  }
};
var IfcTextureCoordinateGenerator = class {
  constructor(expressID, type, Maps, Mode, Parameter) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Mode = Mode;
    this.Parameter = Parameter;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Mode = tape[ptr++];
    let Parameter = tape[ptr++];
    return new IfcTextureCoordinateGenerator(expressID, type, Maps, Mode, Parameter);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.Mode);
    args.push(this.Parameter);
    return args;
  }
};
var IfcTextureMap = class {
  constructor(expressID, type, Maps, Vertices, MappedTo) {
    this.expressID = expressID;
    this.type = type;
    this.Maps = Maps;
    this.Vertices = Vertices;
    this.MappedTo = MappedTo;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Maps = tape[ptr++];
    let Vertices = tape[ptr++];
    let MappedTo = tape[ptr++];
    return new IfcTextureMap(expressID, type, Maps, Vertices, MappedTo);
  }
  ToTape() {
    let args = [];
    args.push(this.Maps);
    args.push(this.Vertices);
    args.push(this.MappedTo);
    return args;
  }
};
var IfcTextureVertex = class {
  constructor(expressID, type, Coordinates) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    return new IfcTextureVertex(expressID, type, Coordinates);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    return args;
  }
};
var IfcTextureVertexList = class {
  constructor(expressID, type, TexCoordsList) {
    this.expressID = expressID;
    this.type = type;
    this.TexCoordsList = TexCoordsList;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let TexCoordsList = tape[ptr++];
    return new IfcTextureVertexList(expressID, type, TexCoordsList);
  }
  ToTape() {
    let args = [];
    args.push(this.TexCoordsList);
    return args;
  }
};
var IfcTimePeriod = class {
  constructor(expressID, type, StartTime, EndTime) {
    this.expressID = expressID;
    this.type = type;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    return new IfcTimePeriod(expressID, type, StartTime, EndTime);
  }
  ToTape() {
    let args = [];
    args.push(this.StartTime);
    args.push(this.EndTime);
    return args;
  }
};
var IfcTimeSeries = class {
  constructor(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.Description = Description;
    this.StartTime = StartTime;
    this.EndTime = EndTime;
    this.TimeSeriesDataType = TimeSeriesDataType;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.Unit = Unit;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let StartTime = tape[ptr++];
    let EndTime = tape[ptr++];
    let TimeSeriesDataType = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let Unit = tape[ptr++];
    return new IfcTimeSeries(expressID, type, Name, Description, StartTime, EndTime, TimeSeriesDataType, DataOrigin, UserDefinedDataOrigin, Unit);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.StartTime);
    args.push(this.EndTime);
    args.push(this.TimeSeriesDataType);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.Unit);
    return args;
  }
};
var IfcTimeSeriesValue = class {
  constructor(expressID, type, ListValues) {
    this.expressID = expressID;
    this.type = type;
    this.ListValues = ListValues;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ListValues = tape[ptr++];
    return new IfcTimeSeriesValue(expressID, type, ListValues);
  }
  ToTape() {
    let args = [];
    args.push(this.ListValues);
    return args;
  }
};
var IfcTopologicalRepresentationItem = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcTopologicalRepresentationItem(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcTopologyRepresentation = class {
  constructor(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items) {
    this.expressID = expressID;
    this.type = type;
    this.ContextOfItems = ContextOfItems;
    this.RepresentationIdentifier = RepresentationIdentifier;
    this.RepresentationType = RepresentationType;
    this.Items = Items;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ContextOfItems = tape[ptr++];
    let RepresentationIdentifier = tape[ptr++];
    let RepresentationType = tape[ptr++];
    let Items = tape[ptr++];
    return new IfcTopologyRepresentation(expressID, type, ContextOfItems, RepresentationIdentifier, RepresentationType, Items);
  }
  ToTape() {
    let args = [];
    args.push(this.ContextOfItems);
    args.push(this.RepresentationIdentifier);
    args.push(this.RepresentationType);
    args.push(this.Items);
    return args;
  }
};
var IfcToroidalSurface = class {
  constructor(expressID, type, Position, MajorRadius, MinorRadius) {
    this.expressID = expressID;
    this.type = type;
    this.Position = Position;
    this.MajorRadius = MajorRadius;
    this.MinorRadius = MinorRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Position = tape[ptr++];
    let MajorRadius = tape[ptr++];
    let MinorRadius = tape[ptr++];
    return new IfcToroidalSurface(expressID, type, Position, MajorRadius, MinorRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.Position);
    args.push(this.MajorRadius);
    args.push(this.MinorRadius);
    return args;
  }
};
var IfcTransformer = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformer(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransformerType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransformerType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransitionCurveSegment2D = class {
  constructor(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType) {
    this.expressID = expressID;
    this.type = type;
    this.StartPoint = StartPoint;
    this.StartDirection = StartDirection;
    this.SegmentLength = SegmentLength;
    this.StartRadius = StartRadius;
    this.EndRadius = EndRadius;
    this.IsStartRadiusCCW = IsStartRadiusCCW;
    this.IsEndRadiusCCW = IsEndRadiusCCW;
    this.TransitionCurveType = TransitionCurveType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let StartPoint = tape[ptr++];
    let StartDirection = tape[ptr++];
    let SegmentLength = tape[ptr++];
    let StartRadius = tape[ptr++];
    let EndRadius = tape[ptr++];
    let IsStartRadiusCCW = tape[ptr++];
    let IsEndRadiusCCW = tape[ptr++];
    let TransitionCurveType = tape[ptr++];
    return new IfcTransitionCurveSegment2D(expressID, type, StartPoint, StartDirection, SegmentLength, StartRadius, EndRadius, IsStartRadiusCCW, IsEndRadiusCCW, TransitionCurveType);
  }
  ToTape() {
    let args = [];
    args.push(this.StartPoint);
    args.push(this.StartDirection);
    args.push(this.SegmentLength);
    args.push(this.StartRadius);
    args.push(this.EndRadius);
    args.push(this.IsStartRadiusCCW);
    args.push(this.IsEndRadiusCCW);
    args.push(this.TransitionCurveType);
    return args;
  }
};
var IfcTransportElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTransportElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTransportElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTrapeziumProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.BottomXDim = BottomXDim;
    this.TopXDim = TopXDim;
    this.YDim = YDim;
    this.TopXOffset = TopXOffset;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let BottomXDim = tape[ptr++];
    let TopXDim = tape[ptr++];
    let YDim = tape[ptr++];
    let TopXOffset = tape[ptr++];
    return new IfcTrapeziumProfileDef(expressID, type, ProfileType, ProfileName, Position, BottomXDim, TopXDim, YDim, TopXOffset);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.BottomXDim);
    args.push(this.TopXDim);
    args.push(this.YDim);
    args.push(this.TopXOffset);
    return args;
  }
};
var IfcTriangulatedFaceSet = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    return new IfcTriangulatedFaceSet(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Normals);
    args.push(this.Closed);
    args.push(this.CoordIndex);
    args.push(this.PnIndex);
    return args;
  }
};
var IfcTriangulatedIrregularNetwork = class {
  constructor(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags) {
    this.expressID = expressID;
    this.type = type;
    this.Coordinates = Coordinates;
    this.Normals = Normals;
    this.Closed = Closed;
    this.CoordIndex = CoordIndex;
    this.PnIndex = PnIndex;
    this.Flags = Flags;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Coordinates = tape[ptr++];
    let Normals = tape[ptr++];
    let Closed = tape[ptr++];
    let CoordIndex = tape[ptr++];
    let PnIndex = tape[ptr++];
    let Flags = tape[ptr++];
    return new IfcTriangulatedIrregularNetwork(expressID, type, Coordinates, Normals, Closed, CoordIndex, PnIndex, Flags);
  }
  ToTape() {
    let args = [];
    args.push(this.Coordinates);
    args.push(this.Normals);
    args.push(this.Closed);
    args.push(this.CoordIndex);
    args.push(this.PnIndex);
    args.push(this.Flags);
    return args;
  }
};
var IfcTrimmedCurve = class {
  constructor(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation) {
    this.expressID = expressID;
    this.type = type;
    this.BasisCurve = BasisCurve;
    this.Trim1 = Trim1;
    this.Trim2 = Trim2;
    this.SenseAgreement = SenseAgreement;
    this.MasterRepresentation = MasterRepresentation;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let BasisCurve = tape[ptr++];
    let Trim1 = tape[ptr++];
    let Trim2 = tape[ptr++];
    let SenseAgreement = tape[ptr++];
    let MasterRepresentation = tape[ptr++];
    return new IfcTrimmedCurve(expressID, type, BasisCurve, Trim1, Trim2, SenseAgreement, MasterRepresentation);
  }
  ToTape() {
    let args = [];
    args.push(this.BasisCurve);
    args.push(this.Trim1);
    args.push(this.Trim2);
    args.push(this.SenseAgreement);
    args.push(this.MasterRepresentation);
    return args;
  }
};
var IfcTubeBundle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundle(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTubeBundleType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcTubeBundleType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcTypeObject = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    return new IfcTypeObject(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    return args;
  }
};
var IfcTypeProcess = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ProcessType = ProcessType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ProcessType = tape[ptr++];
    return new IfcTypeProcess(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ProcessType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ProcessType);
    return args;
  }
};
var IfcTypeProduct = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcTypeProduct(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    return args;
  }
};
var IfcTypeResource = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.Identification = Identification;
    this.LongDescription = LongDescription;
    this.ResourceType = ResourceType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let Identification = tape[ptr++];
    let LongDescription = tape[ptr++];
    let ResourceType = tape[ptr++];
    return new IfcTypeResource(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, Identification, LongDescription, ResourceType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.Identification);
    args.push(this.LongDescription);
    args.push(this.ResourceType);
    return args;
  }
};
var IfcUShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
    this.FlangeSlope = FlangeSlope;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    let FlangeSlope = tape[ptr++];
    return new IfcUShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius, FlangeSlope);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    args.push(this.FlangeSlope);
    return args;
  }
};
var IfcUnitAssignment = class {
  constructor(expressID, type, Units) {
    this.expressID = expressID;
    this.type = type;
    this.Units = Units;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Units = tape[ptr++];
    return new IfcUnitAssignment(expressID, type, Units);
  }
  ToTape() {
    let args = [];
    args.push(this.Units);
    return args;
  }
};
var IfcUnitaryControlElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryControlElementType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryControlElementType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryEquipment = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipment(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcUnitaryEquipmentType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcUnitaryEquipmentType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcValve = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValve(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcValveType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcValveType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVector = class {
  constructor(expressID, type, Orientation, Magnitude) {
    this.expressID = expressID;
    this.type = type;
    this.Orientation = Orientation;
    this.Magnitude = Magnitude;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Orientation = tape[ptr++];
    let Magnitude = tape[ptr++];
    return new IfcVector(expressID, type, Orientation, Magnitude);
  }
  ToTape() {
    let args = [];
    args.push(this.Orientation);
    args.push(this.Magnitude);
    return args;
  }
};
var IfcVertex = class {
  constructor(expressID, type) {
    this.expressID = expressID;
    this.type = type;
  }
  static FromTape(expressID, type, tape) {
    return new IfcVertex(expressID, type);
  }
  ToTape() {
    let args = [];
    return args;
  }
};
var IfcVertexLoop = class {
  constructor(expressID, type, LoopVertex) {
    this.expressID = expressID;
    this.type = type;
    this.LoopVertex = LoopVertex;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let LoopVertex = tape[ptr++];
    return new IfcVertexLoop(expressID, type, LoopVertex);
  }
  ToTape() {
    let args = [];
    args.push(this.LoopVertex);
    return args;
  }
};
var IfcVertexPoint = class {
  constructor(expressID, type, VertexGeometry) {
    this.expressID = expressID;
    this.type = type;
    this.VertexGeometry = VertexGeometry;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let VertexGeometry = tape[ptr++];
    return new IfcVertexPoint(expressID, type, VertexGeometry);
  }
  ToTape() {
    let args = [];
    args.push(this.VertexGeometry);
    return args;
  }
};
var IfcVibrationDamper = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamper(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationDamperType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationDamperType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationIsolator = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolator(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVibrationIsolatorType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVibrationIsolatorType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcVirtualElement = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    return new IfcVirtualElement(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    return args;
  }
};
var IfcVirtualGridIntersection = class {
  constructor(expressID, type, IntersectingAxes, OffsetDistances) {
    this.expressID = expressID;
    this.type = type;
    this.IntersectingAxes = IntersectingAxes;
    this.OffsetDistances = OffsetDistances;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let IntersectingAxes = tape[ptr++];
    let OffsetDistances = tape[ptr++];
    return new IfcVirtualGridIntersection(expressID, type, IntersectingAxes, OffsetDistances);
  }
  ToTape() {
    let args = [];
    args.push(this.IntersectingAxes);
    args.push(this.OffsetDistances);
    return args;
  }
};
var IfcVoidingFeature = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcVoidingFeature(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWall = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWall(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallElementedCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallElementedCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWallType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWallType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWasteTerminal = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminal(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWasteTerminalType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWasteTerminalType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWindow = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindow(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWindowLiningProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.LiningDepth = LiningDepth;
    this.LiningThickness = LiningThickness;
    this.TransomThickness = TransomThickness;
    this.MullionThickness = MullionThickness;
    this.FirstTransomOffset = FirstTransomOffset;
    this.SecondTransomOffset = SecondTransomOffset;
    this.FirstMullionOffset = FirstMullionOffset;
    this.SecondMullionOffset = SecondMullionOffset;
    this.ShapeAspectStyle = ShapeAspectStyle;
    this.LiningOffset = LiningOffset;
    this.LiningToPanelOffsetX = LiningToPanelOffsetX;
    this.LiningToPanelOffsetY = LiningToPanelOffsetY;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let LiningDepth = tape[ptr++];
    let LiningThickness = tape[ptr++];
    let TransomThickness = tape[ptr++];
    let MullionThickness = tape[ptr++];
    let FirstTransomOffset = tape[ptr++];
    let SecondTransomOffset = tape[ptr++];
    let FirstMullionOffset = tape[ptr++];
    let SecondMullionOffset = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    let LiningOffset = tape[ptr++];
    let LiningToPanelOffsetX = tape[ptr++];
    let LiningToPanelOffsetY = tape[ptr++];
    return new IfcWindowLiningProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, LiningDepth, LiningThickness, TransomThickness, MullionThickness, FirstTransomOffset, SecondTransomOffset, FirstMullionOffset, SecondMullionOffset, ShapeAspectStyle, LiningOffset, LiningToPanelOffsetX, LiningToPanelOffsetY);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.LiningDepth);
    args.push(this.LiningThickness);
    args.push(this.TransomThickness);
    args.push(this.MullionThickness);
    args.push(this.FirstTransomOffset);
    args.push(this.SecondTransomOffset);
    args.push(this.FirstMullionOffset);
    args.push(this.SecondMullionOffset);
    args.push(this.ShapeAspectStyle);
    args.push(this.LiningOffset);
    args.push(this.LiningToPanelOffsetX);
    args.push(this.LiningToPanelOffsetY);
    return args;
  }
};
var IfcWindowPanelProperties = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.OperationType = OperationType;
    this.PanelPosition = PanelPosition;
    this.FrameDepth = FrameDepth;
    this.FrameThickness = FrameThickness;
    this.ShapeAspectStyle = ShapeAspectStyle;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let OperationType = tape[ptr++];
    let PanelPosition = tape[ptr++];
    let FrameDepth = tape[ptr++];
    let FrameThickness = tape[ptr++];
    let ShapeAspectStyle = tape[ptr++];
    return new IfcWindowPanelProperties(expressID, type, GlobalId, OwnerHistory, Name, Description, OperationType, PanelPosition, FrameDepth, FrameThickness, ShapeAspectStyle);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.OperationType);
    args.push(this.PanelPosition);
    args.push(this.FrameDepth);
    args.push(this.FrameThickness);
    args.push(this.ShapeAspectStyle);
    return args;
  }
};
var IfcWindowStandardCase = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.ObjectPlacement = ObjectPlacement;
    this.Representation = Representation;
    this.Tag = Tag;
    this.OverallHeight = OverallHeight;
    this.OverallWidth = OverallWidth;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let ObjectPlacement = tape[ptr++];
    let Representation = tape[ptr++];
    let Tag = tape[ptr++];
    let OverallHeight = tape[ptr++];
    let OverallWidth = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowStandardCase(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, ObjectPlacement, Representation, Tag, OverallHeight, OverallWidth, PredefinedType, PartitioningType, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.ObjectPlacement);
    args.push(this.Representation);
    args.push(this.Tag);
    args.push(this.OverallHeight);
    args.push(this.OverallWidth);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWindowStyle = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ConstructionType = ConstructionType;
    this.OperationType = OperationType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.Sizeable = Sizeable;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ConstructionType = tape[ptr++];
    let OperationType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let Sizeable = tape[ptr++];
    return new IfcWindowStyle(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ConstructionType, OperationType, ParameterTakesPrecedence, Sizeable);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ConstructionType);
    args.push(this.OperationType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.Sizeable);
    return args;
  }
};
var IfcWindowType = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ApplicableOccurrence = ApplicableOccurrence;
    this.HasPropertySets = HasPropertySets;
    this.RepresentationMaps = RepresentationMaps;
    this.Tag = Tag;
    this.ElementType = ElementType;
    this.PredefinedType = PredefinedType;
    this.PartitioningType = PartitioningType;
    this.ParameterTakesPrecedence = ParameterTakesPrecedence;
    this.UserDefinedPartitioningType = UserDefinedPartitioningType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ApplicableOccurrence = tape[ptr++];
    let HasPropertySets = tape[ptr++];
    let RepresentationMaps = tape[ptr++];
    let Tag = tape[ptr++];
    let ElementType = tape[ptr++];
    let PredefinedType = tape[ptr++];
    let PartitioningType = tape[ptr++];
    let ParameterTakesPrecedence = tape[ptr++];
    let UserDefinedPartitioningType = tape[ptr++];
    return new IfcWindowType(expressID, type, GlobalId, OwnerHistory, Name, Description, ApplicableOccurrence, HasPropertySets, RepresentationMaps, Tag, ElementType, PredefinedType, PartitioningType, ParameterTakesPrecedence, UserDefinedPartitioningType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ApplicableOccurrence);
    args.push(this.HasPropertySets);
    args.push(this.RepresentationMaps);
    args.push(this.Tag);
    args.push(this.ElementType);
    args.push(this.PredefinedType);
    args.push(this.PartitioningType);
    args.push(this.ParameterTakesPrecedence);
    args.push(this.UserDefinedPartitioningType);
    return args;
  }
};
var IfcWorkCalendar = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.WorkingTimes = WorkingTimes;
    this.ExceptionTimes = ExceptionTimes;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let WorkingTimes = tape[ptr++];
    let ExceptionTimes = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkCalendar(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, WorkingTimes, ExceptionTimes, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.WorkingTimes);
    args.push(this.ExceptionTimes);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkControl = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    return new IfcWorkControl(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    return args;
  }
};
var IfcWorkPlan = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkPlan(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkSchedule = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.Identification = Identification;
    this.CreationDate = CreationDate;
    this.Creators = Creators;
    this.Purpose = Purpose;
    this.Duration = Duration;
    this.TotalFloat = TotalFloat;
    this.StartTime = StartTime;
    this.FinishTime = FinishTime;
    this.PredefinedType = PredefinedType;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let Identification = tape[ptr++];
    let CreationDate = tape[ptr++];
    let Creators = tape[ptr++];
    let Purpose = tape[ptr++];
    let Duration = tape[ptr++];
    let TotalFloat = tape[ptr++];
    let StartTime = tape[ptr++];
    let FinishTime = tape[ptr++];
    let PredefinedType = tape[ptr++];
    return new IfcWorkSchedule(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, Identification, CreationDate, Creators, Purpose, Duration, TotalFloat, StartTime, FinishTime, PredefinedType);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.Identification);
    args.push(this.CreationDate);
    args.push(this.Creators);
    args.push(this.Purpose);
    args.push(this.Duration);
    args.push(this.TotalFloat);
    args.push(this.StartTime);
    args.push(this.FinishTime);
    args.push(this.PredefinedType);
    return args;
  }
};
var IfcWorkTime = class {
  constructor(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish) {
    this.expressID = expressID;
    this.type = type;
    this.Name = Name;
    this.DataOrigin = DataOrigin;
    this.UserDefinedDataOrigin = UserDefinedDataOrigin;
    this.RecurrencePattern = RecurrencePattern;
    this.Start = Start;
    this.Finish = Finish;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let Name = tape[ptr++];
    let DataOrigin = tape[ptr++];
    let UserDefinedDataOrigin = tape[ptr++];
    let RecurrencePattern = tape[ptr++];
    let Start = tape[ptr++];
    let Finish = tape[ptr++];
    return new IfcWorkTime(expressID, type, Name, DataOrigin, UserDefinedDataOrigin, RecurrencePattern, Start, Finish);
  }
  ToTape() {
    let args = [];
    args.push(this.Name);
    args.push(this.DataOrigin);
    args.push(this.UserDefinedDataOrigin);
    args.push(this.RecurrencePattern);
    args.push(this.Start);
    args.push(this.Finish);
    return args;
  }
};
var IfcZShapeProfileDef = class {
  constructor(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius) {
    this.expressID = expressID;
    this.type = type;
    this.ProfileType = ProfileType;
    this.ProfileName = ProfileName;
    this.Position = Position;
    this.Depth = Depth;
    this.FlangeWidth = FlangeWidth;
    this.WebThickness = WebThickness;
    this.FlangeThickness = FlangeThickness;
    this.FilletRadius = FilletRadius;
    this.EdgeRadius = EdgeRadius;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let ProfileType = tape[ptr++];
    let ProfileName = tape[ptr++];
    let Position = tape[ptr++];
    let Depth = tape[ptr++];
    let FlangeWidth = tape[ptr++];
    let WebThickness = tape[ptr++];
    let FlangeThickness = tape[ptr++];
    let FilletRadius = tape[ptr++];
    let EdgeRadius = tape[ptr++];
    return new IfcZShapeProfileDef(expressID, type, ProfileType, ProfileName, Position, Depth, FlangeWidth, WebThickness, FlangeThickness, FilletRadius, EdgeRadius);
  }
  ToTape() {
    let args = [];
    args.push(this.ProfileType);
    args.push(this.ProfileName);
    args.push(this.Position);
    args.push(this.Depth);
    args.push(this.FlangeWidth);
    args.push(this.WebThickness);
    args.push(this.FlangeThickness);
    args.push(this.FilletRadius);
    args.push(this.EdgeRadius);
    return args;
  }
};
var IfcZone = class {
  constructor(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName) {
    this.expressID = expressID;
    this.type = type;
    this.GlobalId = GlobalId;
    this.OwnerHistory = OwnerHistory;
    this.Name = Name;
    this.Description = Description;
    this.ObjectType = ObjectType;
    this.LongName = LongName;
  }
  static FromTape(expressID, type, tape) {
    let ptr = 0;
    let GlobalId = tape[ptr++];
    let OwnerHistory = tape[ptr++];
    let Name = tape[ptr++];
    let Description = tape[ptr++];
    let ObjectType = tape[ptr++];
    let LongName = tape[ptr++];
    return new IfcZone(expressID, type, GlobalId, OwnerHistory, Name, Description, ObjectType, LongName);
  }
  ToTape() {
    let args = [];
    args.push(this.GlobalId);
    args.push(this.OwnerHistory);
    args.push(this.Name);
    args.push(this.Description);
    args.push(this.ObjectType);
    args.push(this.LongName);
    return args;
  }
};

// dist/helpers/ifc-elements.ts
var IfcElements2 = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};

// dist/helpers/types-map.ts
var IfcTypesMap$1 = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119e3: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE"
};

// dist/helpers/properties.ts
var PropsNames$1 = {
  aggregates: {
    name: IFCRELAGGREGATES,
    relating: "RelatingObject",
    related: "RelatedObjects",
    key: "children"
  },
  spatial: {
    name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
    relating: "RelatingStructure",
    related: "RelatedElements",
    key: "children"
  },
  psets: {
    name: IFCRELDEFINESBYPROPERTIES,
    relating: "RelatingPropertyDefinition",
    related: "RelatedObjects",
    key: "hasPsets"
  },
  materials: {
    name: IFCRELASSOCIATESMATERIAL,
    relating: "RelatingMaterial",
    related: "RelatedObjects",
    key: "hasMaterial"
  },
  type: {
    name: IFCRELDEFINESBYTYPE,
    relating: "RelatingType",
    related: "RelatedObjects",
    key: "hasType"
  }
};
var Properties = class {
  constructor(api) {
    this.api = api;
  }
  getIfcType(type) {
    return IfcTypesMap$1[type];
  }
  getItemProperties(modelID, id, recursive = false) {
    return __async(this, null, function* () {
      return this.api.GetLine(modelID, id, recursive);
    });
  }
  getPropertySets(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.psets);
    });
  }
  getTypeProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.type);
    });
  }
  getMaterialsProperties(modelID, elementID, recursive = false) {
    return __async(this, null, function* () {
      return yield this.getProperty(modelID, elementID, recursive, PropsNames$1.materials);
    });
  }
  getSpatialStructure(modelID, includeProperties) {
    return __async(this, null, function* () {
      yield this.getAllTypesOfModel(modelID);
      const chunks = yield this.getSpatialTreeChunks(modelID);
      const allLines = yield this.api.GetLineIDsWithType(modelID, IFCPROJECT);
      const projectID = allLines.get(0);
      const project = Properties.newIfcProject(projectID);
      yield this.getSpatialNode(modelID, project, chunks, includeProperties);
      this.cleanupTypes();
      return project;
    });
  }
  getAllItemsOfType(modelID, type, verbose) {
    return __async(this, null, function* () {
      let items = [];
      const lines = yield this.api.GetLineIDsWithType(modelID, type);
      for (let i = 0; i < lines.size(); i++)
        items.push(lines.get(i));
      if (!verbose)
        return items;
      const result = [];
      for (let i = 0; i < items.length; i++) {
        result.push(yield this.api.GetLine(modelID, items[i]));
      }
      return result;
    });
  }
  getProperty(modelID, elementID, recursive = false, propName) {
    return __async(this, null, function* () {
      const propSetIds = yield this.getAllRelatedItemsOfType(modelID, elementID, propName);
      const result = [];
      for (let i = 0; i < propSetIds.length; i++) {
        result.push(yield this.api.GetLine(modelID, propSetIds[i], recursive));
      }
      return result;
    });
  }
  getChunks(modelID, chunks, propNames) {
    return __async(this, null, function* () {
      const relation = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      for (let i = 0; i < relation.size(); i++) {
        const rel = yield this.api.GetLine(modelID, relation.get(i), false);
        this.saveChunk(chunks, propNames, rel);
      }
    });
  }
  static isRelated(id, rel, propNames) {
    const relatedItems = rel[propNames.related];
    if (Array.isArray(relatedItems)) {
      const values = relatedItems.map((item) => item.value);
      return values.includes(id);
    }
    return relatedItems.value === id;
  }
  static newIfcProject(id) {
    return {
      expressID: id,
      type: "IFCPROJECT",
      children: []
    };
  }
  getSpatialNode(modelID, node, treeChunks, includeProperties) {
    return __async(this, null, function* () {
      yield this.getChildren(modelID, node, treeChunks, PropsNames$1.aggregates, includeProperties);
      yield this.getChildren(modelID, node, treeChunks, PropsNames$1.spatial, includeProperties);
    });
  }
  getChildren(modelID, node, treeChunks, propNames, includeProperties) {
    return __async(this, null, function* () {
      const children = treeChunks[node.expressID];
      if (children == void 0)
        return;
      const prop = propNames.key;
      const nodes = [];
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        let node2 = this.newNode(child);
        if (includeProperties) {
          const properties = yield this.getItemProperties(modelID, node2.expressID);
          node2 = __spreadValues(__spreadValues({}, properties), node2);
        }
        yield this.getSpatialNode(modelID, node2, treeChunks, includeProperties);
        nodes.push(node2);
      }
      node[prop] = nodes;
    });
  }
  newNode(id) {
    const typeName = this.getNodeType(id);
    return {
      expressID: id,
      type: typeName,
      children: []
    };
  }
  getNodeType(id) {
    const typeID = this.types[id];
    return IfcElements2[typeID];
  }
  getSpatialTreeChunks(modelID) {
    return __async(this, null, function* () {
      const treeChunks = {};
      yield this.getChunks(modelID, treeChunks, PropsNames$1.aggregates);
      yield this.getChunks(modelID, treeChunks, PropsNames$1.spatial);
      return treeChunks;
    });
  }
  saveChunk(chunks, propNames, rel) {
    const relating = rel[propNames.relating].value;
    const related = rel[propNames.related].map((r) => r.value);
    if (chunks[relating] == void 0) {
      chunks[relating] = related;
    } else {
      chunks[relating] = chunks[relating].concat(related);
    }
  }
  getRelated(rel, propNames, IDs) {
    const element = rel[propNames.relating];
    if (!Array.isArray(element))
      IDs.push(element.value);
    else
      element.forEach((ele) => IDs.push(ele.value));
  }
  getAllRelatedItemsOfType(modelID, id, propNames) {
    return __async(this, null, function* () {
      const lines = yield this.api.GetLineIDsWithType(modelID, propNames.name);
      const IDs = [];
      for (let i = 0; i < lines.size(); i++) {
        const rel = yield this.api.GetLine(modelID, lines.get(i));
        const isRelated = Properties.isRelated(id, rel, propNames);
        if (isRelated)
          this.getRelated(rel, propNames, IDs);
      }
      return IDs;
    });
  }
  cleanupTypes() {
    this.types = {};
  }
  getAllTypesOfModel(modelID) {
    return __async(this, null, function* () {
      const result = {};
      const elements = Object.keys(IfcElements2).map((e) => parseInt(e));
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        const lines = yield this.api.GetLineIDsWithType(modelID, element);
        const size = lines.size();
        for (let i2 = 0; i2 < size; i2++)
          result[lines.get(i2)] = element;
      }
      this.types = result;
    });
  }
};

// dist/web-ifc-api.ts
var WebIFCWasm;
if (typeof self !== "undefined" && self.crossOriginIsolated) {
  WebIFCWasm = require_web_ifc_mt();
} else {
  WebIFCWasm = require_web_ifc();
}
var IfcAPI2 = class {
  constructor() {
    this.wasmModule = void 0;
    this.fs = void 0;
    this.wasmPath = "";
    this.isWasmPathAbsolute = false;
    this.ifcGuidMap = new Map();
    this.properties = new Properties(this);
  }
  Init(customLocateFileHandler) {
    return __async(this, null, function* () {
      if (WebIFCWasm) {
        let locateFileHandler = (path, prefix) => {
          if (path.endsWith(".wasm")) {
            if (this.isWasmPathAbsolute) {
              return this.wasmPath + path;
            }
            return prefix + this.wasmPath + path;
          }
          return prefix + path;
        };
        this.wasmModule = yield WebIFCWasm({ noInitialRun: true, locateFile: customLocateFileHandler || locateFileHandler });
        this.fs = this.wasmModule.FS;
      } else {
        console.error(`Could not find wasm module at './web-ifc' from web-ifc-api.ts`);
      }
    });
  }
  OpenModel(data, settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let offsetInSrc = 0;
    let result = this.wasmModule.OpenModel(s, (destPtr, destSize) => {
      let srcSize = Math.min(data.byteLength - offsetInSrc, destSize);
      let dest = this.wasmModule.HEAPU8.subarray(destPtr, destPtr + destSize);
      let src = data.subarray(offsetInSrc, offsetInSrc + srcSize);
      dest.set(src);
      offsetInSrc += srcSize;
      return srcSize;
    });
    return result;
  }
  CreateModel(settings) {
    let s = __spreadValues({
      COORDINATE_TO_ORIGIN: false,
      USE_FAST_BOOLS: false,
      CIRCLE_SEGMENTS_LOW: 5,
      CIRCLE_SEGMENTS_MEDIUM: 8,
      CIRCLE_SEGMENTS_HIGH: 12,
      BOOL_ABORT_THRESHOLD: 1e4
    }, settings);
    let result = this.wasmModule.CreateModel(s);
    return result;
  }
  ExportFileAsIFC(modelID) {
    this.wasmModule.ExportFileAsIFC(modelID);
    let result = this.fs.readFile("/export.ifc");
    this.wasmModule["FS_unlink"]("/export.ifc");
    return result;
  }
  GetGeometry(modelID, geometryExpressID) {
    return this.wasmModule.GetGeometry(modelID, geometryExpressID);
  }
  GetLine(modelID, expressID, flatten = false) {
    let rawLineData = this.GetRawLineData(modelID, expressID);
    let lineData = FromRawLineData[rawLineData.type](rawLineData);
    if (flatten) {
      this.FlattenLine(modelID, lineData);
    }
    return lineData;
  }
  GetAndClearErrors(modelID) {
    return this.wasmModule.GetAndClearErrors(modelID);
  }
  WriteLine(modelID, lineObject) {
    Object.keys(lineObject).forEach((propertyName) => {
      let property = lineObject[propertyName];
      if (property && property.expressID !== void 0) {
        this.WriteLine(modelID, property);
        lineObject[propertyName] = {
          type: 5,
          value: property.expressID
        };
      } else if (Array.isArray(property) && property.length > 0) {
        for (let i = 0; i < property.length; i++) {
          if (property[i].expressID !== void 0) {
            this.WriteLine(modelID, property[i]);
            lineObject[propertyName][i] = {
              type: 5,
              value: property[i].expressID
            };
          }
        }
      }
    });
    let rawLineData = {
      ID: lineObject.expressID,
      type: lineObject.type,
      arguments: lineObject.ToTape()
    };
    this.WriteRawLineData(modelID, rawLineData);
  }
  FlattenLine(modelID, line) {
    Object.keys(line).forEach((propertyName) => {
      let property = line[propertyName];
      if (property && property.type === 5) {
        line[propertyName] = this.GetLine(modelID, property.value, true);
      } else if (Array.isArray(property) && property.length > 0 && property[0].type === 5) {
        for (let i = 0; i < property.length; i++) {
          line[propertyName][i] = this.GetLine(modelID, property[i].value, true);
        }
      }
    });
  }
  GetRawLineData(modelID, expressID) {
    return this.wasmModule.GetLine(modelID, expressID);
  }
  WriteRawLineData(modelID, data) {
    return this.wasmModule.WriteLine(modelID, data.ID, data.type, data.arguments);
  }
  GetLineIDsWithType(modelID, type) {
    return this.wasmModule.GetLineIDsWithType(modelID, type);
  }
  GetAllLines(modelID) {
    return this.wasmModule.GetAllLines(modelID);
  }
  SetGeometryTransformation(modelID, transformationMatrix) {
    if (transformationMatrix.length != 16) {
      console.log(`Bad transformation matrix size: ${transformationMatrix.length}`);
      return;
    }
    this.wasmModule.SetGeometryTransformation(modelID, transformationMatrix);
  }
  GetCoordinationMatrix(modelID) {
    return this.wasmModule.GetCoordinationMatrix(modelID);
  }
  GetVertexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPF32, ptr, size);
  }
  GetIndexArray(ptr, size) {
    return this.getSubArray(this.wasmModule.HEAPU32, ptr, size);
  }
  getSubArray(heap, startPtr, sizeBytes) {
    return heap.subarray(startPtr / 4, startPtr / 4 + sizeBytes).slice(0);
  }
  CloseModel(modelID) {
    this.ifcGuidMap.delete(modelID);
    this.wasmModule.CloseModel(modelID);
  }
  StreamAllMeshes(modelID, meshCallback) {
    this.wasmModule.StreamAllMeshes(modelID, meshCallback);
  }
  StreamAllMeshesWithTypes(modelID, types, meshCallback) {
    this.wasmModule.StreamAllMeshesWithTypes(modelID, types, meshCallback);
  }
  IsModelOpen(modelID) {
    return this.wasmModule.IsModelOpen(modelID);
  }
  LoadAllGeometry(modelID) {
    return this.wasmModule.LoadAllGeometry(modelID);
  }
  GetFlatMesh(modelID, expressID) {
    return this.wasmModule.GetFlatMesh(modelID, expressID);
  }
  CreateIfcGuidToExpressIdMapping(modelID) {
    const map = new Map();
    for (let x = 0; x < IfcElements$1.length; x++) {
      const type = IfcElements$1[x];
      const lines = this.GetLineIDsWithType(modelID, type);
      const size = lines.size();
      for (let y = 0; y < size; y++) {
        const expressID = lines.get(y);
        const info = this.GetLine(modelID, expressID);
        const globalID = info.GlobalId.value;
        map.set(expressID, globalID);
        map.set(globalID, expressID);
      }
    }
    this.ifcGuidMap.set(modelID, map);
  }
  SetWasmPath(path, absolute = false) {
    this.wasmPath = path;
    this.isWasmPathAbsolute = absolute;
  }
};

class ClippingEdges {
    constructor(clippingPlane) {
        this.edges = {};
        this.isVisible = true;
        this.inverseMatrix = new Matrix4();
        this.localPlane = new Plane();
        this.tempLine = new Line3();
        this.tempVector = new Vector3();
        this.stylesInitialized = false;
        this.clippingPlane = clippingPlane;
    }
    get visible() {
        return this.isVisible;
    }
    set visible(visible) {
        this.isVisible = visible;
        const allEdges = Object.values(this.edges);
        allEdges.forEach((edges) => {
            edges.mesh.visible = visible;
            if (visible)
                ClippingEdges.context.getScene().add(edges.mesh);
            else
                edges.mesh.removeFromParent();
        });
        if (visible)
            this.updateEdges();
    }
    // Initializes the helper geometry used to compute the vertices
    static newGeneratorGeometry() {
        // create line geometry with enough data to hold 100000 segments
        const generatorGeometry = new BufferGeometry();
        const linePosAttr = new BufferAttribute(new Float32Array(300000), 3, false);
        linePosAttr.setUsage(DynamicDrawUsage);
        generatorGeometry.setAttribute('position', linePosAttr);
        return generatorGeometry;
    }
    dispose() {
        Object.values(this.edges).forEach((edge) => {
            if (edge.generatorGeometry.boundsTree)
                edge.generatorGeometry.disposeBoundsTree();
            edge.generatorGeometry.dispose();
            if (edge.mesh.geometry.boundsTree)
                edge.mesh.geometry.disposeBoundsTree();
            edge.mesh.geometry.dispose();
            edge.mesh.removeFromParent();
            edge.mesh = null;
        });
        this.edges = null;
        this.clippingPlane = null;
    }
    disposeStylesAndHelpers() {
        if (ClippingEdges.basicEdges) {
            ClippingEdges.basicEdges.removeFromParent();
            ClippingEdges.basicEdges.geometry.dispose();
            ClippingEdges.basicEdges = null;
            ClippingEdges.basicEdges = new LineSegments();
        }
        ClippingEdges.context = null;
        ClippingEdges.ifc = null;
        ClippingEdges.edgesParent = undefined;
        if (!ClippingEdges.styles)
            return;
        const styles = Object.values(ClippingEdges.styles);
        styles.forEach((style) => {
            style.ids.length = 0;
            style.meshes.forEach((mesh) => {
                mesh.removeFromParent();
                mesh.geometry.dispose();
                if (mesh.geometry.boundsTree)
                    mesh.geometry.disposeBoundsTree();
                if (Array.isArray(mesh.material))
                    mesh.material.forEach((mat) => mat.dispose());
                else
                    mesh.material.dispose();
            });
            style.meshes.length = 0;
            style.categories.length = 0;
            style.material.dispose();
        });
        ClippingEdges.styles = null;
        ClippingEdges.styles = {};
    }
    async updateEdges() {
        if (ClippingEdges.createDefaultIfcStyles) {
            await this.updateIfcStyles();
        }
        if (ClippingEdges.forceStyleUpdate) {
            this.updateSubsetsTranformation();
        }
        Object.keys(ClippingEdges.styles).forEach((styleName) => {
            try {
                // this can trow error if there is an empty mesh, we still want to update other edges so we catch ere
                this.drawEdges(styleName);
            }
            catch (e) {
                console.error('error in drawing edges', e);
            }
        });
    }
    // Creates a new style that applies to all clipping edges for IFC models
    static async newStyle(styleName, categories, material = ClippingEdges.defaultMaterial) {
        const subsets = [];
        const models = ClippingEdges.context.items.ifcModels;
        for (let i = 0; i < models.length; i++) {
            // eslint-disable-next-line no-await-in-loop
            const subset = await ClippingEdges.newSubset(styleName, models[i], categories);
            if (subset) {
                subsets.push(subset);
            }
        }
        material.clippingPlanes = ClippingEdges.context.getClippingPlanes();
        ClippingEdges.styles[styleName] = {
            ids: models.map((model) => model.modelID),
            categories,
            material,
            meshes: subsets
        };
    }
    // Creates a new style that applies to all clipping edges for generic models
    static async newStyleFromMesh(styleName, meshes, material = ClippingEdges.defaultMaterial) {
        const ids = meshes.map((mesh) => mesh.modelID);
        meshes.forEach((mesh) => {
            if (!mesh.geometry.boundsTree)
                mesh.geometry.computeBoundsTree();
        });
        material.clippingPlanes = ClippingEdges.context.getClippingPlanes();
        ClippingEdges.styles[styleName] = {
            ids,
            categories: [],
            material,
            meshes
        };
    }
    async updateStylesIfcGeometry() {
        const styleNames = Object.keys(ClippingEdges.styles);
        for (let i = 0; i < styleNames.length; i++) {
            const name = styleNames[i];
            const style = ClippingEdges.styles[name];
            const models = ClippingEdges.context.items.ifcModels;
            style.meshes.length = 0;
            for (let i = 0; i < models.length; i++) {
                // eslint-disable-next-line no-await-in-loop
                const subset = await ClippingEdges.newSubset(name, models[i], style.categories);
                if (subset) {
                    style.meshes.push(subset);
                }
            }
        }
    }
    updateSubsetsTranformation() {
        const styleNames = Object.keys(ClippingEdges.styles);
        for (let i = 0; i < styleNames.length; i++) {
            const styleName = styleNames[i];
            const style = ClippingEdges.styles[styleName];
            style.meshes.forEach((mesh) => {
                const model = ClippingEdges.context.items.ifcModels.find((model) => model.modelID === mesh.modelID);
                if (model) {
                    mesh.position.copy(model.position);
                    mesh.rotation.copy(model.rotation);
                    mesh.scale.copy(model.scale);
                }
            });
        }
        ClippingEdges.forceStyleUpdate = false;
    }
    async updateIfcStyles() {
        if (!this.stylesInitialized) {
            await this.createDefaultIfcStyles();
        }
        if (ClippingEdges.forceStyleUpdate) {
            await this.updateStylesIfcGeometry();
            ClippingEdges.forceStyleUpdate = false;
        }
    }
    // Creates some basic styles so that users don't have to create it each time
    async createDefaultIfcStyles() {
        if (Object.keys(ClippingEdges.styles).length === 0) {
            await ClippingEdges.newStyle('thick', [
                IFCWALLSTANDARDCASE,
                IFCWALL,
                IFCSLAB,
                IFCSTAIRFLIGHT,
                IFCCOLUMN,
                IFCBEAM,
                IFCROOF,
                IFCBUILDINGELEMENTPROXY,
                IFCPROXY
            ], new LineMaterial({ color: 0x000000, linewidth: 0.0015 }));
            await ClippingEdges.newStyle('thin', [
                IFCWINDOW,
                IFCPLATE,
                IFCMEMBER,
                IFCDOOR,
                IFCFURNISHINGELEMENT,
                IFCPROXY,
                IFCBUILDINGELEMENTPROXY,
                IFCFOOTING
            ], new LineMaterial({ color: 0x333333, linewidth: 0.001 }));
            this.stylesInitialized = true;
        }
    }
    // Creates a new subset. This allows to apply a style just to a specific set of items
    static async newSubset(styleName, model, categories) {
        const modelID = model.modelID;
        const ids = await this.getItemIDs(modelID, categories);
        // If no items were found, no geometry is created for this style
        if (!ids.length)
            return null;
        const manager = this.ifc.loader.ifcManager;
        let subset;
        if (ids.length > 0) {
            subset = manager.createSubset({
                modelID,
                ids,
                customID: styleName,
                material: ClippingEdges.invisibleMaterial,
                removePrevious: true,
                scene: ClippingEdges.context.getScene(),
                applyBVH: true
            });
        }
        else {
            subset = manager.getSubset(modelID, ClippingEdges.invisibleMaterial, styleName);
        }
        subset.position.copy(model.position);
        subset.rotation.copy(model.rotation);
        subset.scale.copy(model.scale);
        return subset;
    }
    static async getItemIDs(modelID, categories) {
        const ids = [];
        for (let j = 0; j < categories.length; j++) {
            // eslint-disable-next-line no-await-in-loop
            const found = await this.ifc.getAllItemsOfType(modelID, categories[j], false);
            ids.push(...found);
        }
        const visibleItems = this.getVisibileItems(modelID);
        return ids.filter((id) => visibleItems.has(id));
    }
    static getVisibileItems(modelID) {
        const visibleItems = new Set();
        const model = this.context.items.ifcModels.find((model) => model.modelID === modelID);
        if (!model)
            throw new Error('IFC model was not found for computing clipping edges.');
        if (!model.geometry.index)
            throw new Error('Indices were not found for clipping edges.');
        const indices = new Set(model.geometry.index.array);
        indices.forEach((index) => {
            visibleItems.add(model.geometry.attributes.expressID.getX(index));
        });
        return visibleItems;
    }
    // Creates the geometry of the clipping edges
    newThickEdges(styleName) {
        const material = ClippingEdges.styles[styleName].material;
        const thickLineGeometry = new LineSegmentsGeometry();
        const thickEdges = new LineSegments2(thickLineGeometry, material);
        thickEdges.material.polygonOffset = true;
        thickEdges.material.polygonOffsetFactor = -2;
        thickEdges.material.polygonOffsetUnits = 1;
        thickEdges.renderOrder = 3;
        return thickEdges;
    }
    // Source: https://gkjohnson.github.io/three-mesh-bvh/example/bundle/clippedEdges.html
    drawEdges(styleName) {
        const style = ClippingEdges.styles[styleName];
        // if (!style.subsets.geometry.boundsTree) return;
        if (!this.edges[styleName]) {
            this.edges[styleName] = {
                generatorGeometry: ClippingEdges.newGeneratorGeometry(),
                mesh: this.newThickEdges(styleName)
            };
        }
        const edges = this.edges[styleName];
        let index = 0;
        const posAttr = edges.generatorGeometry.attributes.position;
        // @ts-ignore
        posAttr.array.fill(0);
        const notEmptyMeshes = style.meshes.filter((subset) => subset.geometry);
        notEmptyMeshes.forEach((mesh) => {
            if (!mesh.geometry.boundsTree) {
                throw new Error('Boundstree not found for clipping edges subset.');
            }
            this.inverseMatrix.copy(mesh.matrixWorld).invert();
            this.localPlane.copy(this.clippingPlane).applyMatrix4(this.inverseMatrix);
            mesh.geometry.boundsTree.shapecast({
                intersectsBounds: (box) => {
                    return this.localPlane.intersectsBox(box);
                },
                // @ts-ignore
                intersectsTriangle: (tri) => {
                    // check each triangle edge to see if it intersects with the plane. If so then
                    // add it to the list of segments.
                    let count = 0;
                    this.tempLine.start.copy(tri.a);
                    this.tempLine.end.copy(tri.b);
                    if (this.localPlane.intersectLine(this.tempLine, this.tempVector)) {
                        const result = this.tempVector.applyMatrix4(mesh.matrixWorld);
                        posAttr.setXYZ(index, result.x, result.y, result.z);
                        count++;
                        index++;
                    }
                    this.tempLine.start.copy(tri.b);
                    this.tempLine.end.copy(tri.c);
                    if (this.localPlane.intersectLine(this.tempLine, this.tempVector)) {
                        const result = this.tempVector.applyMatrix4(mesh.matrixWorld);
                        posAttr.setXYZ(index, result.x, result.y, result.z);
                        count++;
                        index++;
                    }
                    this.tempLine.start.copy(tri.c);
                    this.tempLine.end.copy(tri.a);
                    if (this.localPlane.intersectLine(this.tempLine, this.tempVector)) {
                        const result = this.tempVector.applyMatrix4(mesh.matrixWorld);
                        posAttr.setXYZ(index, result.x, result.y, result.z);
                        count++;
                        index++;
                    }
                    // If we only intersected with one or three sides then just remove it. This could be handled
                    // more gracefully.
                    if (count !== 2) {
                        index -= count;
                    }
                }
            });
        });
        // set the draw range to only the new segments and offset the lines so they don't intersect with the geometry
        edges.mesh.geometry.setDrawRange(0, index);
        edges.mesh.position.copy(this.clippingPlane.normal).multiplyScalar(0.0001);
        posAttr.needsUpdate = true;
        // Update the edges geometry only if there is no NaN in the output (which means there's been an error)
        if (!Number.isNaN(edges.generatorGeometry.attributes.position.array[0])) {
            ClippingEdges.basicEdges.geometry = edges.generatorGeometry;
            edges.mesh.geometry.fromLineSegments(ClippingEdges.basicEdges);
            const parent = ClippingEdges.edgesParent || ClippingEdges.context.getScene();
            parent.add(edges.mesh);
            ClippingEdges.context.renderer.postProduction.excludedItems.add(edges.mesh);
        }
    }
}
ClippingEdges.styles = {};
ClippingEdges.forceStyleUpdate = false;
ClippingEdges.createDefaultIfcStyles = true;
ClippingEdges.edgesParent = null;
ClippingEdges.invisibleMaterial = new MeshBasicMaterial({ visible: false });
ClippingEdges.defaultMaterial = new LineMaterial({ color: 0x000000, linewidth: 0.001 });
// Helpers
ClippingEdges.basicEdges = new LineSegments();

class IfcPlane extends IfcComponent {
    constructor(context, origin, normal, onStartDragging, onEndDragging, planeSize, edgesEnabled) {
        super(context);
        this.arrowBoundingBox = new Mesh();
        this.isVisible = true;
        this.enabled = true;
        this.edgesActive = true;
        // Wether this plane is a section or floor plan
        this.isPlan = false;
        this.removeFromScene = () => {
            this.helper.removeFromParent();
            this.arrowBoundingBox.removeFromParent();
            this.arrowBoundingBox.geometry.dispose();
            this.arrowBoundingBox = undefined;
            this.planeMesh.geometry.dispose();
            this.planeMesh.geometry = undefined;
            this.controls.removeFromParent();
            this.controls.dispose();
            this.edges.dispose();
            this.helper.removeFromParent();
        };
        this.planeSize = planeSize;
        this.context = context;
        this.plane = new Plane();
        this.planeMesh = this.getPlaneMesh();
        this.normal = normal;
        this.origin = origin;
        this.helper = this.createHelper();
        this.controls = this.newTransformControls();
        this.setupEvents(onStartDragging, onEndDragging);
        this.plane.setFromNormalAndCoplanarPoint(normal, origin);
        this.edges = new ClippingEdges(this.plane);
        this.edgesActive = edgesEnabled;
    }
    get active() {
        return this.enabled;
    }
    set active(state) {
        this.enabled = state;
        const planes = this.context.getClippingPlanes();
        this.edges.visible = state;
        if (state) {
            planes.push(this.plane);
        }
        else {
            const index = planes.indexOf(this.plane);
            if (index >= 0)
                planes.splice(index);
        }
    }
    get visible() {
        return this.isVisible;
    }
    set visible(state) {
        this.isVisible = state;
        this.controls.visible = state;
        this.helper.visible = state;
        this.edges.visible = state;
    }
    dispose() {
        if (IfcPlane.planeMaterial) {
            IfcPlane.planeMaterial.dispose();
            IfcPlane.planeMaterial = null;
            IfcPlane.planeMaterial = IfcPlane.getPlaneMaterial();
        }
        if (IfcPlane.hiddenMaterial) {
            IfcPlane.hiddenMaterial.dispose();
            IfcPlane.hiddenMaterial = null;
            IfcPlane.hiddenMaterial = IfcPlane.getHiddenMaterial();
        }
        this.removeFromScene();
        this.edges.disposeStylesAndHelpers();
        this.edges = null;
        this.context = null;
    }
    static getPlaneMaterial() {
        return new MeshBasicMaterial({
            color: 0xffff00,
            side: DoubleSide,
            transparent: true,
            opacity: 0.2
        });
    }
    static getHiddenMaterial() {
        return new MeshBasicMaterial({ visible: false });
    }
    newTransformControls() {
        const camera = this.context.getCamera();
        const container = this.context.getDomElement();
        const controls = new TransformControls(camera, container);
        this.initializeControls(controls);
        const scene = this.context.getScene();
        scene.add(controls);
        this.context.renderer.postProduction.excludedItems.add(controls);
        return controls;
    }
    initializeControls(controls) {
        controls.attach(this.helper);
        controls.showX = false;
        controls.showY = false;
        controls.setSpace('local');
        this.createArrowBoundingBox();
        controls.children[0].children[0].add(this.arrowBoundingBox);
    }
    createArrowBoundingBox() {
        this.arrowBoundingBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2);
        this.arrowBoundingBox.material = IfcPlane.hiddenMaterial;
        this.arrowBoundingBox.rotateX(Math.PI / 2);
        this.arrowBoundingBox.updateMatrix();
        this.arrowBoundingBox.geometry.applyMatrix4(this.arrowBoundingBox.matrix);
    }
    setupEvents(onStart, onEnd) {
        this.controls.addEventListener('change', () => {
            if (!this.enabled)
                return;
            this.plane.setFromNormalAndCoplanarPoint(this.normal, this.helper.position);
            if (this.edgesActive)
                this.edges.updateEdges();
        });
        this.controls.addEventListener('dragging-changed', (event) => {
            if (!this.enabled)
                return;
            this.isVisible = !event.value;
            this.context.toggleCameraControls(this.isVisible);
            if (event.value)
                onStart();
            else
                onEnd();
        });
        this.context.ifcCamera.currentNavMode.onChangeProjection.on((camera) => {
            this.controls.camera = camera;
        });
    }
    createHelper() {
        const helper = new Object3D();
        helper.lookAt(this.normal);
        helper.position.copy(this.origin);
        const scene = this.context.getScene();
        scene.add(helper);
        helper.add(this.planeMesh);
        this.context.renderer.postProduction.excludedItems.add(helper);
        return helper;
    }
    getPlaneMesh() {
        const planeGeom = new PlaneGeometry(this.planeSize, this.planeSize, 1);
        return new Mesh(planeGeom, IfcPlane.planeMaterial);
    }
}
IfcPlane.planeMaterial = IfcPlane.getPlaneMaterial();
IfcPlane.hiddenMaterial = IfcPlane.getHiddenMaterial();

[new Vector3(), new Vector3(), new Vector3()];

var UnitType;
(function (UnitType) {
    UnitType["LENGTHUNIT"] = "LENGTHUNIT";
    UnitType["AREAUNIT"] = "AREAUNIT";
    UnitType["VOLUMEUNIT"] = "VOLUMEUNIT";
})(UnitType || (UnitType = {}));

class CSS2DObject extends Object3D {

	constructor( element = document.createElement( 'div' ) ) {

		super();

		this.isCSS2DObject = true;

		this.element = element;

		this.element.style.position = 'absolute';
		this.element.style.userSelect = 'none';

		this.element.setAttribute( 'draggable', false );

		this.addEventListener( 'removed', function () {

			this.traverse( function ( object ) {

				if ( object.element instanceof Element && object.element.parentNode !== null ) {

					object.element.parentNode.removeChild( object.element );

				}

			} );

		} );

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.element = source.element.cloneNode( true );

		return this;

	}

}

//

new Vector3();
new Matrix4();
new Matrix4();
new Vector3();
new Vector3();

class SeparatingAxisBounds {

	constructor() {

		this.min = Infinity;
		this.max = - Infinity;

	}

	setFromPointsField( points, field ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = p[ field ];
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	setFromPoints( axis, points ) {

		let min = Infinity;
		let max = - Infinity;
		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const p = points[ i ];
			const val = axis.dot( p );
			min = val < min ? val : min;
			max = val > max ? val : max;

		}

		this.min = min;
		this.max = max;

	}

	isSeparated( other ) {

		return this.min > other.max || other.min > this.max;

	}

}

SeparatingAxisBounds.prototype.setFromBox = ( function () {

	const p = new Vector3();
	return function setFromBox( axis, box ) {

		const boxMin = box.min;
		const boxMax = box.max;
		let min = Infinity;
		let max = - Infinity;
		for ( let x = 0; x <= 1; x ++ ) {

			for ( let y = 0; y <= 1; y ++ ) {

				for ( let z = 0; z <= 1; z ++ ) {

					p.x = boxMin.x * x + boxMax.x * ( 1 - x );
					p.y = boxMin.y * y + boxMax.y * ( 1 - y );
					p.z = boxMin.z * z + boxMax.z * ( 1 - z );

					const val = axis.dot( p );
					min = Math.min( val, min );
					max = Math.max( val, max );

				}

			}

		}

		this.min = min;
		this.max = max;

	};

} )();

( (function () {

	const cacheSatBounds = new SeparatingAxisBounds();
	return function areIntersecting( shape1, shape2 ) {

		const points1 = shape1.points;
		const satAxes1 = shape1.satAxes;
		const satBounds1 = shape1.satBounds;

		const points2 = shape2.points;
		const satAxes2 = shape2.satAxes;
		const satBounds2 = shape2.satBounds;

		// check axes of the first shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds1[ i ];
			const sa = satAxes1[ i ];
			cacheSatBounds.setFromPoints( sa, points2 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

		// check axes of the second shape
		for ( let i = 0; i < 3; i ++ ) {

			const sb = satBounds2[ i ];
			const sa = satAxes2[ i ];
			cacheSatBounds.setFromPoints( sa, points1 );
			if ( sb.isSeparated( cacheSatBounds ) ) return false;

		}

	};

}) )();

const closestPointLineToLine = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56
	const dir1 = new Vector3();
	const dir2 = new Vector3();
	const v02 = new Vector3();
	return function closestPointLineToLine( l1, l2, result ) {

		const v0 = l1.start;
		const v10 = dir1;
		const v2 = l2.start;
		const v32 = dir2;

		v02.subVectors( v0, v2 );
		dir1.subVectors( l1.end, l1.start );
		dir2.subVectors( l2.end, l2.start );

		// float d0232 = v02.Dot(v32);
		const d0232 = v02.dot( v32 );

		// float d3210 = v32.Dot(v10);
		const d3210 = v32.dot( v10 );

		// float d3232 = v32.Dot(v32);
		const d3232 = v32.dot( v32 );

		// float d0210 = v02.Dot(v10);
		const d0210 = v02.dot( v10 );

		// float d1010 = v10.Dot(v10);
		const d1010 = v10.dot( v10 );

		// float denom = d1010*d3232 - d3210*d3210;
		const denom = d1010 * d3232 - d3210 * d3210;

		let d, d2;
		if ( denom !== 0 ) {

			d = ( d0232 * d3210 - d0210 * d3232 ) / denom;

		} else {

			d = 0;

		}

		d2 = ( d0232 + d * d3210 ) / d3232;

		result.x = d;
		result.y = d2;

	};

} )();

const closestPointsSegmentToSegment = ( function () {

	// https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187
	const paramResult = new Vector2();
	const temp1 = new Vector3();
	const temp2 = new Vector3();
	return function closestPointsSegmentToSegment( l1, l2, target1, target2 ) {

		closestPointLineToLine( l1, l2, paramResult );

		let d = paramResult.x;
		let d2 = paramResult.y;
		if ( d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1 ) {

			l1.at( d, target1 );
			l2.at( d2, target2 );

			return;

		} else if ( d >= 0 && d <= 1 ) {

			// Only d2 is out of bounds.
			if ( d2 < 0 ) {

				l2.at( 0, target2 );

			} else {

				l2.at( 1, target2 );

			}

			l1.closestPointToPoint( target2, true, target1 );
			return;

		} else if ( d2 >= 0 && d2 <= 1 ) {

			// Only d is out of bounds.
			if ( d < 0 ) {

				l1.at( 0, target1 );

			} else {

				l1.at( 1, target1 );

			}

			l2.closestPointToPoint( target1, true, target2 );
			return;

		} else {

			// Both u and u2 are out of bounds.
			let p;
			if ( d < 0 ) {

				p = l1.start;

			} else {

				p = l1.end;

			}

			let p2;
			if ( d2 < 0 ) {

				p2 = l2.start;

			} else {

				p2 = l2.end;

			}

			const closestPoint = temp1;
			const closestPoint2 = temp2;
			l1.closestPointToPoint( p2, true, temp1 );
			l2.closestPointToPoint( p, true, temp2 );

			if ( closestPoint.distanceToSquared( p2 ) <= closestPoint2.distanceToSquared( p ) ) {

				target1.copy( closestPoint );
				target2.copy( p2 );
				return;

			} else {

				target1.copy( p );
				target2.copy( closestPoint2 );
				return;

			}

		}

	};

} )();


const sphereIntersectTriangle = ( function () {

	// https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js
	const closestPointTemp = new Vector3();
	const projectedPointTemp = new Vector3();
	const planeTemp = new Plane();
	const lineTemp = new Line3();
	return function sphereIntersectTriangle( sphere, triangle ) {

		const { radius, center } = sphere;
		const { a, b, c } = triangle;

		// phase 1
		lineTemp.start = a;
		lineTemp.end = b;
		const closestPoint1 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint1.distanceTo( center ) <= radius ) return true;

		lineTemp.start = a;
		lineTemp.end = c;
		const closestPoint2 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint2.distanceTo( center ) <= radius ) return true;

		lineTemp.start = b;
		lineTemp.end = c;
		const closestPoint3 = lineTemp.closestPointToPoint( center, true, closestPointTemp );
		if ( closestPoint3.distanceTo( center ) <= radius ) return true;

		// phase 2
		const plane = triangle.getPlane( planeTemp );
		const dp = Math.abs( plane.distanceToPoint( center ) );
		if ( dp <= radius ) {

			const pp = plane.projectPoint( center, projectedPointTemp );
			const cp = triangle.containsPoint( pp );
			if ( cp ) return true;

		}

		return false;

	};

} )();

const DIST_EPSILON = 1e-15;
function isNearZero( value ) {

	return Math.abs( value ) < DIST_EPSILON;

}

class ExtendedTriangle extends Triangle {

	constructor( ...args ) {

		super( ...args );

		this.isExtendedTriangle = true;
		this.satAxes = new Array( 4 ).fill().map( () => new Vector3() );
		this.satBounds = new Array( 4 ).fill().map( () => new SeparatingAxisBounds() );
		this.points = [ this.a, this.b, this.c ];
		this.sphere = new Sphere();
		this.plane = new Plane();
		this.needsUpdate = true;

	}

	intersectsSphere( sphere ) {

		return sphereIntersectTriangle( sphere, this );

	}

	update() {

		const a = this.a;
		const b = this.b;
		const c = this.c;
		const points = this.points;

		const satAxes = this.satAxes;
		const satBounds = this.satBounds;

		const axis0 = satAxes[ 0 ];
		const sab0 = satBounds[ 0 ];
		this.getNormal( axis0 );
		sab0.setFromPoints( axis0, points );

		const axis1 = satAxes[ 1 ];
		const sab1 = satBounds[ 1 ];
		axis1.subVectors( a, b );
		sab1.setFromPoints( axis1, points );

		const axis2 = satAxes[ 2 ];
		const sab2 = satBounds[ 2 ];
		axis2.subVectors( b, c );
		sab2.setFromPoints( axis2, points );

		const axis3 = satAxes[ 3 ];
		const sab3 = satBounds[ 3 ];
		axis3.subVectors( c, a );
		sab3.setFromPoints( axis3, points );

		this.sphere.setFromPoints( this.points );
		this.plane.setFromNormalAndCoplanarPoint( axis0, a );
		this.needsUpdate = false;

	}

}

ExtendedTriangle.prototype.closestPointToSegment = ( function () {

	const point1 = new Vector3();
	const point2 = new Vector3();
	const edge = new Line3();

	return function distanceToSegment( segment, target1 = null, target2 = null ) {

		const { start, end } = segment;
		const points = this.points;
		let distSq;
		let closestDistanceSq = Infinity;

		// check the triangle edges
		for ( let i = 0; i < 3; i ++ ) {

			const nexti = ( i + 1 ) % 3;
			edge.start.copy( points[ i ] );
			edge.end.copy( points[ nexti ] );

			closestPointsSegmentToSegment( edge, segment, point1, point2 );

			distSq = point1.distanceToSquared( point2 );
			if ( distSq < closestDistanceSq ) {

				closestDistanceSq = distSq;
				if ( target1 ) target1.copy( point1 );
				if ( target2 ) target2.copy( point2 );

			}

		}

		// check end points
		this.closestPointToPoint( start, point1 );
		distSq = start.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( start );

		}

		this.closestPointToPoint( end, point1 );
		distSq = end.distanceToSquared( point1 );
		if ( distSq < closestDistanceSq ) {

			closestDistanceSq = distSq;
			if ( target1 ) target1.copy( point1 );
			if ( target2 ) target2.copy( end );

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

ExtendedTriangle.prototype.intersectsTriangle = ( function () {

	const saTri2 = new ExtendedTriangle();
	const arr1 = new Array( 3 );
	const arr2 = new Array( 3 );
	const cachedSatBounds = new SeparatingAxisBounds();
	const cachedSatBounds2 = new SeparatingAxisBounds();
	const cachedAxis = new Vector3();
	const dir1 = new Vector3();
	const dir2 = new Vector3();
	const tempDir = new Vector3();
	const edge = new Line3();
	const edge1 = new Line3();
	const edge2 = new Line3();

	// TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least
	// be a line contained by both triangles if not a different special case somehow represented in the return result.
	return function intersectsTriangle( other, target = null ) {

		if ( this.needsUpdate ) {

			this.update();

		}

		if ( ! other.isExtendedTriangle ) {

			saTri2.copy( other );
			saTri2.update();
			other = saTri2;

		} else if ( other.needsUpdate ) {

			other.update();

		}

		const plane1 = this.plane;
		const plane2 = other.plane;

		if ( Math.abs( plane1.normal.dot( plane2.normal ) ) > 1.0 - 1e-10 ) {

			// perform separating axis intersection test only for coplanar triangles
			const satBounds1 = this.satBounds;
			const satAxes1 = this.satAxes;
			arr2[ 0 ] = other.a;
			arr2[ 1 ] = other.b;
			arr2[ 2 ] = other.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds1[ i ];
				const sa = satAxes1[ i ];
				cachedSatBounds.setFromPoints( sa, arr2 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			const satBounds2 = other.satBounds;
			const satAxes2 = other.satAxes;
			arr1[ 0 ] = this.a;
			arr1[ 1 ] = this.b;
			arr1[ 2 ] = this.c;
			for ( let i = 0; i < 4; i ++ ) {

				const sb = satBounds2[ i ];
				const sa = satAxes2[ i ];
				cachedSatBounds.setFromPoints( sa, arr1 );
				if ( sb.isSeparated( cachedSatBounds ) ) return false;

			}

			// check crossed axes
			for ( let i = 0; i < 4; i ++ ) {

				const sa1 = satAxes1[ i ];
				for ( let i2 = 0; i2 < 4; i2 ++ ) {

					const sa2 = satAxes2[ i2 ];
					cachedAxis.crossVectors( sa1, sa2 );
					cachedSatBounds.setFromPoints( cachedAxis, arr1 );
					cachedSatBounds2.setFromPoints( cachedAxis, arr2 );
					if ( cachedSatBounds.isSeparated( cachedSatBounds2 ) ) return false;

				}

			}

			if ( target ) {

				// TODO find two points that intersect on the edges and make that the result
				console.warn( 'ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.' );

				target.start.set( 0, 0, 0 );
				target.end.set( 0, 0, 0 );

			}

			return true;

		} else {

			// find the edge that intersects the other triangle plane
			const points1 = this.points;
			let found1 = false;
			let count1 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points1[ i ];
				const pNext = points1[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir1 );

				const targetPoint = found1 ? edge1.start : edge1.end;
				const startIntersects = isNearZero( plane2.distanceToPoint( p ) );
				if ( isNearZero( plane2.normal.dot( dir1 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge1.copy( edge );
					count1 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane2.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count1 ++;
					if ( found1 ) {

						break;

					}

					found1 = true;

				}

			}

			if ( count1 === 1 && this.containsPoint( edge1.end ) ) {

				if ( target ) {

					target.start.copy( edge1.end );
					target.end.copy( edge1.end );

				}

				return true;

			} else if ( count1 !== 2 ) {

				return false;

			}

			// find the other triangles edge that intersects this plane
			const points2 = other.points;
			let found2 = false;
			let count2 = 0;
			for ( let i = 0; i < 3; i ++ ) {

				const p = points2[ i ];
				const pNext = points2[ ( i + 1 ) % 3 ];

				edge.start.copy( p );
				edge.end.copy( pNext );
				edge.delta( dir2 );

				const targetPoint = found2 ? edge2.start : edge2.end;
				const startIntersects = isNearZero( plane1.distanceToPoint( p ) );
				if ( isNearZero( plane1.normal.dot( dir2 ) ) && startIntersects ) {

					// if the edge lies on the plane then take the line
					edge2.copy( edge );
					count2 = 2;
					break;

				}

				// check if the start point is near the plane because "intersectLine" is not robust to that case
				const doesIntersect = plane1.intersectLine( edge, targetPoint ) || startIntersects;
				if ( doesIntersect && ! isNearZero( targetPoint.distanceTo( pNext ) ) ) {

					count2 ++;
					if ( found2 ) {

						break;

					}

					found2 = true;

				}

			}

			if ( count2 === 1 && this.containsPoint( edge2.end ) ) {

				if ( target ) {

					target.start.copy( edge2.end );
					target.end.copy( edge2.end );

				}

				return true;

			} else if ( count2 !== 2 ) {

				return false;

			}

			// find swap the second edge so both lines are running the same direction
			edge1.delta( dir1 );
			edge2.delta( dir2 );

			if ( dir1.dot( dir2 ) < 0 ) {

				let tmp = edge2.start;
				edge2.start = edge2.end;
				edge2.end = tmp;

			}

			// check if the edges are overlapping
			const s1 = edge1.start.dot( dir1 );
			const e1 = edge1.end.dot( dir1 );
			const s2 = edge2.start.dot( dir1 );
			const e2 = edge2.end.dot( dir1 );
			const separated1 = e1 < s2;
			const separated2 = s1 < e2;

			if ( s1 !== e2 && s2 !== e1 && separated1 === separated2 ) {

				return false;

			}

			// assign the target output
			if ( target ) {

				tempDir.subVectors( edge1.start, edge2.start );
				if ( tempDir.dot( dir1 ) > 0 ) {

					target.start.copy( edge1.start );

				} else {

					target.start.copy( edge2.start );

				}

				tempDir.subVectors( edge1.end, edge2.end );
				if ( tempDir.dot( dir1 ) < 0 ) {

					target.end.copy( edge1.end );

				} else {

					target.end.copy( edge2.end );

				}

			}

			return true;

		}

	};

} )();


ExtendedTriangle.prototype.distanceToPoint = ( function () {

	const target = new Vector3();
	return function distanceToPoint( point ) {

		this.closestPointToPoint( point, target );
		return point.distanceTo( target );

	};

} )();


ExtendedTriangle.prototype.distanceToTriangle = ( function () {

	const point = new Vector3();
	const point2 = new Vector3();
	const cornerFields = [ 'a', 'b', 'c' ];
	const line1 = new Line3();
	const line2 = new Line3();

	return function distanceToTriangle( other, target1 = null, target2 = null ) {

		const lineTarget = target1 || target2 ? line1 : null;
		if ( this.intersectsTriangle( other, lineTarget ) ) {

			if ( target1 || target2 ) {

				if ( target1 ) lineTarget.getCenter( target1 );
				if ( target2 ) lineTarget.getCenter( target2 );

			}

			return 0;

		}

		let closestDistanceSq = Infinity;

		// check all point distances
		for ( let i = 0; i < 3; i ++ ) {

			let dist;
			const field = cornerFields[ i ];
			const otherVec = other[ field ];
			this.closestPointToPoint( otherVec, point );

			dist = otherVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( point );
				if ( target2 ) target2.copy( otherVec );

			}


			const thisVec = this[ field ];
			other.closestPointToPoint( thisVec, point );

			dist = thisVec.distanceToSquared( point );

			if ( dist < closestDistanceSq ) {

				closestDistanceSq = dist;
				if ( target1 ) target1.copy( thisVec );
				if ( target2 ) target2.copy( point );

			}

		}

		for ( let i = 0; i < 3; i ++ ) {

			const f11 = cornerFields[ i ];
			const f12 = cornerFields[ ( i + 1 ) % 3 ];
			line1.set( this[ f11 ], this[ f12 ] );
			for ( let i2 = 0; i2 < 3; i2 ++ ) {

				const f21 = cornerFields[ i2 ];
				const f22 = cornerFields[ ( i2 + 1 ) % 3 ];
				line2.set( other[ f21 ], other[ f22 ] );

				closestPointsSegmentToSegment( line1, line2, point, point2 );

				const dist = point.distanceToSquared( point2 );
				if ( dist < closestDistanceSq ) {

					closestDistanceSq = dist;
					if ( target1 ) target1.copy( point );
					if ( target2 ) target2.copy( point2 );

				}

			}

		}

		return Math.sqrt( closestDistanceSq );

	};

} )();

/**
 * @param  {Array<BufferGeometry>} geometries
 * @param  {Boolean} useGroups
 * @return {BufferGeometry}
 */
function mergeBufferGeometries( geometries, useGroups = false ) {

	const isIndexed = geometries[ 0 ].index !== null;

	const attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );
	const morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );

	const attributes = {};
	const morphAttributes = {};

	const morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;

	const mergedGeometry = new BufferGeometry();

	let offset = 0;

	for ( let i = 0; i < geometries.length; ++ i ) {

		const geometry = geometries[ i ];
		let attributesCount = 0;

		// ensure that all geometries are indexed, or none

		if ( isIndexed !== ( geometry.index !== null ) ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );
			return null;

		}

		// gather attributes, exit early if they're different

		for ( const name in geometry.attributes ) {

			if ( ! attributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.' );
				return null;

			}

			if ( attributes[ name ] === undefined ) attributes[ name ] = [];

			attributes[ name ].push( geometry.attributes[ name ] );

			attributesCount ++;

		}

		// ensure geometries have the same number of attributes

		if ( attributesCount !== attributesUsed.size ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );
			return null;

		}

		// gather morph attributes, exit early if they're different

		if ( morphTargetsRelative !== geometry.morphTargetsRelative ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );
			return null;

		}

		for ( const name in geometry.morphAttributes ) {

			if ( ! morphAttributesUsed.has( name ) ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );
				return null;

			}

			if ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];

			morphAttributes[ name ].push( geometry.morphAttributes[ name ] );

		}

		// gather .userData

		mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];
		mergedGeometry.userData.mergedUserData.push( geometry.userData );

		if ( useGroups ) {

			let count;

			if ( isIndexed ) {

				count = geometry.index.count;

			} else if ( geometry.attributes.position !== undefined ) {

				count = geometry.attributes.position.count;

			} else {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );
				return null;

			}

			mergedGeometry.addGroup( offset, count, i );

			offset += count;

		}

	}

	// merge indices

	if ( isIndexed ) {

		let indexOffset = 0;
		const mergedIndex = [];

		for ( let i = 0; i < geometries.length; ++ i ) {

			const index = geometries[ i ].index;

			for ( let j = 0; j < index.count; ++ j ) {

				mergedIndex.push( index.getX( j ) + indexOffset );

			}

			indexOffset += geometries[ i ].attributes.position.count;

		}

		mergedGeometry.setIndex( mergedIndex );

	}

	// merge attributes

	for ( const name in attributes ) {

		const mergedAttribute = mergeBufferAttributes( attributes[ name ] );

		if ( ! mergedAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );
			return null;

		}

		mergedGeometry.setAttribute( name, mergedAttribute );

	}

	// merge morph attributes

	for ( const name in morphAttributes ) {

		const numMorphTargets = morphAttributes[ name ][ 0 ].length;

		if ( numMorphTargets === 0 ) break;

		mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
		mergedGeometry.morphAttributes[ name ] = [];

		for ( let i = 0; i < numMorphTargets; ++ i ) {

			const morphAttributesToMerge = [];

			for ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {

				morphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );

			}

			const mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );

			if ( ! mergedMorphAttribute ) {

				console.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );
				return null;

			}

			mergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );

		}

	}

	return mergedGeometry;

}

/**
 * @param {Array<BufferAttribute>} attributes
 * @return {BufferAttribute}
 */
function mergeBufferAttributes( attributes ) {

	let TypedArray;
	let itemSize;
	let normalized;
	let arrayLength = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		const attribute = attributes[ i ];

		if ( attribute.isInterleavedBufferAttribute ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );
			return null;

		}

		if ( TypedArray === undefined ) TypedArray = attribute.array.constructor;
		if ( TypedArray !== attribute.array.constructor ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );
			return null;

		}

		if ( itemSize === undefined ) itemSize = attribute.itemSize;
		if ( itemSize !== attribute.itemSize ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );
			return null;

		}

		if ( normalized === undefined ) normalized = attribute.normalized;
		if ( normalized !== attribute.normalized ) {

			console.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );
			return null;

		}

		arrayLength += attribute.array.length;

	}

	const array = new TypedArray( arrayLength );
	let offset = 0;

	for ( let i = 0; i < attributes.length; ++ i ) {

		array.set( attributes[ i ].array, offset );

		offset += attributes[ i ].array.length;

	}

	return new BufferAttribute( array, itemSize, normalized );

}

const nullIfcManagerErrorMessage = 'IfcManager is null!';

class IFCModel extends Mesh {

  constructor() {
    super(...arguments);
    this.modelID = IFCModel.modelIdCounter++;
    this.ifcManager = null;
    this.mesh = this;
  }

  static dispose() {
    IFCModel.modelIdCounter = 0;
  }

  setIFCManager(manager) {
    this.ifcManager = manager;
  }

  setWasmPath(path) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    this.ifcManager.setWasmPath(path);
  }

  close(scene) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    this.ifcManager.close(this.modelID, scene);
  }

  getExpressId(geometry, faceIndex) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getExpressId(geometry, faceIndex);
  }

  getAllItemsOfType(type, verbose) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getAllItemsOfType(this.modelID, type, verbose);
  }

  getItemProperties(id, recursive = false) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getItemProperties(this.modelID, id, recursive);
  }

  getPropertySets(id, recursive = false) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getPropertySets(this.modelID, id, recursive);
  }

  getTypeProperties(id, recursive = false) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getTypeProperties(this.modelID, id, recursive);
  }

  getIfcType(id) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getIfcType(this.modelID, id);
  }

  getSpatialStructure() {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getSpatialStructure(this.modelID);
  }

  getSubset(material) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    return this.ifcManager.getSubset(this.modelID, material);
  }

  removeSubset(material, customID) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    this.ifcManager.removeSubset(this.modelID, material, customID);
  }

  createSubset(config) {
    if (this.ifcManager === null)
      throw new Error(nullIfcManagerErrorMessage);
    const modelConfig = {
      ...config,
      modelID: this.modelID
    };
    return this.ifcManager.createSubset(modelConfig);
  }

}

IFCModel.modelIdCounter = 0;

class IFCParser {

  constructor(state, BVH) {
    this.state = state;
    this.BVH = BVH;
    this.loadedModels = 0;
    this.optionalCategories = {
      [IFCSPACE]: true,
      [IFCOPENINGELEMENT]: false
    };
    this.geometriesByMaterials = {};
    this.loadingState = {
      total: 0,
      current: 0,
      step: 0.1
    };
    this.currentWebIfcID = -1;
    this.currentModelID = -1;
  }

  async setupOptionalCategories(config) {
    this.optionalCategories = config;
  }

  async parse(buffer, coordinationMatrix) {
    if (this.state.api.wasmModule === undefined)
      await this.state.api.Init();
    await this.newIfcModel(buffer);
    this.loadedModels++;
    if (coordinationMatrix) {
      await this.state.api.SetGeometryTransformation(this.currentWebIfcID, coordinationMatrix);
    }
    return this.loadAllGeometry(this.currentWebIfcID);
  }

  getAndClearErrors(_modelId) {}

  notifyProgress(loaded, total) {
    if (this.state.onProgress)
      this.state.onProgress({
        loaded,
        total
      });
  }

  async newIfcModel(buffer) {
    const data = new Uint8Array(buffer);
    this.currentWebIfcID = await this.state.api.OpenModel(data, this.state.webIfcSettings);
    this.currentModelID = this.state.useJSON ? this.loadedModels : this.currentWebIfcID;
    this.state.models[this.currentModelID] = {
      modelID: this.currentModelID,
      mesh: {},
      types: {},
      jsonData: {}
    };
  }

  async loadAllGeometry(modelID) {
    this.addOptionalCategories(modelID);
    await this.initializeLoadingState(modelID);
    this.state.api.StreamAllMeshes(modelID, (mesh) => {
      this.updateLoadingState();
      this.streamMesh(modelID, mesh);
    });
    this.notifyLoadingEnded();
    const geometries = [];
    const materials = [];
    Object.keys(this.geometriesByMaterials).forEach((key) => {
      const geometriesByMaterial = this.geometriesByMaterials[key].geometries;
      const merged = mergeBufferGeometries(geometriesByMaterial);
      materials.push(this.geometriesByMaterials[key].material);
      geometries.push(merged);
    });
    const combinedGeometry = mergeBufferGeometries(geometries, true);
    this.cleanUpGeometryMemory(geometries);
    if (this.BVH)
      this.BVH.applyThreeMeshBVH(combinedGeometry);
    const model = new IFCModel(combinedGeometry, materials);
    this.state.models[this.currentModelID].mesh = model;
    return model;
  }

  async initializeLoadingState(modelID) {
    const shapes = await this.state.api.GetLineIDsWithType(modelID, IFCPRODUCTDEFINITIONSHAPE);
    this.loadingState.total = shapes.size();
    this.loadingState.current = 0;
    this.loadingState.step = 0.1;
  }

  notifyLoadingEnded() {
    this.notifyProgress(this.loadingState.total, this.loadingState.total);
  }

  updateLoadingState() {
    const realCurrentItem = Math.min(this.loadingState.current++, this.loadingState.total);
    if (realCurrentItem / this.loadingState.total >= this.loadingState.step) {
      const currentProgress = Math.ceil(this.loadingState.total * this.loadingState.step);
      this.notifyProgress(currentProgress, this.loadingState.total);
      this.loadingState.step += 0.1;
    }
  }

  addOptionalCategories(modelID) {
    const optionalTypes = [];
    for (let key in this.optionalCategories) {
      if (this.optionalCategories.hasOwnProperty(key)) {
        const category = parseInt(key);
        if (this.optionalCategories[category])
          optionalTypes.push(category);
      }
    }
    this.state.api.StreamAllMeshesWithTypes(this.currentWebIfcID, optionalTypes, (mesh) => {
      this.streamMesh(modelID, mesh);
    });
  }

  streamMesh(modelID, mesh) {
    const placedGeometries = mesh.geometries;
    const size = placedGeometries.size();
    for (let i = 0; i < size; i++) {
      const placedGeometry = placedGeometries.get(i);
      let itemMesh = this.getPlacedGeometry(modelID, mesh.expressID, placedGeometry);
      let geom = itemMesh.geometry.applyMatrix4(itemMesh.matrix);
      this.storeGeometryByMaterial(placedGeometry.color, geom);
    }
  }

  getPlacedGeometry(modelID, expressID, placedGeometry) {
    const geometry = this.getBufferGeometry(modelID, expressID, placedGeometry);
    const mesh = new Mesh(geometry);
    mesh.matrix = this.getMeshMatrix(placedGeometry.flatTransformation);
    mesh.matrixAutoUpdate = false;
    return mesh;
  }

  getBufferGeometry(modelID, expressID, placedGeometry) {
    const geometry = this.state.api.GetGeometry(modelID, placedGeometry.geometryExpressID);
    const verts = this.state.api.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());
    const indices = this.state.api.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());
    const buffer = this.ifcGeometryToBuffer(expressID, verts, indices);
    geometry.delete();
    return buffer;
  }

  storeGeometryByMaterial(color, geometry) {
    let colID = `${color.x}${color.y}${color.z}${color.w}`;
    if (this.geometriesByMaterials[colID]) {
      this.geometriesByMaterials[colID].geometries.push(geometry);
      return;
    }
    const col = new Color(color.x, color.y, color.z);
    const material = new MeshLambertMaterial({
      color: col,
      side: DoubleSide
    });
    material.transparent = color.w !== 1;
    if (material.transparent)
      material.opacity = color.w;
    this.geometriesByMaterials[colID] = {
      material,
      geometries: [geometry]
    };
  }

  getMeshMatrix(matrix) {
    const mat = new Matrix4();
    mat.fromArray(matrix);
    return mat;
  }

  ifcGeometryToBuffer(expressID, vertexData, indexData) {
    const geometry = new BufferGeometry();
    const posFloats = new Float32Array(vertexData.length / 2);
    const normFloats = new Float32Array(vertexData.length / 2);
    const idAttribute = new Uint32Array(vertexData.length / 6);
    for (let i = 0; i < vertexData.length; i += 6) {
      posFloats[i / 2] = vertexData[i];
      posFloats[i / 2 + 1] = vertexData[i + 1];
      posFloats[i / 2 + 2] = vertexData[i + 2];
      normFloats[i / 2] = vertexData[i + 3];
      normFloats[i / 2 + 1] = vertexData[i + 4];
      normFloats[i / 2 + 2] = vertexData[i + 5];
      idAttribute[i / 6] = expressID;
    }
    geometry.setAttribute('position', new BufferAttribute(posFloats, 3));
    geometry.setAttribute('normal', new BufferAttribute(normFloats, 3));
    geometry.setAttribute('expressID', new BufferAttribute(idAttribute, 1));
    geometry.setIndex(new BufferAttribute(indexData, 1));
    return geometry;
  }

  cleanUpGeometryMemory(geometries) {
    geometries.forEach(geometry => geometry.dispose());
    Object.keys(this.geometriesByMaterials).forEach((materialID) => {
      const geometriesByMaterial = this.geometriesByMaterials[materialID];
      geometriesByMaterial.geometries.forEach(geometry => geometry.dispose());
      geometriesByMaterial.geometries = [];
      geometriesByMaterial.material = null;
    });
    this.geometriesByMaterials = {};
  }

}

class ItemsMap {

  constructor(state) {
    this.state = state;
    this.map = {};
  }

  generateGeometryIndexMap(modelID) {
    if (this.map[modelID])
      return;
    const geometry = this.getGeometry(modelID);
    const items = this.newItemsMap(modelID, geometry);
    for (const group of geometry.groups) {
      this.fillItemsWithGroupInfo(group, geometry, items);
    }
  }

  getSubsetID(modelID, material, customID = 'DEFAULT') {
    const baseID = modelID;
    const materialID = material ? material.uuid : 'DEFAULT';
    return `${baseID} - ${materialID} - ${customID}`;
  }

  dispose() {
    Object.values(this.map).forEach(model => {
      model.indexCache = null;
      model.map = null;
    });
    this.map = null;
  }

  getGeometry(modelID) {
    const geometry = this.state.models[modelID].mesh.geometry;
    if (!geometry)
      throw new Error('Model without geometry.');
    if (!geometry.index)
      throw new Error('Geometry must be indexed');
    return geometry;
  }

  newItemsMap(modelID, geometry) {
    const startIndices = geometry.index.array;
    this.map[modelID] = {
      indexCache: startIndices.slice(0, geometry.index.array.length),
      map: new Map()
    };
    return this.map[modelID];
  }

  fillItemsWithGroupInfo(group, geometry, items) {
    let prevExpressID = -1;
    const materialIndex = group.materialIndex;
    const materialStart = group.start;
    const materialEnd = materialStart + group.count - 1;
    let objectStart = -1;
    let objectEnd = -1;
    for (let i = materialStart; i <= materialEnd; i++) {
      const index = geometry.index.array[i];
      const expressID = geometry.attributes.expressID.array[index];
      if (prevExpressID === -1) {
        prevExpressID = expressID;
        objectStart = i;
      }
      const isEndOfMaterial = i === materialEnd;
      if (isEndOfMaterial) {
        const store = this.getMaterialStore(items.map, expressID, materialIndex);
        store.push(objectStart, materialEnd);
        break;
      }
      if (prevExpressID === expressID)
        continue;
      const store = this.getMaterialStore(items.map, prevExpressID, materialIndex);
      objectEnd = i - 1;
      store.push(objectStart, objectEnd);
      prevExpressID = expressID;
      objectStart = i;
    }
  }

  getMaterialStore(map, id, matIndex) {
    if (map.get(id) === undefined) {
      map.set(id, {});
    }
    const storedIfcItem = map.get(id);
    if (storedIfcItem === undefined)
      throw new Error('Geometry map generation error');
    if (storedIfcItem[matIndex] === undefined) {
      storedIfcItem[matIndex] = [];
    }
    return storedIfcItem[matIndex];
  }

}

class SubsetUtils {

  static getAllIndicesOfGroup(modelID, ids, materialIndex, items, flatten = true) {
    const indicesByGroup = [];
    for (const expressID of ids) {
      const entry = items.map.get(expressID);
      if (!entry)
        continue;
      const value = entry[materialIndex];
      if (!value)
        continue;
      SubsetUtils.getIndexChunk(value, indicesByGroup, materialIndex, items, flatten);
    }
    return indicesByGroup;
  }

  static getIndexChunk(value, indicesByGroup, materialIndex, items, flatten) {
    const pairs = value.length / 2;
    for (let pair = 0; pair < pairs; pair++) {
      const pairIndex = pair * 2;
      const start = value[pairIndex];
      const end = value[pairIndex + 1];
      for (let j = start; j <= end; j++) {
        if (flatten)
          indicesByGroup.push(items.indexCache[j]);
        else {
          if (!indicesByGroup[materialIndex])
            indicesByGroup[materialIndex] = [];
          indicesByGroup[materialIndex].push(items.indexCache[j]);
        }
      }
    }
  }

}

class SubsetCreator {

  constructor(state, items, subsets, BVH) {
    this.state = state;
    this.items = items;
    this.subsets = subsets;
    this.BVH = BVH;
    this.tempIndex = [];
  }

  createSubset(config, subsetID) {
    if (!this.items.map[config.modelID])
      this.items.generateGeometryIndexMap(config.modelID);
    if (!this.subsets[subsetID])
      this.initializeSubset(config, subsetID);
    this.filterIndices(config, subsetID);
    this.constructSubsetByMaterial(config, subsetID);
    config.ids.forEach(id => this.subsets[subsetID].ids.add(id));
    this.subsets[subsetID].mesh.geometry.setIndex(this.tempIndex);
    this.tempIndex.length = 0;
    const subset = this.subsets[subsetID].mesh;
    if (config.applyBVH)
      this.BVH.applyThreeMeshBVH(subset.geometry);
    if (config.scene)
      config.scene.add(subset);
    return this.subsets[subsetID].mesh;
  }

  dispose() {
    this.tempIndex = [];
  }

  initializeSubset(config, subsetID) {
    const model = this.state.models[config.modelID].mesh;
    const subsetGeom = new BufferGeometry();
    this.initializeSubsetAttributes(subsetGeom, model);
    if (!config.material)
      this.initializeSubsetGroups(subsetGeom, model);
    const mesh = new Mesh(subsetGeom, config.material || model.material);
    mesh.modelID = config.modelID;
    const bvh = Boolean(config.applyBVH);
    this.subsets[subsetID] = {
      ids: new Set(),
      mesh,
      bvh
    };
    model.add(mesh);
  }

  initializeSubsetAttributes(subsetGeom, model) {
    subsetGeom.setAttribute('position', model.geometry.attributes.position);
    subsetGeom.setAttribute('normal', model.geometry.attributes.normal);
    subsetGeom.setAttribute('expressID', model.geometry.attributes.expressID);
    subsetGeom.setIndex([]);
  }

  initializeSubsetGroups(subsetGeom, model) {
    subsetGeom.groups = JSON.parse(JSON.stringify(model.geometry.groups));
    this.resetGroups(subsetGeom);
  }

  filterIndices(config, subsetID) {
    const geometry = this.subsets[subsetID].mesh.geometry;
    if (config.removePrevious) {
      geometry.setIndex([]);
      this.resetGroups(geometry);
      return;
    }
    const previousIndices = geometry.index.array;
    const previousIDs = this.subsets[subsetID].ids;
    config.ids = config.ids.filter(id => !previousIDs.has(id));
    this.tempIndex = Array.from(previousIndices);
  }

  constructSubsetByMaterial(config, subsetID) {
    const model = this.state.models[config.modelID].mesh;
    const newIndices = {
      count: 0
    };
    for (let i = 0; i < model.geometry.groups.length; i++) {
      this.insertNewIndices(config, subsetID, i, newIndices);
    }
  }

  insertNewIndices(config, subsetID, materialIndex, newIndices) {
    const items = this.items.map[config.modelID];
    const indicesOfOneMaterial = SubsetUtils.getAllIndicesOfGroup(config.modelID, config.ids, materialIndex, items);
    if (!config.material) {
      this.insertIndicesAtGroup(subsetID, indicesOfOneMaterial, materialIndex, newIndices);
    } else {
      indicesOfOneMaterial.forEach(index => this.tempIndex.push(index));
    }
  }

  insertIndicesAtGroup(subsetID, indicesByGroup, index, newIndices) {
    const currentGroup = this.getCurrentGroup(subsetID, index);
    currentGroup.start += newIndices.count;
    let newIndicesPosition = currentGroup.start + currentGroup.count;
    newIndices.count += indicesByGroup.length;
    if (indicesByGroup.length > 0) {
      let position = newIndicesPosition;
      const start = this.tempIndex.slice(0, position);
      const end = this.tempIndex.slice(position);
      this.tempIndex = Array.prototype.concat.apply([], [start, indicesByGroup, end]);
      currentGroup.count += indicesByGroup.length;
    }
  }

  getCurrentGroup(subsetID, groupIndex) {
    const geometry = this.subsets[subsetID].mesh.geometry;
    return geometry.groups[groupIndex];
  }

  resetGroups(geometry) {
    geometry.groups.forEach((group) => {
      group.start = 0;
      group.count = 0;
    });
  }

}

class SubsetManager {

  constructor(state, BVH) {
    this.subsets = {};
    this.state = state;
    this.items = new ItemsMap(state);
    this.BVH = BVH;
    this.subsetCreator = new SubsetCreator(state, this.items, this.subsets, this.BVH);
  }

  getAllSubsets() {
    return this.subsets;
  }

  getSubset(modelID, material, customId) {
    const subsetID = this.getSubsetID(modelID, material, customId);
    return this.subsets[subsetID].mesh;
  }

  removeSubset(modelID, material, customID) {
    const subsetID = this.getSubsetID(modelID, material, customID);
    const subset = this.subsets[subsetID];
    if (!subset)
      return;
    if (subset.mesh.parent)
      subset.mesh.removeFromParent();
    subset.mesh.geometry.attributes = {};
    subset.mesh.geometry.index = null;
    subset.mesh.geometry.dispose();
    subset.mesh.geometry = null;
    delete this.subsets[subsetID];
  }

  createSubset(config) {
    const subsetID = this.getSubsetID(config.modelID, config.material, config.customID);
    return this.subsetCreator.createSubset(config, subsetID);
  }

  removeFromSubset(modelID, ids, customID, material) {
    const subsetID = this.getSubsetID(modelID, material, customID);
    if (!this.subsets[subsetID])
      return;
    const previousIDs = this.subsets[subsetID].ids;
    ids.forEach((id) => {
      if (previousIDs.has(id))
        previousIDs.delete(id);
    });
    return this.createSubset({
      modelID,
      removePrevious: true,
      material,
      customID,
      applyBVH: this.subsets[subsetID].bvh,
      ids: Array.from(previousIDs),
      scene: this.subsets[subsetID].mesh.parent
    });
  }

  clearSubset(modelID, customID, material) {
    const subsetID = this.getSubsetID(modelID, material, customID);
    if (!this.subsets[subsetID])
      return;
    this.subsets[subsetID].ids.clear();
    const subset = this.getSubset(modelID, material, customID);
    subset.geometry.setIndex([]);
  }

  dispose() {
    this.items.dispose();
    this.subsetCreator.dispose();
    Object.values(this.subsets).forEach(subset => {
      subset.ids = null;
      subset.mesh.removeFromParent();
      const mats = subset.mesh.material;
      if (Array.isArray(mats))
        mats.forEach(mat => mat.dispose());
      else
        mats.dispose();
      subset.mesh.geometry.index = null;
      subset.mesh.geometry.dispose();
      const geom = subset.mesh.geometry;
      if (geom.disposeBoundsTree)
        geom.disposeBoundsTree();
      subset.mesh = null;
    });
    this.subsets = null;
  }

  getSubsetID(modelID, material, customID = 'DEFAULT') {
    const baseID = modelID;
    const materialID = material ? material.uuid : 'DEFAULT';
    return `${baseID} - ${materialID} - ${customID}`;
  }

}

const IdAttrName = 'expressID';
const PropsNames = {
  aggregates: {
    name: IFCRELAGGREGATES,
    relating: 'RelatingObject',
    related: 'RelatedObjects',
    key: 'children'
  },
  spatial: {
    name: IFCRELCONTAINEDINSPATIALSTRUCTURE,
    relating: 'RelatingStructure',
    related: 'RelatedElements',
    key: 'children'
  },
  psets: {
    name: IFCRELDEFINESBYPROPERTIES,
    relating: 'RelatingPropertyDefinition',
    related: 'RelatedObjects',
    key: 'hasPsets'
  },
  materials: {
    name: IFCRELASSOCIATESMATERIAL,
    relating: 'RelatingMaterial',
    related: 'RelatedObjects',
    key: 'hasMaterial'
  },
  type: {
    name: IFCRELDEFINESBYTYPE,
    relating: 'RelatingType',
    related: 'RelatedObjects',
    key: 'hasType'
  }
};

class BasePropertyManager {

  constructor(state) {
    this.state = state;
  }

  async getPropertySets(modelID, elementID, recursive = false) {
    return await this.getProperty(modelID, elementID, recursive, PropsNames.psets);
  }

  async getTypeProperties(modelID, elementID, recursive = false) {
    return await this.getProperty(modelID, elementID, recursive, PropsNames.type);
  }

  async getMaterialsProperties(modelID, elementID, recursive = false) {
    return await this.getProperty(modelID, elementID, recursive, PropsNames.materials);
  }

  async getSpatialNode(modelID, node, treeChunks, includeProperties) {
    await this.getChildren(modelID, node, treeChunks, PropsNames.aggregates, includeProperties);
    await this.getChildren(modelID, node, treeChunks, PropsNames.spatial, includeProperties);
  }

  async getChildren(modelID, node, treeChunks, propNames, includeProperties) {
    const children = treeChunks[node.expressID];
    if (children == undefined)
      return;
    const prop = propNames.key;
    const nodes = [];
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      let node = this.newNode(modelID, child);
      if (includeProperties) {
        const properties = await this.getItemProperties(modelID, node.expressID);
        node = {
          ...properties, ...node
        };
      }
      await this.getSpatialNode(modelID, node, treeChunks, includeProperties);
      nodes.push(node);
    }
    node[prop] = nodes;
  }

  newNode(modelID, id) {
    const typeName = this.getNodeType(modelID, id);
    return {
      expressID: id,
      type: typeName,
      children: []
    };
  }

  async getSpatialTreeChunks(modelID) {
    const treeChunks = {};
    await this.getChunks(modelID, treeChunks, PropsNames.aggregates);
    await this.getChunks(modelID, treeChunks, PropsNames.spatial);
    return treeChunks;
  }

  saveChunk(chunks, propNames, rel) {
    const relating = rel[propNames.relating].value;
    const related = rel[propNames.related].map((r) => r.value);
    if (chunks[relating] == undefined) {
      chunks[relating] = related;
    } else {
      chunks[relating] = chunks[relating].concat(related);
    }
  }

  getRelated(rel, propNames, IDs) {
    const element = rel[propNames.relating];
    if (!element) {
      return console.warn(`The object with ID ${rel.expressID} has a broken reference.`);
    }
    if (!Array.isArray(element))
      IDs.push(element.value);
    else
      element.forEach((ele) => IDs.push(ele.value));
  }

  static isRelated(id, rel, propNames) {
    const relatedItems = rel[propNames.related];
    if (Array.isArray(relatedItems)) {
      const values = relatedItems.map((item) => item.value);
      return values.includes(id);
    }
    return relatedItems.value === id;
  }

  static newIfcProject(id) {
    return {
      expressID: id,
      type: 'IFCPROJECT',
      children: []
    };
  }

  async getProperty(modelID, elementID, recursive = false, propName) {}

  async getChunks(modelID, chunks, propNames) {}

  async getItemProperties(modelID, expressID, recursive = false) {}

  getNodeType(modelID, id) {}

}

let IfcElements = {
  103090709: 'IFCPROJECT',
  4097777520: 'IFCSITE',
  4031249490: 'IFCBUILDING',
  3124254112: 'IFCBUILDINGSTOREY',
  3856911033: 'IFCSPACE',
  1674181508: 'IFCANNOTATION',
  25142252: 'IFCCONTROLLER',
  32344328: 'IFCBOILER',
  76236018: 'IFCLAMP',
  90941305: 'IFCPUMP',
  177149247: 'IFCAIRTERMINALBOX',
  182646315: 'IFCFLOWINSTRUMENT',
  263784265: 'IFCFURNISHINGELEMENT',
  264262732: 'IFCELECTRICGENERATOR',
  277319702: 'IFCAUDIOVISUALAPPLIANCE',
  310824031: 'IFCPIPEFITTING',
  331165859: 'IFCSTAIR',
  342316401: 'IFCDUCTFITTING',
  377706215: 'IFCMECHANICALFASTENER',
  395920057: 'IFCDOOR',
  402227799: 'IFCELECTRICMOTOR',
  413509423: 'IFCSYSTEMFURNITUREELEMENT',
  484807127: 'IFCEVAPORATOR',
  486154966: 'IFCWINDOWSTANDARDCASE',
  629592764: 'IFCLIGHTFIXTURE',
  630975310: 'IFCUNITARYCONTROLELEMENT',
  635142910: 'IFCCABLECARRIERFITTING',
  639361253: 'IFCCOIL',
  647756555: 'IFCFASTENER',
  707683696: 'IFCFLOWSTORAGEDEVICE',
  738039164: 'IFCPROTECTIVEDEVICE',
  753842376: 'IFCBEAM',
  812556717: 'IFCTANK',
  819412036: 'IFCFILTER',
  843113511: 'IFCCOLUMN',
  862014818: 'IFCELECTRICDISTRIBUTIONBOARD',
  900683007: 'IFCFOOTING',
  905975707: 'IFCCOLUMNSTANDARDCASE',
  926996030: 'IFCVOIDINGFEATURE',
  979691226: 'IFCREINFORCINGBAR',
  987401354: 'IFCFLOWSEGMENT',
  1003880860: 'IFCELECTRICTIMECONTROL',
  1051757585: 'IFCCABLEFITTING',
  1052013943: 'IFCDISTRIBUTIONCHAMBERELEMENT',
  1062813311: 'IFCDISTRIBUTIONCONTROLELEMENT',
  1073191201: 'IFCMEMBER',
  1095909175: 'IFCBUILDINGELEMENTPROXY',
  1156407060: 'IFCPLATESTANDARDCASE',
  1162798199: 'IFCSWITCHINGDEVICE',
  1329646415: 'IFCSHADINGDEVICE',
  1335981549: 'IFCDISCRETEACCESSORY',
  1360408905: 'IFCDUCTSILENCER',
  1404847402: 'IFCSTACKTERMINAL',
  1426591983: 'IFCFIRESUPPRESSIONTERMINAL',
  1437502449: 'IFCMEDICALDEVICE',
  1509553395: 'IFCFURNITURE',
  1529196076: 'IFCSLAB',
  1620046519: 'IFCTRANSPORTELEMENT',
  1634111441: 'IFCAIRTERMINAL',
  1658829314: 'IFCENERGYCONVERSIONDEVICE',
  1677625105: 'IFCCIVILELEMENT',
  1687234759: 'IFCPILE',
  1904799276: 'IFCELECTRICAPPLIANCE',
  1911478936: 'IFCMEMBERSTANDARDCASE',
  1945004755: 'IFCDISTRIBUTIONELEMENT',
  1973544240: 'IFCCOVERING',
  1999602285: 'IFCSPACEHEATER',
  2016517767: 'IFCROOF',
  2056796094: 'IFCAIRTOAIRHEATRECOVERY',
  2058353004: 'IFCFLOWCONTROLLER',
  2068733104: 'IFCHUMIDIFIER',
  2176052936: 'IFCJUNCTIONBOX',
  2188021234: 'IFCFLOWMETER',
  2223149337: 'IFCFLOWTERMINAL',
  2262370178: 'IFCRAILING',
  2272882330: 'IFCCONDENSER',
  2295281155: 'IFCPROTECTIVEDEVICETRIPPINGUNIT',
  2320036040: 'IFCREINFORCINGMESH',
  2347447852: 'IFCTENDONANCHOR',
  2391383451: 'IFCVIBRATIONISOLATOR',
  2391406946: 'IFCWALL',
  2474470126: 'IFCMOTORCONNECTION',
  2769231204: 'IFCVIRTUALELEMENT',
  2814081492: 'IFCENGINE',
  2906023776: 'IFCBEAMSTANDARDCASE',
  2938176219: 'IFCBURNER',
  2979338954: 'IFCBUILDINGELEMENTPART',
  3024970846: 'IFCRAMP',
  3026737570: 'IFCTUBEBUNDLE',
  3027962421: 'IFCSLABSTANDARDCASE',
  3040386961: 'IFCDISTRIBUTIONFLOWELEMENT',
  3053780830: 'IFCSANITARYTERMINAL',
  3079942009: 'IFCOPENINGSTANDARDCASE',
  3087945054: 'IFCALARM',
  3101698114: 'IFCSURFACEFEATURE',
  3127900445: 'IFCSLABELEMENTEDCASE',
  3132237377: 'IFCFLOWMOVINGDEVICE',
  3171933400: 'IFCPLATE',
  3221913625: 'IFCCOMMUNICATIONSAPPLIANCE',
  3242481149: 'IFCDOORSTANDARDCASE',
  3283111854: 'IFCRAMPFLIGHT',
  3296154744: 'IFCCHIMNEY',
  3304561284: 'IFCWINDOW',
  3310460725: 'IFCELECTRICFLOWSTORAGEDEVICE',
  3319311131: 'IFCHEATEXCHANGER',
  3415622556: 'IFCFAN',
  3420628829: 'IFCSOLARDEVICE',
  3493046030: 'IFCGEOGRAPHICELEMENT',
  3495092785: 'IFCCURTAINWALL',
  3508470533: 'IFCFLOWTREATMENTDEVICE',
  3512223829: 'IFCWALLSTANDARDCASE',
  3518393246: 'IFCDUCTSEGMENT',
  3571504051: 'IFCCOMPRESSOR',
  3588315303: 'IFCOPENINGELEMENT',
  3612865200: 'IFCPIPESEGMENT',
  3640358203: 'IFCCOOLINGTOWER',
  3651124850: 'IFCPROJECTIONELEMENT',
  3694346114: 'IFCOUTLET',
  3747195512: 'IFCEVAPORATIVECOOLER',
  3758799889: 'IFCCABLECARRIERSEGMENT',
  3824725483: 'IFCTENDON',
  3825984169: 'IFCTRANSFORMER',
  3902619387: 'IFCCHILLER',
  4074379575: 'IFCDAMPER',
  4086658281: 'IFCSENSOR',
  4123344466: 'IFCELEMENTASSEMBLY',
  4136498852: 'IFCCOOLEDBEAM',
  4156078855: 'IFCWALLELEMENTEDCASE',
  4175244083: 'IFCINTERCEPTOR',
  4207607924: 'IFCVALVE',
  4217484030: 'IFCCABLESEGMENT',
  4237592921: 'IFCWASTETERMINAL',
  4252922144: 'IFCSTAIRFLIGHT',
  4278956645: 'IFCFLOWFITTING',
  4288193352: 'IFCACTUATOR',
  4292641817: 'IFCUNITARYEQUIPMENT',
  3009204131: 'IFCGRID'
};

class WebIfcPropertyManager extends BasePropertyManager {

  async getItemProperties(modelID, id, recursive = false) {
    return this.state.api.GetLine(modelID, id, recursive);
  }

  async getSpatialStructure(modelID, includeProperties) {
    const chunks = await this.getSpatialTreeChunks(modelID);
    const allLines = await this.state.api.GetLineIDsWithType(modelID, IFCPROJECT);
    const projectID = allLines.get(0);
    const project = WebIfcPropertyManager.newIfcProject(projectID);
    await this.getSpatialNode(modelID, project, chunks, includeProperties);
    return project;
  }

  async getAllItemsOfType(modelID, type, verbose) {
    let items = [];
    const lines = await this.state.api.GetLineIDsWithType(modelID, type);
    for (let i = 0; i < lines.size(); i++)
      items.push(lines.get(i));
    if (!verbose)
      return items;
    const result = [];
    for (let i = 0; i < items.length; i++) {
      result.push(await this.state.api.GetLine(modelID, items[i]));
    }
    return result;
  }

  async getProperty(modelID, elementID, recursive = false, propName) {
    const propSetIds = await this.getAllRelatedItemsOfType(modelID, elementID, propName);
    const result = [];
    for (let i = 0; i < propSetIds.length; i++) {
      result.push(await this.state.api.GetLine(modelID, propSetIds[i], recursive));
    }
    return result;
  }

  getNodeType(modelID, id) {
    const typeID = this.state.models[modelID].types[id];
    return IfcElements[typeID];
  }

  async getChunks(modelID, chunks, propNames) {
    const relation = await this.state.api.GetLineIDsWithType(modelID, propNames.name);
    for (let i = 0; i < relation.size(); i++) {
      const rel = await this.state.api.GetLine(modelID, relation.get(i), false);
      this.saveChunk(chunks, propNames, rel);
    }
  }

  async getAllRelatedItemsOfType(modelID, id, propNames) {
    const lines = await this.state.api.GetLineIDsWithType(modelID, propNames.name);
    const IDs = [];
    for (let i = 0; i < lines.size(); i++) {
      const rel = await this.state.api.GetLine(modelID, lines.get(i));
      const isRelated = BasePropertyManager.isRelated(id, rel, propNames);
      if (isRelated)
        this.getRelated(rel, propNames, IDs);
    }
    return IDs;
  }

}

let IfcTypesMap = {
  3821786052: "IFCACTIONREQUEST",
  2296667514: "IFCACTOR",
  3630933823: "IFCACTORROLE",
  4288193352: "IFCACTUATOR",
  2874132201: "IFCACTUATORTYPE",
  618182010: "IFCADDRESS",
  1635779807: "IFCADVANCEDBREP",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  3406155212: "IFCADVANCEDFACE",
  1634111441: "IFCAIRTERMINAL",
  177149247: "IFCAIRTERMINALBOX",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3087945054: "IFCALARM",
  3001207471: "IFCALARMTYPE",
  325726236: "IFCALIGNMENT",
  749761778: "IFCALIGNMENT2DHORIZONTAL",
  3199563722: "IFCALIGNMENT2DHORIZONTALSEGMENT",
  2483840362: "IFCALIGNMENT2DSEGMENT",
  3379348081: "IFCALIGNMENT2DVERSEGCIRCULARARC",
  3239324667: "IFCALIGNMENT2DVERSEGLINE",
  4263986512: "IFCALIGNMENT2DVERSEGPARABOLICARC",
  53199957: "IFCALIGNMENT2DVERTICAL",
  2029264950: "IFCALIGNMENT2DVERTICALSEGMENT",
  3512275521: "IFCALIGNMENTCURVE",
  1674181508: "IFCANNOTATION",
  669184980: "IFCANNOTATIONFILLAREA",
  639542469: "IFCAPPLICATION",
  411424972: "IFCAPPLIEDVALUE",
  130549933: "IFCAPPROVAL",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  3460190687: "IFCASSET",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4261334040: "IFCAXIS1PLACEMENT",
  3125803723: "IFCAXIS2PLACEMENT2D",
  2740243338: "IFCAXIS2PLACEMENT3D",
  1967976161: "IFCBSPLINECURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  753842376: "IFCBEAM",
  2906023776: "IFCBEAMSTANDARDCASE",
  819618141: "IFCBEAMTYPE",
  4196446775: "IFCBEARING",
  3649138523: "IFCBEARINGTYPE",
  616511568: "IFCBLOBTEXTURE",
  1334484129: "IFCBLOCK",
  32344328: "IFCBOILER",
  231477066: "IFCBOILERTYPE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  2736907675: "IFCBOOLEANRESULT",
  4037036970: "IFCBOUNDARYCONDITION",
  1136057603: "IFCBOUNDARYCURVE",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1387855156: "IFCBOUNDARYNODECONDITION",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1260505505: "IFCBOUNDEDCURVE",
  4182860854: "IFCBOUNDEDSURFACE",
  2581212453: "IFCBOUNDINGBOX",
  2713105998: "IFCBOXEDHALFSPACE",
  644574406: "IFCBRIDGE",
  963979645: "IFCBRIDGEPART",
  4031249490: "IFCBUILDING",
  3299480353: "IFCBUILDINGELEMENT",
  2979338954: "IFCBUILDINGELEMENTPART",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  3124254112: "IFCBUILDINGSTOREY",
  1177604601: "IFCBUILDINGSYSTEM",
  2938176219: "IFCBURNER",
  2188180465: "IFCBURNERTYPE",
  2898889636: "IFCCSHAPEPROFILEDEF",
  635142910: "IFCCABLECARRIERFITTING",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  1051757585: "IFCCABLEFITTING",
  2674252688: "IFCCABLEFITTINGTYPE",
  4217484030: "IFCCABLESEGMENT",
  1285652485: "IFCCABLESEGMENTTYPE",
  3999819293: "IFCCAISSONFOUNDATION",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  1123145078: "IFCCARTESIANPOINT",
  574549367: "IFCCARTESIANPOINTLIST",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  3902619387: "IFCCHILLER",
  2951183804: "IFCCHILLERTYPE",
  3296154744: "IFCCHIMNEY",
  2197970202: "IFCCHIMNEYTYPE",
  2611217952: "IFCCIRCLE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1062206242: "IFCCIRCULARARCSEGMENT2D",
  1677625105: "IFCCIVILELEMENT",
  3893394355: "IFCCIVILELEMENTTYPE",
  747523909: "IFCCLASSIFICATION",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  2205249479: "IFCCLOSEDSHELL",
  639361253: "IFCCOIL",
  2301859152: "IFCCOILTYPE",
  776857604: "IFCCOLOURRGB",
  3285139300: "IFCCOLOURRGBLIST",
  3264961684: "IFCCOLOURSPECIFICATION",
  843113511: "IFCCOLUMN",
  905975707: "IFCCOLUMNSTANDARDCASE",
  300633059: "IFCCOLUMNTYPE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  2542286263: "IFCCOMPLEXPROPERTY",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3732776249: "IFCCOMPOSITECURVE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  3571504051: "IFCCOMPRESSOR",
  3850581409: "IFCCOMPRESSORTYPE",
  2272882330: "IFCCONDENSER",
  2816379211: "IFCCONDENSERTYPE",
  2510884976: "IFCCONIC",
  370225590: "IFCCONNECTEDFACESET",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  1959218052: "IFCCONSTRAINT",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  3293443760: "IFCCONTROL",
  25142252: "IFCCONTROLLER",
  578613899: "IFCCONTROLLERTYPE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  4136498852: "IFCCOOLEDBEAM",
  335055490: "IFCCOOLEDBEAMTYPE",
  3640358203: "IFCCOOLINGTOWER",
  2954562838: "IFCCOOLINGTOWERTYPE",
  1785450214: "IFCCOORDINATEOPERATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  3895139033: "IFCCOSTITEM",
  1419761937: "IFCCOSTSCHEDULE",
  602808272: "IFCCOSTVALUE",
  1973544240: "IFCCOVERING",
  1916426348: "IFCCOVERINGTYPE",
  3295246426: "IFCCREWRESOURCE",
  1815067380: "IFCCREWRESOURCETYPE",
  2506170314: "IFCCSGPRIMITIVE3D",
  2147822146: "IFCCSGSOLID",
  539742890: "IFCCURRENCYRELATIONSHIP",
  3495092785: "IFCCURTAINWALL",
  1457835157: "IFCCURTAINWALLTYPE",
  2601014836: "IFCCURVE",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1186437898: "IFCCURVESEGMENT2D",
  3800577675: "IFCCURVESTYLE",
  1105321065: "IFCCURVESTYLEFONT",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  1213902940: "IFCCYLINDRICALSURFACE",
  4074379575: "IFCDAMPER",
  3961806047: "IFCDAMPERTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  3632507154: "IFCDERIVEDPROFILEDEF",
  1765591967: "IFCDERIVEDUNIT",
  1045800335: "IFCDERIVEDUNITELEMENT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  32440307: "IFCDIRECTION",
  1335981549: "IFCDISCRETEACCESSORY",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1945343521: "IFCDISTANCEEXPRESSION",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3041715199: "IFCDISTRIBUTIONPORT",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  1154170062: "IFCDOCUMENTINFORMATION",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  3732053477: "IFCDOCUMENTREFERENCE",
  395920057: "IFCDOOR",
  2963535650: "IFCDOORLININGPROPERTIES",
  1714330368: "IFCDOORPANELPROPERTIES",
  3242481149: "IFCDOORSTANDARDCASE",
  526551008: "IFCDOORSTYLE",
  2323601079: "IFCDOORTYPE",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  342316401: "IFCDUCTFITTING",
  869906466: "IFCDUCTFITTINGTYPE",
  3518393246: "IFCDUCTSEGMENT",
  3760055223: "IFCDUCTSEGMENTTYPE",
  1360408905: "IFCDUCTSILENCER",
  2030761528: "IFCDUCTSILENCERTYPE",
  3900360178: "IFCEDGE",
  476780140: "IFCEDGECURVE",
  1472233963: "IFCEDGELOOP",
  1904799276: "IFCELECTRICAPPLIANCE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  264262732: "IFCELECTRICGENERATOR",
  1534661035: "IFCELECTRICGENERATORTYPE",
  402227799: "IFCELECTRICMOTOR",
  1217240411: "IFCELECTRICMOTORTYPE",
  1003880860: "IFCELECTRICTIMECONTROL",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1758889154: "IFCELEMENT",
  4123344466: "IFCELEMENTASSEMBLY",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  339256511: "IFCELEMENTTYPE",
  2777663545: "IFCELEMENTARYSURFACE",
  1704287377: "IFCELLIPSE",
  2835456948: "IFCELLIPSEPROFILEDEF",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  2814081492: "IFCENGINE",
  132023988: "IFCENGINETYPE",
  3747195512: "IFCEVAPORATIVECOOLER",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  484807127: "IFCEVAPORATOR",
  3390157468: "IFCEVAPORATORTYPE",
  4148101412: "IFCEVENT",
  211053100: "IFCEVENTTIME",
  4024345920: "IFCEVENTTYPE",
  297599258: "IFCEXTENDEDPROPERTIES",
  4294318154: "IFCEXTERNALINFORMATION",
  3200245327: "IFCEXTERNALREFERENCE",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  477187591: "IFCEXTRUDEDAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  2556980723: "IFCFACE",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  1809719519: "IFCFACEBOUND",
  803316827: "IFCFACEOUTERBOUND",
  3008276851: "IFCFACESURFACE",
  807026263: "IFCFACETEDBREP",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  24185140: "IFCFACILITY",
  1310830890: "IFCFACILITYPART",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3415622556: "IFCFAN",
  346874300: "IFCFANTYPE",
  647756555: "IFCFASTENER",
  2489546625: "IFCFASTENERTYPE",
  2827207264: "IFCFEATUREELEMENT",
  2143335405: "IFCFEATUREELEMENTADDITION",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  738692330: "IFCFILLAREASTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  315944413: "IFCFILLAREASTYLETILES",
  819412036: "IFCFILTER",
  1810631287: "IFCFILTERTYPE",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2058353004: "IFCFLOWCONTROLLER",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  4278956645: "IFCFLOWFITTING",
  3198132628: "IFCFLOWFITTINGTYPE",
  182646315: "IFCFLOWINSTRUMENT",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  2188021234: "IFCFLOWMETER",
  3815607619: "IFCFLOWMETERTYPE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  987401354: "IFCFLOWSEGMENT",
  1834744321: "IFCFLOWSEGMENTTYPE",
  707683696: "IFCFLOWSTORAGEDEVICE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  2223149337: "IFCFLOWTERMINAL",
  2297155007: "IFCFLOWTERMINALTYPE",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  900683007: "IFCFOOTING",
  1893162501: "IFCFOOTINGTYPE",
  263784265: "IFCFURNISHINGELEMENT",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  1509553395: "IFCFURNITURE",
  1268542332: "IFCFURNITURETYPE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  987898635: "IFCGEOMETRICCURVESET",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  3590301190: "IFCGEOMETRICSET",
  3009204131: "IFCGRID",
  852622518: "IFCGRIDAXIS",
  178086475: "IFCGRIDPLACEMENT",
  2706460486: "IFCGROUP",
  812098782: "IFCHALFSPACESOLID",
  3319311131: "IFCHEATEXCHANGER",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2068733104: "IFCHUMIDIFIER",
  1806887404: "IFCHUMIDIFIERTYPE",
  1484403080: "IFCISHAPEPROFILEDEF",
  3905492369: "IFCIMAGETEXTURE",
  3570813810: "IFCINDEXEDCOLOURMAP",
  2571569899: "IFCINDEXEDPOLYCURVE",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  4175244083: "IFCINTERCEPTOR",
  3946677679: "IFCINTERCEPTORTYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  2391368822: "IFCINVENTORY",
  3741457305: "IFCIRREGULARTIMESERIES",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  2176052936: "IFCJUNCTIONBOX",
  4288270099: "IFCJUNCTIONBOXTYPE",
  572779678: "IFCLSHAPEPROFILEDEF",
  3827777499: "IFCLABORRESOURCE",
  428585644: "IFCLABORRESOURCETYPE",
  1585845231: "IFCLAGTIME",
  76236018: "IFCLAMP",
  1051575348: "IFCLAMPTYPE",
  2655187982: "IFCLIBRARYINFORMATION",
  3452421091: "IFCLIBRARYREFERENCE",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  629592764: "IFCLIGHTFIXTURE",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  1402838566: "IFCLIGHTSOURCE",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  3422422726: "IFCLIGHTSOURCESPOT",
  1281925730: "IFCLINE",
  3092502836: "IFCLINESEGMENT2D",
  388784114: "IFCLINEARPLACEMENT",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2624227202: "IFCLOCALPLACEMENT",
  1008929658: "IFCLOOP",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  3057273783: "IFCMAPCONVERSION",
  2347385850: "IFCMAPPEDITEM",
  1838606355: "IFCMATERIAL",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  3708119000: "IFCMATERIALCONSTITUENT",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  760658860: "IFCMATERIALDEFINITION",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  248100487: "IFCMATERIALLAYER",
  3303938423: "IFCMATERIALLAYERSET",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  2199411900: "IFCMATERIALLIST",
  2235152071: "IFCMATERIALPROFILE",
  164193824: "IFCMATERIALPROFILESET",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  3265635763: "IFCMATERIALPROPERTIES",
  853536259: "IFCMATERIALRELATIONSHIP",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  2597039031: "IFCMEASUREWITHUNIT",
  377706215: "IFCMECHANICALFASTENER",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  1437502449: "IFCMEDICALDEVICE",
  1114901282: "IFCMEDICALDEVICETYPE",
  1073191201: "IFCMEMBER",
  1911478936: "IFCMEMBERSTANDARDCASE",
  3181161470: "IFCMEMBERTYPE",
  3368373690: "IFCMETRIC",
  2998442950: "IFCMIRROREDPROFILEDEF",
  2706619895: "IFCMONETARYUNIT",
  2474470126: "IFCMOTORCONNECTION",
  977012517: "IFCMOTORCONNECTIONTYPE",
  1918398963: "IFCNAMEDUNIT",
  3888040117: "IFCOBJECT",
  219451334: "IFCOBJECTDEFINITION",
  3701648758: "IFCOBJECTPLACEMENT",
  2251480897: "IFCOBJECTIVE",
  4143007308: "IFCOCCUPANT",
  590820931: "IFCOFFSETCURVE",
  3388369263: "IFCOFFSETCURVE2D",
  3505215534: "IFCOFFSETCURVE3D",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  2665983363: "IFCOPENSHELL",
  3588315303: "IFCOPENINGELEMENT",
  3079942009: "IFCOPENINGSTANDARDCASE",
  4251960020: "IFCORGANIZATION",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  643959842: "IFCORIENTATIONEXPRESSION",
  1029017970: "IFCORIENTEDEDGE",
  144952367: "IFCOUTERBOUNDARYCURVE",
  3694346114: "IFCOUTLET",
  2837617999: "IFCOUTLETTYPE",
  1207048766: "IFCOWNERHISTORY",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  2519244187: "IFCPATH",
  1682466193: "IFCPCURVE",
  2382730787: "IFCPERFORMANCEHISTORY",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3327091369: "IFCPERMIT",
  2077209135: "IFCPERSON",
  101040310: "IFCPERSONANDORGANIZATION",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  1687234759: "IFCPILE",
  1158309216: "IFCPILETYPE",
  310824031: "IFCPIPEFITTING",
  804291784: "IFCPIPEFITTINGTYPE",
  3612865200: "IFCPIPESEGMENT",
  4231323485: "IFCPIPESEGMENTTYPE",
  597895409: "IFCPIXELTEXTURE",
  2004835150: "IFCPLACEMENT",
  603570806: "IFCPLANARBOX",
  1663979128: "IFCPLANAREXTENT",
  220341763: "IFCPLANE",
  3171933400: "IFCPLATE",
  1156407060: "IFCPLATESTANDARDCASE",
  4017108033: "IFCPLATETYPE",
  2067069095: "IFCPOINT",
  4022376103: "IFCPOINTONCURVE",
  1423911732: "IFCPOINTONSURFACE",
  2924175390: "IFCPOLYLOOP",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2839578677: "IFCPOLYGONALFACESET",
  3724593414: "IFCPOLYLINE",
  3740093272: "IFCPORT",
  1946335990: "IFCPOSITIONINGELEMENT",
  3355820592: "IFCPOSTALADDRESS",
  759155922: "IFCPREDEFINEDCOLOUR",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  3727388367: "IFCPREDEFINEDITEM",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  677532197: "IFCPRESENTATIONITEM",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  3119450353: "IFCPRESENTATIONSTYLE",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  2744685151: "IFCPROCEDURE",
  569719735: "IFCPROCEDURETYPE",
  2945172077: "IFCPROCESS",
  4208778838: "IFCPRODUCT",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  2095639259: "IFCPRODUCTREPRESENTATION",
  3958567839: "IFCPROFILEDEF",
  2802850158: "IFCPROFILEPROPERTIES",
  103090709: "IFCPROJECT",
  653396225: "IFCPROJECTLIBRARY",
  2904328755: "IFCPROJECTORDER",
  3843373140: "IFCPROJECTEDCRS",
  3651124850: "IFCPROJECTIONELEMENT",
  2598011224: "IFCPROPERTY",
  986844984: "IFCPROPERTYABSTRACTION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  3710013099: "IFCPROPERTYENUMERATION",
  2752243245: "IFCPROPERTYLISTVALUE",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  1451395588: "IFCPROPERTYSET",
  3357820518: "IFCPROPERTYSETDEFINITION",
  492091185: "IFCPROPERTYSETTEMPLATE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  110355661: "IFCPROPERTYTABLEVALUE",
  3521284610: "IFCPROPERTYTEMPLATE",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  738039164: "IFCPROTECTIVEDEVICE",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3219374653: "IFCPROXY",
  90941305: "IFCPUMP",
  2250791053: "IFCPUMPTYPE",
  2044713172: "IFCQUANTITYAREA",
  2093928680: "IFCQUANTITYCOUNT",
  931644368: "IFCQUANTITYLENGTH",
  2090586900: "IFCQUANTITYSET",
  3252649465: "IFCQUANTITYTIME",
  2405470396: "IFCQUANTITYVOLUME",
  825690147: "IFCQUANTITYWEIGHT",
  2262370178: "IFCRAILING",
  2893384427: "IFCRAILINGTYPE",
  3024970846: "IFCRAMP",
  3283111854: "IFCRAMPFLIGHT",
  2324767716: "IFCRAMPFLIGHTTYPE",
  1469900589: "IFCRAMPTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  2798486643: "IFCRECTANGULARPYRAMID",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  3915482550: "IFCRECURRENCEPATTERN",
  2433181523: "IFCREFERENCE",
  4021432810: "IFCREFERENT",
  3413951693: "IFCREGULARTIMESERIES",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  979691226: "IFCREINFORCINGBAR",
  2572171363: "IFCREINFORCINGBARTYPE",
  3027567501: "IFCREINFORCINGELEMENT",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  2320036040: "IFCREINFORCINGMESH",
  2310774935: "IFCREINFORCINGMESHTYPE",
  160246688: "IFCRELAGGREGATES",
  3939117080: "IFCRELASSIGNS",
  1683148259: "IFCRELASSIGNSTOACTOR",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1307041759: "IFCRELASSIGNSTOGROUP",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  205026976: "IFCRELASSIGNSTORESOURCE",
  1865459582: "IFCRELASSOCIATES",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  826625072: "IFCRELCONNECTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3190031847: "IFCRELCONNECTSPORTS",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  2802773753: "IFCRELCOVERSSPACES",
  2565941209: "IFCRELDECLARES",
  2551354335: "IFCRELDECOMPOSES",
  693640335: "IFCRELDEFINES",
  1462361463: "IFCRELDEFINESBYOBJECT",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  781010003: "IFCRELDEFINESBYTYPE",
  3940055652: "IFCRELFILLSELEMENT",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  427948657: "IFCRELINTERFERESELEMENTS",
  3268803585: "IFCRELNESTS",
  1441486842: "IFCRELPOSITIONS",
  750771296: "IFCRELPROJECTSELEMENT",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  4122056220: "IFCRELSEQUENCE",
  366585022: "IFCRELSERVICESBUILDINGS",
  3451746338: "IFCRELSPACEBOUNDARY",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  1401173127: "IFCRELVOIDSELEMENT",
  478536968: "IFCRELATIONSHIP",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1076942058: "IFCREPRESENTATION",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  3008791417: "IFCREPRESENTATIONITEM",
  1660063152: "IFCREPRESENTATIONMAP",
  2914609552: "IFCRESOURCE",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  1042787934: "IFCRESOURCETIME",
  1856042241: "IFCREVOLVEDAREASOLID",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  4158566097: "IFCRIGHTCIRCULARCONE",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  2016517767: "IFCROOF",
  2781568857: "IFCROOFTYPE",
  2341007311: "IFCROOT",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  448429030: "IFCSIUNIT",
  3053780830: "IFCSANITARYTERMINAL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  1054537805: "IFCSCHEDULINGTIME",
  2157484638: "IFCSEAMCURVE",
  2042790032: "IFCSECTIONPROPERTIES",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  1862484736: "IFCSECTIONEDSOLID",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1509187699: "IFCSECTIONEDSPINE",
  4086658281: "IFCSENSOR",
  1783015770: "IFCSENSORTYPE",
  1329646415: "IFCSHADINGDEVICE",
  4074543187: "IFCSHADINGDEVICETYPE",
  867548509: "IFCSHAPEASPECT",
  3982875396: "IFCSHAPEMODEL",
  4240577450: "IFCSHAPEREPRESENTATION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  3692461612: "IFCSIMPLEPROPERTY",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  4097777520: "IFCSITE",
  1529196076: "IFCSLAB",
  3127900445: "IFCSLABELEMENTEDCASE",
  3027962421: "IFCSLABSTANDARDCASE",
  2533589738: "IFCSLABTYPE",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  3420628829: "IFCSOLARDEVICE",
  1072016465: "IFCSOLARDEVICETYPE",
  723233188: "IFCSOLIDMODEL",
  3856911033: "IFCSPACE",
  1999602285: "IFCSPACEHEATER",
  1305183839: "IFCSPACEHEATERTYPE",
  3812236995: "IFCSPACETYPE",
  1412071761: "IFCSPATIALELEMENT",
  710998568: "IFCSPATIALELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  463610769: "IFCSPATIALZONE",
  2481509218: "IFCSPATIALZONETYPE",
  451544542: "IFCSPHERE",
  4015995234: "IFCSPHERICALSURFACE",
  1404847402: "IFCSTACKTERMINAL",
  3112655638: "IFCSTACKTERMINALTYPE",
  331165859: "IFCSTAIR",
  4252922144: "IFCSTAIRFLIGHT",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  338393293: "IFCSTAIRTYPE",
  682877961: "IFCSTRUCTURALACTION",
  3544373492: "IFCSTRUCTURALACTIVITY",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  1179482911: "IFCSTRUCTURALCONNECTION",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  3136571912: "IFCSTRUCTURALITEM",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2162789131: "IFCSTRUCTURALLOAD",
  385403989: "IFCSTRUCTURALLOADCASE",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  530289379: "IFCSTRUCTURALMEMBER",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  3689010777: "IFCSTRUCTURALREACTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  2830218821: "IFCSTYLEMODEL",
  3958052878: "IFCSTYLEDITEM",
  3049322572: "IFCSTYLEDREPRESENTATION",
  148013059: "IFCSUBCONTRACTRESOURCE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  2233826070: "IFCSUBEDGE",
  2513912981: "IFCSURFACE",
  699246055: "IFCSURFACECURVE",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  3101698114: "IFCSURFACEFEATURE",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  1300840506: "IFCSURFACESTYLE",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  1878645084: "IFCSURFACESTYLERENDERING",
  846575682: "IFCSURFACESTYLESHADING",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  626085974: "IFCSURFACETEXTURE",
  2247615214: "IFCSWEPTAREASOLID",
  1260650574: "IFCSWEPTDISKSOLID",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  230924584: "IFCSWEPTSURFACE",
  1162798199: "IFCSWITCHINGDEVICE",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  2254336722: "IFCSYSTEM",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  3071757647: "IFCTSHAPEPROFILEDEF",
  985171141: "IFCTABLE",
  2043862942: "IFCTABLECOLUMN",
  531007025: "IFCTABLEROW",
  812556717: "IFCTANK",
  5716631: "IFCTANKTYPE",
  3473067441: "IFCTASK",
  1549132990: "IFCTASKTIME",
  2771591690: "IFCTASKTIMERECURRING",
  3206491090: "IFCTASKTYPE",
  912023232: "IFCTELECOMADDRESS",
  3824725483: "IFCTENDON",
  2347447852: "IFCTENDONANCHOR",
  3081323446: "IFCTENDONANCHORTYPE",
  3663046924: "IFCTENDONCONDUIT",
  2281632017: "IFCTENDONCONDUITTYPE",
  2415094496: "IFCTENDONTYPE",
  2387106220: "IFCTESSELLATEDFACESET",
  901063453: "IFCTESSELLATEDITEM",
  4282788508: "IFCTEXTLITERAL",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  1447204868: "IFCTEXTSTYLE",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  280115917: "IFCTEXTURECOORDINATE",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  2552916305: "IFCTEXTUREMAP",
  1210645708: "IFCTEXTUREVERTEX",
  3611470254: "IFCTEXTUREVERTEXLIST",
  1199560280: "IFCTIMEPERIOD",
  3101149627: "IFCTIMESERIES",
  581633288: "IFCTIMESERIESVALUE",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1935646853: "IFCTOROIDALSURFACE",
  3825984169: "IFCTRANSFORMER",
  1692211062: "IFCTRANSFORMERTYPE",
  2595432518: "IFCTRANSITIONCURVESEGMENT2D",
  1620046519: "IFCTRANSPORTELEMENT",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  2916149573: "IFCTRIANGULATEDFACESET",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3593883385: "IFCTRIMMEDCURVE",
  3026737570: "IFCTUBEBUNDLE",
  1600972822: "IFCTUBEBUNDLETYPE",
  1628702193: "IFCTYPEOBJECT",
  3736923433: "IFCTYPEPROCESS",
  2347495698: "IFCTYPEPRODUCT",
  3698973494: "IFCTYPERESOURCE",
  427810014: "IFCUSHAPEPROFILEDEF",
  180925521: "IFCUNITASSIGNMENT",
  630975310: "IFCUNITARYCONTROLELEMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  4292641817: "IFCUNITARYEQUIPMENT",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  4207607924: "IFCVALVE",
  728799441: "IFCVALVETYPE",
  1417489154: "IFCVECTOR",
  2799835756: "IFCVERTEX",
  2759199220: "IFCVERTEXLOOP",
  1907098498: "IFCVERTEXPOINT",
  1530820697: "IFCVIBRATIONDAMPER",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  2391383451: "IFCVIBRATIONISOLATOR",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  926996030: "IFCVOIDINGFEATURE",
  2391406946: "IFCWALL",
  4156078855: "IFCWALLELEMENTEDCASE",
  3512223829: "IFCWALLSTANDARDCASE",
  1898987631: "IFCWALLTYPE",
  4237592921: "IFCWASTETERMINAL",
  1133259667: "IFCWASTETERMINALTYPE",
  3304561284: "IFCWINDOW",
  336235671: "IFCWINDOWLININGPROPERTIES",
  512836454: "IFCWINDOWPANELPROPERTIES",
  486154966: "IFCWINDOWSTANDARDCASE",
  1299126871: "IFCWINDOWSTYLE",
  4009809668: "IFCWINDOWTYPE",
  4088093105: "IFCWORKCALENDAR",
  1028945134: "IFCWORKCONTROL",
  4218914973: "IFCWORKPLAN",
  3342526732: "IFCWORKSCHEDULE",
  1236880293: "IFCWORKTIME",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1033361043: "IFCZONE",
};

class JSONPropertyManager extends BasePropertyManager {

  async getItemProperties(modelID, id, recursive = false) {
    return {
      ...this.state.models[modelID].jsonData[id]
    };
  }

  async getSpatialStructure(modelID, includeProperties) {
    const chunks = await this.getSpatialTreeChunks(modelID);
    const projectsIDs = await this.getAllItemsOfType(modelID, IFCPROJECT, false);
    const projectID = projectsIDs[0];
    const project = JSONPropertyManager.newIfcProject(projectID);
    await this.getSpatialNode(modelID, project, chunks, includeProperties);
    return {
      ...project
    };
  }

  async getAllItemsOfType(modelID, type, verbose) {
    const data = this.state.models[modelID].jsonData;
    const typeName = IfcTypesMap[type];
    if (!typeName) {
      throw new Error(`Type not found: ${type}`);
    }
    return this.filterItemsByType(data, typeName, verbose);
  }

  async getProperty(modelID, elementID, recursive = false, propName) {
    const resultIDs = await this.getAllRelatedItemsOfType(modelID, elementID, propName);
    const result = this.getItemsByID(modelID, resultIDs);
    if (recursive) {
      result.forEach(result => this.getReferencesRecursively(modelID, result));
    }
    return result;
  }

  getNodeType(modelID, id) {
    return this.state.models[modelID].jsonData[id].type;
  }

  async getChunks(modelID, chunks, propNames) {
    const relation = await this.getAllItemsOfType(modelID, propNames.name, true);
    relation.forEach(rel => {
      this.saveChunk(chunks, propNames, rel);
    });
  }

  filterItemsByType(data, typeName, verbose) {
    const result = [];
    Object.keys(data).forEach(key => {
      const numKey = parseInt(key);
      if (data[numKey].type.toUpperCase() === typeName) {
        result.push(verbose ? {
          ...data[numKey]
        } : numKey);
      }
    });
    return result;
  }

  async getAllRelatedItemsOfType(modelID, id, propNames) {
    const lines = await this.getAllItemsOfType(modelID, propNames.name, true);
    const IDs = [];
    lines.forEach(line => {
      const isRelated = JSONPropertyManager.isRelated(id, line, propNames);
      if (isRelated)
        this.getRelated(line, propNames, IDs);
    });
    return IDs;
  }

  getItemsByID(modelID, ids) {
    const data = this.state.models[modelID].jsonData;
    const result = [];
    ids.forEach(id => result.push({
      ...data[id]
    }));
    return result;
  }

  getReferencesRecursively(modelID, jsonObject) {
    if (jsonObject == undefined)
      return;
    const keys = Object.keys(jsonObject);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.getJSONItem(modelID, jsonObject, key);
    }
  }

  getJSONItem(modelID, jsonObject, key) {
    if (Array.isArray(jsonObject[key])) {
      return this.getMultipleJSONItems(modelID, jsonObject, key);
    }
    if (jsonObject[key] && jsonObject[key].type === 5) {
      jsonObject[key] = this.getItemsByID(modelID, [jsonObject[key].value])[0];
      this.getReferencesRecursively(modelID, jsonObject[key]);
    }
  }

  getMultipleJSONItems(modelID, jsonObject, key) {
    jsonObject[key] = jsonObject[key].map((item) => {
      if (item.type === 5) {
        item = this.getItemsByID(modelID, [item.value])[0];
        this.getReferencesRecursively(modelID, item);
      }
      return item;
    });
  }

}

class PropertyManager {

  constructor(state) {
    this.state = state;
    this.webIfcProps = new WebIfcPropertyManager(state);
    this.jsonProps = new JSONPropertyManager(state);
    this.currentProps = this.webIfcProps;
  }

  getExpressId(geometry, faceIndex) {
    if (!geometry.index)
      throw new Error('Geometry does not have index information.');
    const geoIndex = geometry.index.array;
    return geometry.attributes[IdAttrName].getX(geoIndex[3 * faceIndex]);
  }

  async getItemProperties(modelID, elementID, recursive = false) {
    this.updateCurrentProps();
    return this.currentProps.getItemProperties(modelID, elementID, recursive);
  }

  async getAllItemsOfType(modelID, type, verbose) {
    this.updateCurrentProps();
    return this.currentProps.getAllItemsOfType(modelID, type, verbose);
  }

  async getPropertySets(modelID, elementID, recursive = false) {
    this.updateCurrentProps();
    return this.currentProps.getPropertySets(modelID, elementID, recursive);
  }

  async getTypeProperties(modelID, elementID, recursive = false) {
    this.updateCurrentProps();
    return this.currentProps.getTypeProperties(modelID, elementID, recursive);
  }

  async getMaterialsProperties(modelID, elementID, recursive = false) {
    this.updateCurrentProps();
    return this.currentProps.getMaterialsProperties(modelID, elementID, recursive);
  }

  async getSpatialStructure(modelID, includeProperties) {
    this.updateCurrentProps();
    if (!this.state.useJSON && includeProperties) {
      console.warn('Including properties in getSpatialStructure with the JSON workflow disabled can lead to poor performance.');
    }
    return await this.currentProps.getSpatialStructure(modelID, includeProperties);
  }

  updateCurrentProps() {
    this.currentProps = this.state.useJSON ? this.jsonProps : this.webIfcProps;
  }

}

class TypeManager {

  constructor(state) {
    this.state = state;
    this.state = state;
  }

  async getAllTypes(worker) {
    for (let modelID in this.state.models) {
      if (this.state.models.hasOwnProperty(modelID)) {
        const types = this.state.models[modelID].types;
        if (Object.keys(types).length == 0) {
          await this.getAllTypesOfModel(parseInt(modelID), worker);
        }
      }
    }
  }

  async getAllTypesOfModel(modelID, worker) {
    const result = {};
    const elements = Object.keys(IfcElements).map((e) => parseInt(e));
    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];
      const lines = await this.state.api.GetLineIDsWithType(modelID, element);
      const size = lines.size();
      for (let i = 0; i < size; i++)
        result[lines.get(i)] = element;
    }
    if (this.state.worker.active && worker) {
      await worker.workerState.updateModelStateTypes(modelID, result);
    }
    this.state.models[modelID].types = result;
  }

}

class BvhManager {

  initializeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast) {
    this.computeBoundsTree = computeBoundsTree;
    this.disposeBoundsTree = disposeBoundsTree;
    this.acceleratedRaycast = acceleratedRaycast;
    this.setupThreeMeshBVH();
  }

  applyThreeMeshBVH(geometry) {
    if (this.computeBoundsTree)
      geometry.computeBoundsTree();
  }

  setupThreeMeshBVH() {
    if (!this.computeBoundsTree || !this.disposeBoundsTree || !this.acceleratedRaycast)
      return;
    BufferGeometry.prototype.computeBoundsTree = this.computeBoundsTree;
    BufferGeometry.prototype.disposeBoundsTree = this.disposeBoundsTree;
    Mesh.prototype.raycast = this.acceleratedRaycast;
  }

}

var WorkerActions;
(function(WorkerActions) {
  WorkerActions["updateStateUseJson"] = "updateStateUseJson";
  WorkerActions["updateStateWebIfcSettings"] = "updateStateWebIfcSettings";
  WorkerActions["updateModelStateTypes"] = "updateModelStateTypes";
  WorkerActions["updateModelStateJsonData"] = "updateModelStateJsonData";
  WorkerActions["loadJsonDataFromWorker"] = "loadJsonDataFromWorker";
  WorkerActions["dispose"] = "dispose";
  WorkerActions["Close"] = "Close";
  WorkerActions["DisposeWebIfc"] = "DisposeWebIfc";
  WorkerActions["Init"] = "Init";
  WorkerActions["OpenModel"] = "OpenModel";
  WorkerActions["CreateModel"] = "CreateModel";
  WorkerActions["ExportFileAsIFC"] = "ExportFileAsIFC";
  WorkerActions["GetGeometry"] = "GetGeometry";
  WorkerActions["GetLine"] = "GetLine";
  WorkerActions["GetAndClearErrors"] = "GetAndClearErrors";
  WorkerActions["WriteLine"] = "WriteLine";
  WorkerActions["FlattenLine"] = "FlattenLine";
  WorkerActions["GetRawLineData"] = "GetRawLineData";
  WorkerActions["WriteRawLineData"] = "WriteRawLineData";
  WorkerActions["GetLineIDsWithType"] = "GetLineIDsWithType";
  WorkerActions["GetAllLines"] = "GetAllLines";
  WorkerActions["SetGeometryTransformation"] = "SetGeometryTransformation";
  WorkerActions["GetCoordinationMatrix"] = "GetCoordinationMatrix";
  WorkerActions["GetVertexArray"] = "GetVertexArray";
  WorkerActions["GetIndexArray"] = "GetIndexArray";
  WorkerActions["getSubArray"] = "getSubArray";
  WorkerActions["CloseModel"] = "CloseModel";
  WorkerActions["StreamAllMeshes"] = "StreamAllMeshes";
  WorkerActions["StreamAllMeshesWithTypes"] = "StreamAllMeshesWithTypes";
  WorkerActions["IsModelOpen"] = "IsModelOpen";
  WorkerActions["LoadAllGeometry"] = "LoadAllGeometry";
  WorkerActions["GetFlatMesh"] = "GetFlatMesh";
  WorkerActions["SetWasmPath"] = "SetWasmPath";
  WorkerActions["parse"] = "parse";
  WorkerActions["setupOptionalCategories"] = "setupOptionalCategories";
  WorkerActions["getExpressId"] = "getExpressId";
  WorkerActions["initializeProperties"] = "initializeProperties";
  WorkerActions["getAllItemsOfType"] = "getAllItemsOfType";
  WorkerActions["getItemProperties"] = "getItemProperties";
  WorkerActions["getMaterialsProperties"] = "getMaterialsProperties";
  WorkerActions["getPropertySets"] = "getPropertySets";
  WorkerActions["getSpatialStructure"] = "getSpatialStructure";
  WorkerActions["getTypeProperties"] = "getTypeProperties";
})(WorkerActions || (WorkerActions = {}));
var WorkerAPIs;
(function(WorkerAPIs) {
  WorkerAPIs["workerState"] = "workerState";
  WorkerAPIs["webIfc"] = "webIfc";
  WorkerAPIs["properties"] = "properties";
  WorkerAPIs["parser"] = "parser";
})(WorkerAPIs || (WorkerAPIs = {}));

class Vector {

  constructor(vector) {
    this._data = {};
    this._size = vector.size;
    const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));
    keys.forEach((key) => this._data[key] = vector[key]);
  }

  size() {
    return this._size;
  }

  get(index) {
    return this._data[index];
  }

}

class IfcGeometry {

  constructor(vector) {
    this._GetVertexData = vector.GetVertexData;
    this._GetVertexDataSize = vector.GetVertexDataSize;
    this._GetIndexData = vector.GetIndexData;
    this._GetIndexDataSize = vector.GetIndexDataSize;
  }

  GetVertexData() {
    return this._GetVertexData;
  }

  GetVertexDataSize() {
    return this._GetVertexDataSize;
  }

  GetIndexData() {
    return this._GetIndexData;
  }

  GetIndexDataSize() {
    return this._GetIndexDataSize;
  }

}

class FlatMesh {

  constructor(serializer, flatMesh) {
    this.expressID = flatMesh.expressID;
    this.geometries = serializer.reconstructVector(flatMesh.geometries);
  }

}

class FlatMeshVector {

  constructor(serializer, vector) {
    this._data = {};
    this._size = vector.size;
    const keys = Object.keys(vector).filter((key) => key.indexOf('size') === -1).map(key => parseInt(key));
    keys.forEach(key => this._data[key] = serializer.reconstructFlatMesh(vector[key]));
  }

  size() {
    return this._size;
  }

  get(index) {
    return this._data[index];
  }

}

class SerializedMaterial {

  constructor(material) {
    this.color = [material.color.r, material.color.g, material.color.b];
    this.opacity = material.opacity;
    this.transparent = material.transparent;
  }

}

class MaterialReconstructor {

  static new(material) {
    return new MeshLambertMaterial({
      color: new Color(material.color[0], material.color[1], material.color[2]),
      opacity: material.opacity,
      transparent: material.transparent,
      side: DoubleSide
    });
  }

}

class SerializedGeometry {

  constructor(geometry) {
    var _a,
      _b,
      _c,
      _d;
    this.position = ((_a = geometry.attributes.position) === null || _a === void 0 ? void 0 : _a.array) || [];
    this.normal = ((_b = geometry.attributes.normal) === null || _b === void 0 ? void 0 : _b.array) || [];
    this.expressID = ((_c = geometry.attributes.expressID) === null || _c === void 0 ? void 0 : _c.array) || [];
    this.index = ((_d = geometry.index) === null || _d === void 0 ? void 0 : _d.array) || [];
    this.groups = geometry.groups;
  }

}

class GeometryReconstructor {

  static new(serialized) {
    const geom = new BufferGeometry();
    GeometryReconstructor.set(geom, 'expressID', new Uint32Array(serialized.expressID), 1);
    GeometryReconstructor.set(geom, 'position', new Float32Array(serialized.position), 3);
    GeometryReconstructor.set(geom, 'normal', new Float32Array(serialized.normal), 3);
    geom.setIndex(Array. from (serialized.index));
    geom.groups = serialized.groups;
    return geom;
  }

  static set(geom, name, data, size) {
    if (data.length > 0) {
      geom.setAttribute(name, new BufferAttribute(data, size));
    }
  }

}

class SerializedMesh {

  constructor(model) {
    this.materials = [];
    this.modelID = model.modelID;
    this.geometry = new SerializedGeometry(model.geometry);
    if (Array.isArray(model.material)) {
      model.material.forEach(mat => {
        this.materials.push(new SerializedMaterial(mat));
      });
    } else {
      this.materials.push(new SerializedMaterial(model.material));
    }
  }

}

class MeshReconstructor {

  static new(serialized) {
    const model = new IFCModel();
    model.modelID = serialized.modelID;
    model.geometry = GeometryReconstructor.new(serialized.geometry);
    MeshReconstructor.getMaterials(serialized, model);
    return model;
  }

  static getMaterials(serialized, model) {
    model.material = [];
    const mats = model.material;
    serialized.materials.forEach(mat => {
      mats.push(MaterialReconstructor.new(mat));
    });
  }

}

class Serializer {

  serializeVector(vector) {
    const size = vector.size();
    const serialized = {
      size
    };
    for (let i = 0; i < size; i++) {
      serialized[i] = vector.get(i);
    }
    return serialized;
  }

  reconstructVector(vector) {
    return new Vector(vector);
  }

  serializeIfcGeometry(geometry) {
    const GetVertexData = geometry.GetVertexData();
    const GetVertexDataSize = geometry.GetVertexDataSize();
    const GetIndexData = geometry.GetIndexData();
    const GetIndexDataSize = geometry.GetIndexDataSize();
    return {
      GetVertexData,
      GetVertexDataSize,
      GetIndexData,
      GetIndexDataSize
    };
  }

  reconstructIfcGeometry(geometry) {
    return new IfcGeometry(geometry);
  }

  serializeFlatMesh(flatMesh) {
    return {
      expressID: flatMesh.expressID,
      geometries: this.serializeVector(flatMesh.geometries)
    };
  }

  reconstructFlatMesh(flatMesh) {
    return new FlatMesh(this, flatMesh);
  }

  serializeFlatMeshVector(vector) {
    const size = vector.size();
    const serialized = {
      size
    };
    for (let i = 0; i < size; i++) {
      const flatMesh = vector.get(i);
      serialized[i] = this.serializeFlatMesh(flatMesh);
    }
    return serialized;
  }

  reconstructFlatMeshVector(vector) {
    return new FlatMeshVector(this, vector);
  }

  serializeIfcModel(model) {
    return new SerializedMesh(model);
  }

  reconstructIfcModel(model) {
    return MeshReconstructor.new(model);
  }

}

class PropertyHandler {

  constructor(handler) {
    this.handler = handler;
    this.API = WorkerAPIs.properties;
  }

  getExpressId(geometry, faceIndex) {
    if (!geometry.index)
      throw new Error('Geometry does not have index information.');
    const geoIndex = geometry.index.array;
    return geometry.attributes[IdAttrName].getX(geoIndex[3 * faceIndex]);
  }

  getAllItemsOfType(modelID, type, verbose) {
    return this.handler.request(this.API, WorkerActions.getAllItemsOfType, {
      modelID,
      type,
      verbose
    });
  }

  getItemProperties(modelID, elementID, recursive) {
    return this.handler.request(this.API, WorkerActions.getItemProperties, {
      modelID,
      elementID,
      recursive
    });
  }

  getMaterialsProperties(modelID, elementID, recursive) {
    return this.handler.request(this.API, WorkerActions.getMaterialsProperties, {
      modelID,
      elementID,
      recursive
    });
  }

  getPropertySets(modelID, elementID, recursive) {
    return this.handler.request(this.API, WorkerActions.getPropertySets, {
      modelID,
      elementID,
      recursive
    });
  }

  getTypeProperties(modelID, elementID, recursive) {
    return this.handler.request(this.API, WorkerActions.getTypeProperties, {
      modelID,
      elementID,
      recursive
    });
  }

  getSpatialStructure(modelID, includeProperties) {
    return this.handler.request(this.API, WorkerActions.getSpatialStructure, {
      modelID,
      includeProperties
    });
  }

}

class WebIfcHandler {

  constructor(handler, serializer) {
    this.handler = handler;
    this.serializer = serializer;
    this.API = WorkerAPIs.webIfc;
  }

  async Init() {
    this.wasmModule = true;
    return this.handler.request(this.API, WorkerActions.Init);
  }

  async OpenModel(data, settings) {
    return this.handler.request(this.API, WorkerActions.OpenModel, {
      data,
      settings
    });
  }

  async CreateModel(settings) {
    return this.handler.request(this.API, WorkerActions.CreateModel, {
      settings
    });
  }

  async ExportFileAsIFC(modelID) {
    return this.handler.request(this.API, WorkerActions.ExportFileAsIFC, {
      modelID
    });
  }

  async GetGeometry(modelID, geometryExpressID) {
    this.handler.serializeHandlers[this.handler.requestID] = (geom) => {
      return this.serializer.reconstructIfcGeometry(geom);
    };
    return this.handler.request(this.API, WorkerActions.GetGeometry, {
      modelID,
      geometryExpressID
    });
  }

  async GetLine(modelID, expressID, flatten) {
    return this.handler.request(this.API, WorkerActions.GetLine, {
      modelID,
      expressID,
      flatten
    });
  }

  async GetAndClearErrors(modelID) {
    this.handler.serializeHandlers[this.handler.requestID] = (vector) => {
      return this.serializer.reconstructVector(vector);
    };
    return this.handler.request(this.API, WorkerActions.GetAndClearErrors, {
      modelID
    });
  }

  async WriteLine(modelID, lineObject) {
    return this.handler.request(this.API, WorkerActions.WriteLine, {
      modelID,
      lineObject
    });
  }

  async FlattenLine(modelID, line) {
    return this.handler.request(this.API, WorkerActions.FlattenLine, {
      modelID,
      line
    });
  }

  async GetRawLineData(modelID, expressID) {
    return this.handler.request(this.API, WorkerActions.GetRawLineData, {
      modelID,
      expressID
    });
  }

  async WriteRawLineData(modelID, data) {
    return this.handler.request(this.API, WorkerActions.WriteRawLineData, {
      modelID,
      data
    });
  }

  async GetLineIDsWithType(modelID, type) {
    this.handler.serializeHandlers[this.handler.requestID] = (vector) => {
      return this.serializer.reconstructVector(vector);
    };
    return this.handler.request(this.API, WorkerActions.GetLineIDsWithType, {
      modelID,
      type
    });
  }

  async GetAllLines(modelID) {
    this.handler.serializeHandlers[this.handler.requestID] = (vector) => {
      return this.serializer.reconstructVector(vector);
    };
    return this.handler.request(this.API, WorkerActions.GetAllLines, {
      modelID
    });
  }

  async SetGeometryTransformation(modelID, transformationMatrix) {
    return this.handler.request(this.API, WorkerActions.SetGeometryTransformation, {
      modelID,
      transformationMatrix
    });
  }

  async GetCoordinationMatrix(modelID) {
    return this.handler.request(this.API, WorkerActions.GetCoordinationMatrix, {
      modelID
    });
  }

  async GetVertexArray(ptr, size) {
    return this.handler.request(this.API, WorkerActions.GetVertexArray, {
      ptr,
      size
    });
  }

  async GetIndexArray(ptr, size) {
    return this.handler.request(this.API, WorkerActions.GetIndexArray, {
      ptr,
      size
    });
  }

  async getSubArray(heap, startPtr, sizeBytes) {
    return this.handler.request(this.API, WorkerActions.getSubArray, {
      heap,
      startPtr,
      sizeBytes
    });
  }

  async CloseModel(modelID) {
    return this.handler.request(this.API, WorkerActions.CloseModel, {
      modelID
    });
  }

  async StreamAllMeshes(modelID, meshCallback) {
    this.handler.callbackHandlers[this.handler.requestID] = {
      action: meshCallback,
      serializer: this.serializer.reconstructFlatMesh
    };
    return this.handler.request(this.API, WorkerActions.StreamAllMeshes, {
      modelID
    });
  }

  async StreamAllMeshesWithTypes(modelID, types, meshCallback) {
    this.handler.callbackHandlers[this.handler.requestID] = {
      action: meshCallback,
      serializer: this.serializer.reconstructFlatMesh
    };
    return this.handler.request(this.API, WorkerActions.StreamAllMeshesWithTypes, {
      modelID,
      types
    });
  }

  async IsModelOpen(modelID) {
    return this.handler.request(this.API, WorkerActions.IsModelOpen, {
      modelID
    });
  }

  async LoadAllGeometry(modelID) {
    this.handler.serializeHandlers[this.handler.requestID] = (vector) => {
      return this.serializer.reconstructFlatMeshVector(vector);
    };
    return this.handler.request(this.API, WorkerActions.LoadAllGeometry, {
      modelID
    });
  }

  async GetFlatMesh(modelID, expressID) {
    this.handler.serializeHandlers[this.handler.requestID] = (flatMesh) => {
      return this.serializer.reconstructFlatMesh(flatMesh);
    };
    return this.handler.request(this.API, WorkerActions.GetFlatMesh, {
      modelID,
      expressID
    });
  }

  async SetWasmPath(path) {
    return this.handler.request(this.API, WorkerActions.SetWasmPath, {
      path
    });
  }

}

class WorkerStateHandler {

  constructor(handler) {
    this.handler = handler;
    this.API = WorkerAPIs.workerState;
    this.state = this.handler.state;
  }

  async updateStateUseJson() {
    const useJson = this.state.useJSON;
    return this.handler.request(this.API, WorkerActions.updateStateUseJson, {
      useJson
    });
  }

  async updateStateWebIfcSettings() {
    const webIfcSettings = this.state.webIfcSettings;
    return this.handler.request(this.API, WorkerActions.updateStateWebIfcSettings, {
      webIfcSettings
    });
  }

  async updateModelStateTypes(modelID, types) {
    return this.handler.request(this.API, WorkerActions.updateModelStateTypes, {
      modelID,
      types
    });
  }

  async updateModelStateJsonData(modelID, jsonData) {
    return this.handler.request(this.API, WorkerActions.updateModelStateJsonData, {
      modelID,
      jsonData
    });
  }

  async loadJsonDataFromWorker(modelID, path) {
    return this.handler.request(this.API, WorkerActions.loadJsonDataFromWorker, {
      modelID,
      path
    });
  }

}

var DBOperation;
(function(DBOperation) {
  DBOperation[DBOperation["transferIfcModel"] = 0] = "transferIfcModel";
  DBOperation[DBOperation["transferIndividualItems"] = 1] = "transferIndividualItems";
})(DBOperation || (DBOperation = {}));

class IndexedDatabase {

  async save(item, id) {
    const open = IndexedDatabase.openOrCreateDB(id);
    this.createSchema(open, id);
    return new Promise((resolve, reject) => {
      open.onsuccess = () => this.saveItem(item, open, id, resolve);
    });
  }

  async load(id) {
    const open = IndexedDatabase.openOrCreateDB(id);
    return new Promise((resolve, reject) => {
      open.onsuccess = () => this.loadItem(open, id, resolve);
    });
  }

  createSchema(open, id) {
    open.onupgradeneeded = function() {
      const db = open.result;
      db.createObjectStore(id.toString(), {
        keyPath: "id"
      });
    };
  }

  saveItem(item, open, id, resolve) {
    const {db, tx, store} = IndexedDatabase.getDBItems(open, id);
    item.id = id;
    store.put(item);
    tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, resolve);
  }

  loadItem(open, id, resolve) {
    const {db, tx, store} = IndexedDatabase.getDBItems(open, id);
    const item = store.get(id);
    const callback = () => {
      delete item.result.id;
      resolve(item.result);
    };
    tx.oncomplete = () => IndexedDatabase.closeDB(db, tx, callback);
  }

  static getDBItems(open, id) {
    const db = open.result;
    const tx = db.transaction(id.toString(), "readwrite");
    const store = tx.objectStore(id.toString());
    return {
      db,
      tx,
      store
    };
  }

  static openOrCreateDB(id) {
    return indexedDB.open(id.toString(), 1);
  }

  static closeDB(db, tx, resolve) {
    db.close();
    resolve("success");
  }

}

class ParserHandler {

  constructor(handler, serializer, BVH, IDB) {
    this.handler = handler;
    this.serializer = serializer;
    this.BVH = BVH;
    this.IDB = IDB;
    this.optionalCategories = {
      [IFCSPACE]: true,
      [IFCOPENINGELEMENT]: false
    };
    this.API = WorkerAPIs.parser;
  }

  async setupOptionalCategories(config) {
    this.optionalCategories = config;
    return this.handler.request(this.API, WorkerActions.setupOptionalCategories, {
      config
    });
  }

  async parse(buffer, coordinationMatrix) {
    this.handler.onprogressHandlers[this.handler.requestID] = (progress) => {
      if (this.handler.state.onProgress)
        this.handler.state.onProgress(progress);
    };
    this.handler.serializeHandlers[this.handler.requestID] = async (result) => {
      this.updateState(result.modelID);
      return this.getModel();
    };
    return this.handler.request(this.API, WorkerActions.parse, {
      buffer,
      coordinationMatrix
    });
  }

  getAndClearErrors(_modelId) {}

  updateState(modelID) {
    this.handler.state.models[modelID] = {
      modelID: modelID,
      mesh: {},
      types: {},
      jsonData: {}
    };
  }

  async getModel() {
    const serializedModel = await this.IDB.load(DBOperation.transferIfcModel);
    const model = this.serializer.reconstructIfcModel(serializedModel);
    this.BVH.applyThreeMeshBVH(model.geometry);
    this.handler.state.models[model.modelID].mesh = model;
    return model;
  }

}

class IFCWorkerHandler {

  constructor(state, BVH) {
    this.state = state;
    this.BVH = BVH;
    this.requestID = 0;
    this.rejectHandlers = {};
    this.resolveHandlers = {};
    this.serializeHandlers = {};
    this.callbackHandlers = {};
    this.onprogressHandlers = {};
    this.serializer = new Serializer();
    this.IDB = new IndexedDatabase();
    this.workerPath = this.state.worker.path;
    this.ifcWorker = new Worker(this.workerPath);
    this.ifcWorker.onmessage = (data) => this.handleResponse(data);
    this.properties = new PropertyHandler(this);
    this.parser = new ParserHandler(this, this.serializer, this.BVH, this.IDB);
    this.webIfc = new WebIfcHandler(this, this.serializer);
    this.workerState = new WorkerStateHandler(this);
  }

  request(worker, action, args) {
    const data = {
      worker,
      action,
      args,
      id: this.requestID,
      result: undefined,
      onProgress: false
    };
    return new Promise((resolve, reject) => {
      this.resolveHandlers[this.requestID] = resolve;
      this.rejectHandlers[this.requestID] = reject;
      this.requestID++;
      this.ifcWorker.postMessage(data);
    });
  }

  async terminate() {
    await this.request(WorkerAPIs.workerState, WorkerActions.dispose);
    await this.request(WorkerAPIs.webIfc, WorkerActions.DisposeWebIfc);
    this.ifcWorker.terminate();
  }

  async Close() {
    await this.request(WorkerAPIs.webIfc, WorkerActions.Close);
  }

  handleResponse(event) {
    const data = event.data;
    if (data.onProgress) {
      this.resolveOnProgress(data);
      return;
    }
    this.callHandlers(data);
    delete this.resolveHandlers[data.id];
    delete this.rejectHandlers[data.id];
    delete this.onprogressHandlers[data.id];
  }

  callHandlers(data) {
    try {
      this.resolveSerializations(data);
      this.resolveCallbacks(data);
      this.resolveHandlers[data.id](data.result);
    } catch (error) {
      this.rejectHandlers[data.id](error);
    }
  }

  resolveOnProgress(data) {
    if (this.onprogressHandlers[data.id]) {
      data.result = this.onprogressHandlers[data.id](data.result);
    }
  }

  resolveSerializations(data) {
    if (this.serializeHandlers[data.id]) {
      data.result = this.serializeHandlers[data.id](data.result);
      delete this.serializeHandlers[data.id];
    }
  }

  resolveCallbacks(data) {
    if (this.callbackHandlers[data.id]) {
      let callbackParameter = data.result;
      if (this.callbackHandlers[data.id].serializer) {
        callbackParameter = this.callbackHandlers[data.id].serializer(data.result);
      }
      this.callbackHandlers[data.id].action(callbackParameter);
    }
  }

}

class MemoryCleaner {

  constructor(state) {
    this.state = state;
  }

  async dispose() {
    Object.keys(this.state.models).forEach(modelID => {
      const model = this.state.models[parseInt(modelID, 10)];
      model.mesh.removeFromParent();
      const geom = model.mesh.geometry;
      if (geom.disposeBoundsTree)
        geom.disposeBoundsTree();
      geom.dispose();
      if (!Array.isArray(model.mesh.material))
        model.mesh.material.dispose();
      else
        model.mesh.material.forEach(mat => mat.dispose());
      model.mesh = null;
      model.types = null;
      model.jsonData = null;
    });
    this.state.api = null;
    this.state.models = null;
  }

}

class IFCUtils {

  constructor(state) {
    this.state = state;
    this.map = {};
  }

  getMapping() {
    this.map = this.reverseElementMapping(IfcTypesMap);
  }

  releaseMapping() {
    this.map = {};
  }

  reverseElementMapping(obj) {
    let reverseElement = {};
    Object.keys(obj).forEach(key => {
      reverseElement[obj[key]] = key;
    });
    return reverseElement;
  }

  isA(entity, entity_class) {
    var test = false;
    if (entity_class) {
      if (IfcTypesMap[entity.type] === entity_class.toUpperCase()) {
        test = true;
      }
      return test;
    } else {
      return IfcTypesMap[entity.type];
    }
  }

  async byId(modelID, id) {
    return this.state.api.GetLine(modelID, id);
  }

  async idsByType(modelID, entity_class) {
    this.getMapping();
    let entities_ids = await this.state.api.GetLineIDsWithType(modelID, Number(this.map[entity_class.toUpperCase()]));
    this.releaseMapping();
    return entities_ids;
  }

  async byType(modelID, entity_class) {
    let entities_ids = await this.idsByType(modelID, entity_class);
    if (entities_ids !== null) {
      this.getMapping();
      let items = [];
      for (let i = 0; i < entities_ids.size(); i++) {
        let entity = await this.byId(modelID, entities_ids.get(i));
        items.push(entity);
      }
      this.releaseMapping();
      return items;
    }
  }

}

class Data {

  constructor(state) {
    this.state = state;
    this.isLoaded = false;
    this.workPlans = {};
    this.workSchedules = {};
    this.workCalendars = {};
    this.workTimes = {};
    this.recurrencePatterns = {};
    this.timePeriods = {};
    this.tasks = {};
    this.taskTimes = {};
    this.lagTimes = {};
    this.sequences = {};
    this.utils = new IFCUtils(this.state);
  }

  async load(modelID) {
    await this.loadTasks(modelID);
    await this.loadWorkSchedules(modelID);
    await this.loadWorkCalendars(modelID);
    await this.loadWorkTimes(modelID);
    await this.loadTimePeriods(modelID);
    this.isLoaded = true;
  }

  async loadWorkSchedules(modelID) {
    let workSchedules = await this.utils.byType(modelID, "IfcWorkSchedule");
    for (let i = 0; i < workSchedules.length; i++) {
      let workSchedule = workSchedules[i];
      this.workSchedules[workSchedule.expressID] = {
        "Id": workSchedule.expressID,
        "Name": workSchedule.Name.value,
        "Description": ((workSchedule.Description) ? workSchedule.Description.value : ""),
        "Creators": [],
        "CreationDate": ((workSchedule.CreationDate) ? workSchedule.CreationDate.value : ""),
        "StartTime": ((workSchedule.StartTime) ? workSchedule.StartTime.value : ""),
        "FinishTime": ((workSchedule.FinishTime) ? workSchedule.FinishTime.value : ""),
        "TotalFloat": ((workSchedule.TotalFloat) ? workSchedule.TotalFloat.value : ""),
        "RelatedObjects": [],
      };
    }
    this.loadWorkScheduleRelatedObjects(modelID);
  }

  async loadWorkScheduleRelatedObjects(modelID) {
    let relsControls = await this.utils.byType(modelID, "IfcRelAssignsToControl");
    for (let i = 0; i < relsControls.length; i++) {
      let relControls = relsControls[i];
      let relatingControl = await this.utils.byId(modelID, relControls.RelatingControl.value);
      let relatedObjects = relControls.RelatedObjects;
      if (this.utils.isA(relatingControl, "IfcWorkSchedule")) {
        for (var objectIndex = 0; objectIndex < relatedObjects.length; objectIndex++) {
          this.workSchedules[relatingControl.expressID]["RelatedObjects"].push(relatedObjects[objectIndex].value);
        }
      }
    }
  }

  async loadTasks(modelID) {
    let tasks = await this.utils.byType(modelID, "IfcTask");
    for (let i = 0; i < tasks.length; i++) {
      let task = tasks[i];
      this.tasks[task.expressID] = {
        "Id": task.expressID,
        "Name": ((task.Name) ? task.Name.value : ""),
        "PredefinedType": ((task.PredefinedType) ? task.PredefinedType.value : ""),
        "TaskTime": ((task.TaskTime) ? await this.utils.byId(modelID, task.TaskTime.value) : ""),
        "Identification": ((task.Identification) ? task.Identification.value : ""),
        "IsMilestone": ((task.IsMilestone) ? task.IsMilestone.value : ""),
        "IsPredecessorTo": [],
        "IsSucessorFrom": [],
        "Inputs": [],
        "Resources": [],
        "Outputs": [],
        "Controls": [],
        "Nests": [],
        "IsNestedBy": [],
        "OperatesOn": [],
        "HasAssignmentsWorkCalendars": [],
      };
    }
    await this.loadTaskSequence(modelID);
    await this.loadTaskOutputs(modelID);
    await this.loadTaskNesting(modelID);
    await this.loadTaskOperations(modelID);
    await this.loadAssignementsWorkCalendar(modelID);
  }

  async loadTaskSequence(modelID) {
    let relsSequence = await this.utils.idsByType(modelID, "IfcRelSequence");
    for (let i = 0; i < relsSequence.size(); i++) {
      let relSequenceId = relsSequence.get(i);
      if (relSequenceId !== 0) {
        let relSequence = await this.utils.byId(modelID, relSequenceId);
        let related_process = relSequence.RelatedProcess.value;
        let relatingProcess = relSequence.RelatingProcess.value;
        this.tasks[relatingProcess]["IsPredecessorTo"].push(relSequence.expressID);
        this.tasks[related_process]["IsSucessorFrom"].push(relSequence.expressID);
      }
    }
  }

  async loadTaskOutputs(modelID) {
    let rels_assigns_to_product = await this.utils.byType(modelID, "IfcRelAssignsToProduct");
    for (let i = 0; i < rels_assigns_to_product.length; i++) {
      let relAssignsToProduct = rels_assigns_to_product[i];
      let relatedObject = await this.utils.byId(modelID, relAssignsToProduct.RelatedObjects[0].value);
      if (this.utils.isA(relatedObject, "IfcTask")) {
        let relatingProduct = await this.utils.byId(modelID, relAssignsToProduct.RelatingProduct.value);
        this.tasks[relatedObject.expressID]["Outputs"].push(relatingProduct.expressID);
      }
    }
  }

  async loadTaskNesting(modelID) {
    let rels_nests = await this.utils.byType(modelID, "IfcRelNests");
    for (let i = 0; i < rels_nests.length; i++) {
      let relNests = rels_nests[i];
      let relating_object = await this.utils.byId(modelID, relNests.RelatingObject.value);
      if (this.utils.isA(relating_object, "IfcTask")) {
        let relatedObjects = relNests.RelatedObjects;
        for (var object_index = 0; object_index < relatedObjects.length; object_index++) {
          this.tasks[relating_object.expressID]["IsNestedBy"].push(relatedObjects[object_index].value);
          this.tasks[relatedObjects[object_index].value]["Nests"].push(relating_object.expressID);
        }
      }
    }
  }

  async loadTaskOperations(modelID) {
    let relsAssignsToProcess = await this.utils.byType(modelID, "IfcRelAssignsToProcess");
    for (let i = 0; i < relsAssignsToProcess.length; i++) {
      let relAssignToProcess = relsAssignsToProcess[i];
      let relatingProcess = await this.utils.byId(modelID, relAssignToProcess.RelatingProcess.value);
      if (this.utils.isA(relatingProcess, "IfcTask")) {
        let relatedObjects = relAssignToProcess.RelatedObjects;
        for (var object_index = 0; object_index < relatedObjects.length; object_index++) {
          this.tasks[relatingProcess.expressID]["OperatesOn"].push(relatedObjects[object_index].value);
        }
      }
    }
  }

  async loadAssignementsWorkCalendar(modelID) {
    let relsAssignsToControl = await this.utils.byType(modelID, "IfcRelAssignsToControl");
    for (let i = 0; i < relsAssignsToControl.length; i++) {
      let relAssignsToControl = relsAssignsToControl[i];
      let relatingControl = await this.utils.byId(modelID, relAssignsToControl.RelatingControl.value);
      if (this.utils.isA(relatingControl, "IfcWorkCalendar")) {
        let relatedObjects = relAssignsToControl.RelatedObjects;
        for (var object_index = 0; object_index < relatedObjects.length; object_index++) {
          this.tasks[relatedObjects[object_index].value]["HasAssignmentsWorkCalendars"].push(relatingControl.expressID);
        }
      }
    }
  }

  async loadWorkCalendars(modelID) {
    let workCalendars = await this.utils.byType(modelID, "IfcWorkCalendar");
    for (let i = 0; i < workCalendars.length; i++) {
      let workCalendar = workCalendars[i];
      let workCalenderData = {
        "Id": workCalendar.expressID,
        "Name": ((workCalendar.Name) ? workCalendar.Name.value : ""),
        "Description": ((workCalendar.Description) ? workCalendar.Description.value : ""),
        "WorkingTimes": ((workCalendar.WorkingTimes) ? workCalendar.WorkingTimes : []),
        "ExceptionTimes": ((workCalendar.ExceptionTimes) ? workCalendar.ExceptionTimes : []),
      };
      this.workCalendars[workCalendar.expressID] = workCalenderData;
    }
  }

  async loadWorkTimes(modelID) {
    let workTimes = await this.utils.byType(modelID, "IfcWorkTime");
    for (let i = 0; i < workTimes.length; i++) {
      let workTime = workTimes[i];
      let workTimeData = {
        "Name": ((workTime.Name) ? workTime.Name.value : ""),
        "RecurrencePattern": ((workTime.RecurrencePattern) ? await this.utils.byId(modelID, workTime.RecurrencePattern.value) : ""),
        "Start": ((workTime.Start) ? new Date(workTime.Start.value) : ""),
        "Finish": ((workTime.Finish) ? new Date(workTime.Finish.value) : ""),
      };
      this.workTimes[workTime.expressID] = workTimeData;
    }
  }

  async loadTimePeriods(modelID) {
    let timePeriods = await this.utils.byType(modelID, "IfcTimePeriod");
    for (let i = 0; i < timePeriods.length; i++) {
      let timePeriod = timePeriods[i];
      let workTimeData = {
        "StartTime": ((timePeriod.StartTime) ? new Date(timePeriod.StartTime.value) : ""),
        "EndTime": ((timePeriod.EndTime) ? new Date(timePeriod.EndTime.value) : ""),
      };
      this.timePeriods[timePeriod.expressID] = workTimeData;
    }
  }

}

class IFCManager {

  constructor() {
    this.state = {
      models: [],
      api: new IfcAPI2(),
      useJSON: false,
      worker: {
        active: false,
        path: ''
      }
    };
    this.BVH = new BvhManager();
    this.typesMap = IfcTypesMap;
    this.parser = new IFCParser(this.state, this.BVH);
    this.subsets = new SubsetManager(this.state, this.BVH);
    this.utils = new IFCUtils(this.state);
    this.sequenceData = new Data(this.state);
    this.properties = new PropertyManager(this.state);
    this.types = new TypeManager(this.state);
    this.cleaner = new MemoryCleaner(this.state);
  }

  get ifcAPI() {
    return this.state.api;
  }

  async parse(buffer) {
    var _a;
    const model = await this.parser.parse(buffer, (_a = this.state.coordinationMatrix) === null || _a === void 0 ? void 0 : _a.toArray());
    model.setIFCManager(this);
    await this.types.getAllTypes(this.worker);
    return model;
  }

  async setWasmPath(path) {
    this.state.api.SetWasmPath(path);
    this.state.wasmPath = path;
  }

  setupThreeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast) {
    this.BVH.initializeMeshBVH(computeBoundsTree, disposeBoundsTree, acceleratedRaycast);
  }

  setOnProgress(onProgress) {
    this.state.onProgress = onProgress;
  }

  setupCoordinationMatrix(matrix) {
    this.state.coordinationMatrix = matrix;
  }

  clearCoordinationMatrix() {
    delete this.state.coordinationMatrix;
  }

  async applyWebIfcConfig(settings) {
    this.state.webIfcSettings = settings;
    if (this.state.worker.active && this.worker) {
      await this.worker.workerState.updateStateWebIfcSettings();
    }
  }

  async useWebWorkers(active, path) {
    if (this.state.worker.active === active)
      return;
    this.state.api = null;
    if (active) {
      if (!path)
        throw new Error('You must provide a path to the web worker.');
      this.state.worker.active = active;
      this.state.worker.path = path;
      await this.initializeWorkers();
      const wasm = this.state.wasmPath;
      if (wasm)
        await this.setWasmPath(wasm);
    } else {
      this.state.api = new IfcAPI2();
    }
  }

  async useJSONData(useJSON = true) {
    var _a;
    this.state.useJSON = useJSON;
    if (useJSON) {
      await ((_a = this.worker) === null || _a === void 0 ? void 0 : _a.workerState.updateStateUseJson());
    }
  }

  async addModelJSONData(modelID, data) {
    var _a;
    const model = this.state.models[modelID];
    if (!model)
      throw new Error('The specified model for the JSON data does not exist');
    if (this.state.worker.active) {
      await ((_a = this.worker) === null || _a === void 0 ? void 0 : _a.workerState.updateModelStateJsonData(modelID, data));
    } else {
      model.jsonData = data;
    }
  }

  async loadJsonDataFromWorker(modelID, path) {
    var _a;
    if (this.state.worker.active) {
      await ((_a = this.worker) === null || _a === void 0 ? void 0 : _a.workerState.loadJsonDataFromWorker(modelID, path));
    }
  }

  close(modelID, scene) {
    this.state.api.CloseModel(modelID);
    if (scene)
      scene.remove(this.state.models[modelID].mesh);
    delete this.state.models[modelID];
  }

  getExpressId(geometry, faceIndex) {
    return this.properties.getExpressId(geometry, faceIndex);
  }

  getAllItemsOfType(modelID, type, verbose) {
    return this.properties.getAllItemsOfType(modelID, type, verbose);
  }

  getItemProperties(modelID, id, recursive = false) {
    return this.properties.getItemProperties(modelID, id, recursive);
  }

  getPropertySets(modelID, id, recursive = false) {
    return this.properties.getPropertySets(modelID, id, recursive);
  }

  getTypeProperties(modelID, id, recursive = false) {
    return this.properties.getTypeProperties(modelID, id, recursive);
  }

  getMaterialsProperties(modelID, id, recursive = false) {
    return this.properties.getMaterialsProperties(modelID, id, recursive);
  }

  getIfcType(modelID, id) {
    const typeID = this.state.models[modelID].types[id];
    return IfcElements[typeID];
  }

  getSpatialStructure(modelID, includeProperties) {
    return this.properties.getSpatialStructure(modelID, includeProperties);
  }

  getSubset(modelID, material, customId) {
    return this.subsets.getSubset(modelID, material, customId);
  }

  removeSubset(modelID, material, customID) {
    this.subsets.removeSubset(modelID, material, customID);
  }

  createSubset(config) {
    return this.subsets.createSubset(config);
  }

  removeFromSubset(modelID, ids, customID, material) {
    return this.subsets.removeFromSubset(modelID, ids, customID, material);
  }

  clearSubset(modelID, customID, material) {
    return this.subsets.clearSubset(modelID, customID, material);
  }

  async isA(entity, entity_class) {
    return this.utils.isA(entity, entity_class);
  }

  async getSequenceData(modelID) {
    await this.sequenceData.load(modelID);
    return this.sequenceData;
  }

  async byType(modelID, entityClass) {
    return this.utils.byType(modelID, entityClass);
  }

  async byId(modelID, id) {
    return this.utils.byId(modelID, id);
  }

  async idsByType(modelID, entityClass) {
    return this.utils.idsByType(modelID, entityClass);
  }

  async dispose() {
    IFCModel.dispose();
    await this.cleaner.dispose();
    this.subsets.dispose();
    if (this.worker && this.state.worker.active)
      await this.worker.terminate();
    this.state = null;
  }

  async disposeMemory() {
    var _a;
    if (this.state.worker.active) {
      await ((_a = this.worker) === null || _a === void 0 ? void 0 : _a.Close());
    } else {
      this.state.api.Close();
      this.state.api = null;
      this.state.api = new IfcAPI2();
    }
  }

  getAndClearErrors(modelID) {
    return this.parser.getAndClearErrors(modelID);
  }

  async initializeWorkers() {
    this.worker = new IFCWorkerHandler(this.state, this.BVH);
    this.state.api = this.worker.webIfc;
    this.properties = this.worker.properties;
    await this.worker.parser.setupOptionalCategories(this.parser.optionalCategories);
    this.parser = this.worker.parser;
    await this.worker.workerState.updateStateUseJson();
    await this.worker.workerState.updateStateWebIfcSettings();
  }

}

class IFCLoader extends Loader {

  constructor(manager) {
    super(manager);
    this.ifcManager = new IFCManager();
  }

  load(url, onLoad, onProgress, onError) {
    const scope = this;
    const loader = new FileLoader(scope.manager);
    this.onProgress = onProgress;
    loader.setPath(scope.path);
    loader.setResponseType('arraybuffer');
    loader.setRequestHeader(scope.requestHeader);
    loader.setWithCredentials(scope.withCredentials);
    loader.load(url, async function (buffer) {
      try {
        if (typeof buffer == 'string') {
          throw new Error('IFC files must be given as a buffer!');
        }
        onLoad(await scope.parse(buffer));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        scope.manager.itemError(url);
      }
    }, onProgress, onError);
  }

  parse(buffer) {
    return this.ifcManager.parse(buffer);
  }

}

/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
Object.freeze({
    NONE: 0,
    ROTATE: 1,
    TRUCK: 2,
    OFFSET: 4,
    DOLLY: 8,
    ZOOM: 16,
    TOUCH_ROTATE: 32,
    TOUCH_TRUCK: 64,
    TOUCH_OFFSET: 128,
    TOUCH_DOLLY: 256,
    TOUCH_ZOOM: 512,
    TOUCH_DOLLY_TRUCK: 1024,
    TOUCH_DOLLY_OFFSET: 2048,
    TOUCH_ZOOM_TRUCK: 4096,
    TOUCH_ZOOM_OFFSET: 8192,
});

const isBrowser = typeof window !== 'undefined';
isBrowser && /Mac/.test(navigator.platform);

({
    MOUSE,
    Vector2,
    Vector3,
    Vector4,
    Quaternion,
    Matrix4,
    Spherical,
    Box3,
    Sphere,
    Raycaster,
    MathUtils: {
        DEG2RAD: MathUtils.DEG2RAD,
        clamp: MathUtils.clamp
    }
});

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry$1 = new BufferGeometry();
_geometry$1.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry$1.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

// Helper for passes that need to fill the viewport with a single quad.

new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );

// https://github.com/mrdoob/three.js/pull/21358

const _geometry = new BufferGeometry();
_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );
_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

/**
 * TODO
 */

({
	defines: {
		'NUM_SAMPLES': 7,
		'NUM_RINGS': 4,
		'NORMAL_TEXTURE': 0,
		'DIFFUSE_TEXTURE': 0,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {

		'tDepth': { value: null },
		'tDiffuse': { value: null },
		'tNormal': { value: null },
		'size': { value: new Vector2( 512, 512 ) },

		'cameraNear': { value: 1 },
		'cameraFar': { value: 100 },
		'cameraProjectionMatrix': { value: new Matrix4() },
		'cameraInverseProjectionMatrix': { value: new Matrix4() },

		'scale': { value: 1.0 },
		'intensity': { value: 0.1 },
		'bias': { value: 0.5 },

		'minResolution': { value: 0.0 },
		'kernelRadius': { value: 100.0 },
		'randomSeed': { value: 0.0 }
	},
	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {
			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>

		varying vec2 vUv;

		#if DIFFUSE_TEXTURE == 1
		uniform sampler2D tDiffuse;
		#endif

		uniform sampler2D tDepth;

		#if NORMAL_TEXTURE == 1
		uniform sampler2D tNormal;
		#endif

		uniform float cameraNear;
		uniform float cameraFar;
		uniform mat4 cameraProjectionMatrix;
		uniform mat4 cameraInverseProjectionMatrix;

		uniform float scale;
		uniform float intensity;
		uniform float bias;
		uniform float kernelRadius;
		uniform float minResolution;
		uniform vec2 size;
		uniform float randomSeed;

		// RGBA depth

		#include <packing>

		vec4 getDefaultColor( const in vec2 screenPosition ) {
			#if DIFFUSE_TEXTURE == 1
			return texture2D( tDiffuse, vUv );
			#else
			return vec4( 1.0 );
			#endif
		}

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {
			float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];
			vec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );
			clipPosition *= clipW; // unprojection.

			return ( cameraInverseProjectionMatrix * clipPosition ).xyz;
		}

		vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {
			#if NORMAL_TEXTURE == 1
			return unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );
			#else
			return normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );
			#endif
		}

		float scaleDividedByCameraFar;
		float minResolutionMultipliedByCameraFar;

		float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {
			vec3 viewDelta = sampleViewPosition - centerViewPosition;
			float viewDistance = length( viewDelta );
			float scaledScreenDistance = scaleDividedByCameraFar * viewDistance;

			return max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );
		}

		// moving costly divides into consts
		const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );
		const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );

		float getAmbientOcclusion( const in vec3 centerViewPosition ) {
			// precompute some variables require in getOcclusion.
			scaleDividedByCameraFar = scale / cameraFar;
			minResolutionMultipliedByCameraFar = minResolution * cameraFar;
			vec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );

			// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/
			float angle = rand( vUv + randomSeed ) * PI2;
			vec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;
			vec2 radiusStep = radius;

			float occlusionSum = 0.0;
			float weightSum = 0.0;

			for( int i = 0; i < NUM_SAMPLES; i ++ ) {
				vec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;
				radius += radiusStep;
				angle += ANGLE_STEP;

				float sampleDepth = getDepth( sampleUv );
				if( sampleDepth >= ( 1.0 - EPSILON ) ) {
					continue;
				}

				float sampleViewZ = getViewZ( sampleDepth );
				vec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );
				occlusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );
				weightSum += 1.0;
			}

			if( weightSum == 0.0 ) discard;

			return occlusionSum * ( intensity / weightSum );
		}

		void main() {
			float centerDepth = getDepth( vUv );
			if( centerDepth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = getViewZ( centerDepth );
			vec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );

			float ambientOcclusion = getAmbientOcclusion( viewPosition );

			gl_FragColor = getDefaultColor( vUv );
			gl_FragColor.xyz *=  1.0 - ambientOcclusion;
		}`

});

/**
 * TODO
 */

({
	defines: {
		'KERNEL_RADIUS': 4,
		'DEPTH_PACKING': 1,
		'PERSPECTIVE_CAMERA': 1
	},
	uniforms: {
		'tDiffuse': { value: null },
		'size': { value: new Vector2( 512, 512 ) },
		'sampleUvOffsets': { value: [ new Vector2( 0, 0 ) ] },
		'sampleWeights': { value: [ 1.0 ] },
		'tDepth': { value: null },
		'cameraNear': { value: 10 },
		'cameraFar': { value: 1000 },
		'depthCutoff': { value: 10 },
	},
	vertexShader: /* glsl */`

		#include <common>

		uniform vec2 size;

		varying vec2 vUv;
		varying vec2 vInvSize;

		void main() {
			vUv = uv;
			vInvSize = 1.0 / size;

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
		}`,

	fragmentShader: /* glsl */`

		#include <common>
		#include <packing>

		uniform sampler2D tDiffuse;
		uniform sampler2D tDepth;

		uniform float cameraNear;
		uniform float cameraFar;
		uniform float depthCutoff;

		uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];
		uniform float sampleWeights[ KERNEL_RADIUS + 1 ];

		varying vec2 vUv;
		varying vec2 vInvSize;

		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
			return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
			return texture2D( tDepth, screenPosition ).x;
			#endif
		}

		float getViewZ( const in float depth ) {
			#if PERSPECTIVE_CAMERA == 1
			return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#else
			return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}

		void main() {
			float depth = getDepth( vUv );
			if( depth >= ( 1.0 - EPSILON ) ) {
				discard;
			}

			float centerViewZ = -getViewZ( depth );
			bool rBreak = false, lBreak = false;

			float weightSum = sampleWeights[0];
			vec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;

			for( int i = 1; i <= KERNEL_RADIUS; i ++ ) {

				float sampleWeight = sampleWeights[i];
				vec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;

				vec2 sampleUv = vUv + sampleUvOffset;
				float viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;

				if( ! rBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

				sampleUv = vUv - sampleUvOffset;
				viewZ = -getViewZ( getDepth( sampleUv ) );

				if( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;

				if( ! lBreak ) {
					diffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;
					weightSum += sampleWeight;
				}

			}

			gl_FragColor = diffuseSum / weightSum;
		}`

});

/**
 * NVIDIA FXAA by Timothy Lottes
 * https://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 * Further improved by Daniel Sturk
 */

({

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: `
	precision highp float;

	uniform sampler2D tDiffuse;

	uniform vec2 resolution;

	varying vec2 vUv;

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:        es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:       gameworks@nvidia.com
	// Site:        http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//  * Redistributions of source code must retain the above copyright
	//    notice, this list of conditions and the following disclaimer.
	//  * Redistributions in binary form must reproduce the above copyright
	//    notice, this list of conditions and the following disclaimer in the
	//    documentation and/or other materials provided with the distribution.
	//  * Neither the name of NVIDIA CORPORATION nor the names of its
	//    contributors may be used to endorse or promote products derived
	//    from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	#ifndef FXAA_DISCARD
			//
			// Only valid for PC OpenGL currently.
			// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
			//
			// 1 = Use discard on pixels which don't need AA.
			//     For APIs which enable concurrent TEX+ROP from same surface.
			// 0 = Return unchanged color on pixels which don't need AA.
			//
			#define FXAA_DISCARD 0
	#endif

	/*--------------------------------------------------------------------------*/
	#define FxaaTexTop(t, p) texture2D(t, p, -100.0)
	#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)
	/*--------------------------------------------------------------------------*/

	#define NUM_SAMPLES 5

	// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha
	float contrast( vec4 a, vec4 b ) {
			vec4 diff = abs( a - b );
			return max( max( max( diff.r, diff.g ), diff.b ), diff.a );
	}

	/*============================================================================

									FXAA3 QUALITY - PC

	============================================================================*/

	/*--------------------------------------------------------------------------*/
	vec4 FxaaPixelShader(
			vec2 posM,
			sampler2D tex,
			vec2 fxaaQualityRcpFrame,
			float fxaaQualityEdgeThreshold,
			float fxaaQualityinvEdgeThreshold
	) {
			vec4 rgbaM = FxaaTexTop(tex, posM);
			vec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);
			vec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);
			// . S .
			// W M E
			// . N .

			bool earlyExit = max( max( max(
					contrast( rgbaM, rgbaN ),
					contrast( rgbaM, rgbaS ) ),
					contrast( rgbaM, rgbaE ) ),
					contrast( rgbaM, rgbaW ) )
					< fxaaQualityEdgeThreshold;
			// . 0 .
			// 0 0 0
			// . 0 .

			#if (FXAA_DISCARD == 1)
					if(earlyExit) FxaaDiscard;
			#else
					if(earlyExit) return rgbaM;
			#endif

			float contrastN = contrast( rgbaM, rgbaN );
			float contrastS = contrast( rgbaM, rgbaS );
			float contrastE = contrast( rgbaM, rgbaE );
			float contrastW = contrast( rgbaM, rgbaW );

			float relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );
			relativeVContrast *= fxaaQualityinvEdgeThreshold;

			bool horzSpan = relativeVContrast > 0.;
			// . 1 .
			// 0 0 0
			// . 1 .

			// 45 deg edge detection and corners of objects, aka V/H contrast is too similar
			if( abs( relativeVContrast ) < .3 ) {
					// locate the edge
					vec2 dirToEdge;
					dirToEdge.x = contrastE > contrastW ? 1. : -1.;
					dirToEdge.y = contrastS > contrastN ? 1. : -1.;
					// . 2 .      . 1 .
					// 1 0 2  ~=  0 0 1
					// . 1 .      . 0 .

					// tap 2 pixels and see which ones are "outside" the edge, to
					// determine if the edge is vertical or horizontal

					vec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongH = contrast( rgbaM, rgbaAlongH );
					// . 1 .
					// 0 0 1
					// . 0 H

					vec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);
					float matchAlongV = contrast( rgbaM, rgbaAlongV );
					// V 1 .
					// 0 0 1
					// . 0 .

					relativeVContrast = matchAlongV - matchAlongH;
					relativeVContrast *= fxaaQualityinvEdgeThreshold;

					if( abs( relativeVContrast ) < .3 ) { // 45 deg edge
							// 1 1 .
							// 0 0 1
							// . 0 1

							// do a simple blur
							return mix(
									rgbaM,
									(rgbaN + rgbaS + rgbaE + rgbaW) * .25,
									.4
							);
					}

					horzSpan = relativeVContrast > 0.;
			}

			if(!horzSpan) rgbaN = rgbaW;
			if(!horzSpan) rgbaS = rgbaE;
			// . 0 .      1
			// 1 0 1  ->  0
			// . 0 .      1

			bool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );
			if(!pairN) rgbaN = rgbaS;

			vec2 offNP;
			offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
			offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;

			bool doneN = false;
			bool doneP = false;

			float nDist = 0.;
			float pDist = 0.;

			vec2 posN = posM;
			vec2 posP = posM;

			int iterationsUsed = 0;
			int iterationsUsedN = 0;
			int iterationsUsedP = 0;
			for( int i = 0; i < NUM_SAMPLES; i++ ) {
					iterationsUsed = i;

					float increment = float(i + 1);

					if(!doneN) {
							nDist += increment;
							posN = posM + offNP * nDist;
							vec4 rgbaEndN = FxaaTexTop(tex, posN.xy);
							doneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );
							iterationsUsedN = i;
					}

					if(!doneP) {
							pDist += increment;
							posP = posM - offNP * pDist;
							vec4 rgbaEndP = FxaaTexTop(tex, posP.xy);
							doneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );
							iterationsUsedP = i;
					}

					if(doneN || doneP) break;
			}


			if ( !doneP && !doneN ) return rgbaM; // failed to find end of edge

			float dist = min(
					doneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,
					doneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.
			);

			// hacky way of reduces blurriness of mostly diagonal edges
			// but reduces AA quality
			dist = pow(dist, .5);

			dist = 1. - dist;

			return mix(
					rgbaM,
					rgbaN,
					dist * .5
			);
	}

	void main() {
			const float edgeDetectionQuality = .2;
			const float invEdgeDetectionQuality = 1. / edgeDetectionQuality;

			gl_FragColor = FxaaPixelShader(
					vUv,
					tDiffuse,
					resolution,
					edgeDetectionQuality, // [0,1] contrast needed, otherwise early discard
					invEdgeDetectionQuality
			);

	}
	`

});

var IfcEvent;
(function (IfcEvent) {
    IfcEvent["onCameraReady"] = "onCameraReady";
})(IfcEvent || (IfcEvent = {}));

class GLTFLoader extends Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsEmissiveStrengthExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIridescenceExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Emissive Strength Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md
 */
class GLTFMaterialsEmissiveStrengthExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const emissiveStrength = materialDef.extensions[ this.name ].emissiveStrength;

		if ( emissiveStrength !== undefined ) {

			materialParams.emissiveIntensity = emissiveStrength;

		}

		return Promise.resolve();

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Iridescence Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence
 */
class GLTFMaterialsIridescenceExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.iridescenceFactor !== undefined ) {

			materialParams.iridescence = extension.iridescenceFactor;

		}

		if ( extension.iridescenceTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceMap', extension.iridescenceTexture ) );

		}

		if ( extension.iridescenceIor !== undefined ) {

			materialParams.iridescenceIOR = extension.iridescenceIor;

		}

		if ( materialParams.iridescenceThicknessRange === undefined ) {

			materialParams.iridescenceThicknessRange = [ 100, 400 ];

		}

		if ( extension.iridescenceThicknessMinimum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 0 ] = extension.iridescenceThicknessMinimum;

		}

		if ( extension.iridescenceThicknessMaximum !== undefined ) {

			materialParams.iridescenceThicknessRange[ 1 ] = extension.iridescenceThicknessMaximum;

		}

		if ( extension.iridescenceThicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'iridescenceThicknessMap', extension.iridescenceThicknessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture, sRGBEncoding ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture, sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, extension.source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new Color().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity'
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture, sRGBEncoding ) );

		}

		materialParams.emissive = new Color( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new Color( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef, sRGBEncoding ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = materialParams.emissiveIntensity === undefined ? 1.0 : materialParams.emissiveIntensity;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

	interpolate_( i1, t0, t, t1 ) {

		const result = this.resultBuffer;
		const values = this.sampleValues;
		const stride = this.valueSize;

		const stride2 = stride * 2;
		const stride3 = stride * 3;

		const td = t1 - t0;

		const p = ( t - t0 ) / td;
		const pp = p * p;
		const ppp = pp * p;

		const offset1 = i1 * stride3;
		const offset0 = offset1 - stride3;

		const s2 = - 2 * ppp + 3 * pp;
		const s3 = ppp - pp;
		const s0 = 1 - s2;
		const s1 = s3 - pp + p;

		// Layout of keyframe output values for CUBICSPLINE animations:
		//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
		for ( let i = 0; i !== stride; i ++ ) {

			const p0 = values[ offset0 + i + stride ]; // splineVertex_k
			const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
			const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
			const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

			result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

		}

		return result;

	}

}

const _q = new Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS$1 = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: NearestFilter,
	9729: LinearFilter,
	9984: NearestMipmapNearestFilter,
	9985: LinearMipmapNearestFilter,
	9986: NearestMipmapLinearFilter,
	9987: LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: ClampToEdgeWrapping,
	33648: MirroredRepeatWrapping,
	10497: RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: InterpolateLinear,
	STEP: InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.

		const isSafari = /^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === true;
		const isFirefox = navigator.userAgent.indexOf( 'Firefox' ) > - 1;
		const firefoxVersion = isFirefox ? navigator.userAgent.match( /Firefox\/([0-9]+)\./ )[ 1 ] : - 1;

		if ( typeof createImageBitmap === 'undefined' || isSafari || ( isFirefox && firefoxVersion < 98 ) ) {

			this.textureLoader = new TextureLoader( this.options.manager );

		} else {

			this.textureLoader = new ImageBitmapLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadAnimation && ext.loadAnimation( index );

					} );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( ( texture ) => texture.clone() );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef, encoding ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			if ( encoding !== undefined ) {

				texture.encoding = encoding;

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new PointsMaterial();
				Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new LineBasicMaterial();
				Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture, sRGBEncoding ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial ) {

			materialParams.emissive = new Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture, sRGBEncoding ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new SkinnedMesh( geometry, material )
						: new Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS$1.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINES ) {

					mesh = new LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_STRIP ) {

					mesh = new Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.LINE_LOOP ) {

					mesh = new LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS$1.POINTS ) {

					mesh = new Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new PerspectiveCamera( MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new Bone();

			} else if ( objects.length > 1 ) {

				node = new Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof Material || key instanceof Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new Vector3();
		const vector = new Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}

//------------------------------------------------------------------------------
// Constants
//------------------------------------------------------------------------------

const WEBGL_CONSTANTS = {
	POINTS: 0x0000,
	LINES: 0x0001,
	LINE_LOOP: 0x0002,
	LINE_STRIP: 0x0003,
	TRIANGLES: 0x0004,
	TRIANGLE_STRIP: 0x0005,
	TRIANGLE_FAN: 0x0006,

	UNSIGNED_BYTE: 0x1401,
	UNSIGNED_SHORT: 0x1403,
	FLOAT: 0x1406,
	UNSIGNED_INT: 0x1405,
	ARRAY_BUFFER: 0x8892,
	ELEMENT_ARRAY_BUFFER: 0x8893,

	NEAREST: 0x2600,
	LINEAR: 0x2601,
	NEAREST_MIPMAP_NEAREST: 0x2700,
	LINEAR_MIPMAP_NEAREST: 0x2701,
	NEAREST_MIPMAP_LINEAR: 0x2702,
	LINEAR_MIPMAP_LINEAR: 0x2703,

	CLAMP_TO_EDGE: 33071,
	MIRRORED_REPEAT: 33648,
	REPEAT: 10497
};

const THREE_TO_WEBGL = {};

THREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;
THREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;
THREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;
THREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;
THREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;
THREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;

THREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;
THREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;
THREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;

/* eslint-disable */
const _upVector = new Vector3(0, 1, 0);
const EPSILON = 1e-16;
// Modified version of js EdgesGeometry logic to handle silhouette edges
((function () {
    const _v0 = new Vector3();
    const _v1 = new Vector3();
    const _normal = new Vector3();
    const _triangle = new Triangle();
    return function generateEdges(geometry, projectionDir, thresholdAngle = 1) {
        const edges = [];
        const precisionPoints = 4;
        const precision = Math.pow(10, precisionPoints);
        const thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
        const indexAttr = geometry.getIndex();
        const positionAttr = geometry.getAttribute('position');
        const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        const indexArr = [0, 0, 0];
        const vertKeys = ['a', 'b', 'c'];
        const hashes = new Array(3);
        const edgeData = {};
        for (let i = 0; i < indexCount; i += 3) {
            if (indexAttr) {
                indexArr[0] = indexAttr.getX(i);
                indexArr[1] = indexAttr.getX(i + 1);
                indexArr[2] = indexAttr.getX(i + 2);
            }
            else {
                indexArr[0] = i;
                indexArr[1] = i + 1;
                indexArr[2] = i + 2;
            }
            const { a, b, c } = _triangle;
            a.fromBufferAttribute(positionAttr, indexArr[0]);
            b.fromBufferAttribute(positionAttr, indexArr[1]);
            c.fromBufferAttribute(positionAttr, indexArr[2]);
            _triangle.getNormal(_normal);
            // create hashes for the edge from the vertices
            hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
            hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
            hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
            // skip degenerate triangles
            if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
                continue;
            }
            // iterate over every edge
            for (let j = 0; j < 3; j++) {
                // get the first and next vertex making up the edge
                const jNext = (j + 1) % 3;
                const vecHash0 = hashes[j];
                const vecHash1 = hashes[jNext];
                const v0 = _triangle[vertKeys[j]];
                const v1 = _triangle[vertKeys[jNext]];
                const hash = `${vecHash0}_${vecHash1}`;
                const reverseHash = `${vecHash1}_${vecHash0}`;
                if (reverseHash in edgeData && edgeData[reverseHash]) {
                    // if we found a sibling edge add it into the vertex array if
                    // it meets the angle threshold and delete the edge from the map.
                    const otherNormal = edgeData[reverseHash].normal;
                    const meetsThreshold = _normal.dot(otherNormal) <= thresholdDot;
                    const projectionThreshold = Math.sign(projectionDir.dot(_normal)) !== Math.sign(projectionDir.dot(otherNormal));
                    if (meetsThreshold || projectionThreshold) {
                        const line = new Line3();
                        line.start.copy(v0);
                        line.end.copy(v1);
                        edges.push(line);
                    }
                    edgeData[reverseHash] = null;
                }
                else if (!(hash in edgeData)) {
                    // if we've already got an edge here then skip adding a new one
                    edgeData[hash] = {
                        index0: indexArr[j],
                        index1: indexArr[jNext],
                        normal: _normal.clone()
                    };
                }
            }
        }
        // iterate over all remaining, unmatched edges and add them to the vertex array
        for (const key in edgeData) {
            if (edgeData[key]) {
                const { index0, index1 } = edgeData[key];
                _v0.fromBufferAttribute(positionAttr, index0);
                _v1.fromBufferAttribute(positionAttr, index1);
                const line = new Line3();
                line.start.copy(_v0);
                line.end.copy(_v1);
                edges.push(line);
            }
        }
        return edges;
    };
}))();
// outputs the overlapping segment of a coplanar line and triangle
const getOverlappingLine = (function () {
    const _dir0 = new Vector3();
    const _dir1 = new Vector3();
    const _tempDir = new Vector3();
    const _orthoPlane = new Plane();
    const _line0 = new Line3();
    const _line1 = new Line3();
    const _tempLine = new Line3();
    return function getOverlappingLine(line, triangle, lineTarget = new Line3()) {
        if (triangle.needsUpdate) {
            triangle.needsUpdate();
        }
        // if the triangle is degenerate then return no overlap
        if (triangle.getArea() <= EPSILON) {
            return null;
        }
        const { points, plane } = triangle;
        _line0.copy(line);
        _line0.delta(_dir0);
        // if the line and triangle are not coplanar then return no overlap
        const areCoplanar = plane.normal.dot(_dir0) === 0.0;
        if (!areCoplanar) {
            return null;
        }
        // a plane that's orthogonal to the triangle that the line lies on
        _dir0.cross(plane.normal).normalize();
        _orthoPlane.setFromNormalAndCoplanarPoint(_dir0, _line0.start);
        // find the line of intersection of the triangle along the plane if it exists
        let intersectCount = 0;
        for (let i = 0; i < 3; i++) {
            const p1 = points[i];
            const p2 = points[(i + 1) % 3];
            _tempLine.start.copy(p1);
            _tempLine.end.copy(p2);
            if (_orthoPlane.distanceToPoint(_tempLine.end) === 0 &&
                _orthoPlane.distanceToPoint(_tempLine.start) === 0) {
                // if the edge lies on the plane then take the line
                _line1.copy(_tempLine);
                intersectCount = 2;
                break;
            }
            else if (_orthoPlane.intersectLine(_tempLine, intersectCount === 0 ? _line1.start : _line1.end)) {
                let p;
                if (intersectCount === 0) {
                    p = _line1.start;
                }
                else {
                    p = _line1.end;
                }
                if (p.distanceTo(p2) === 0.0) {
                    continue;
                }
                intersectCount++;
                if (intersectCount === 2) {
                    break;
                }
            }
        }
        if (intersectCount === 2) {
            // find the intersect line if any
            _line0.delta(_dir0).normalize();
            _line1.delta(_dir1).normalize();
            // swap edges so they're facing in the same direction
            if (_dir0.dot(_dir1) < 0) {
                const tmp = _line1.start;
                _line1.start = _line1.end;
                _line1.end = tmp;
            }
            // check if the edges are overlapping
            const s1 = _line0.start.dot(_dir0);
            const e1 = _line0.end.dot(_dir0);
            const s2 = _line1.start.dot(_dir0);
            const e2 = _line1.end.dot(_dir0);
            const separated1 = e1 < s2;
            const separated2 = s1 < e2;
            if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
                return null;
            }
            // assign the target output
            _tempDir.subVectors(_line0.start, _line1.start);
            if (_tempDir.dot(_dir0) > 0) {
                lineTarget.start.copy(_line0.start);
            }
            else {
                lineTarget.start.copy(_line1.start);
            }
            _tempDir.subVectors(_line0.end, _line1.end);
            if (_tempDir.dot(_dir0) < 0) {
                lineTarget.end.copy(_line0.end);
            }
            else {
                lineTarget.end.copy(_line1.end);
            }
            return lineTarget;
        }
        return null;
    };
})();
// returns the the y value on the plane at the given point x, z
const getPlaneYAtPoint = (function () {
    const testLine = new Line3();
    return function getPlaneYAtPoint(plane, point, target = null) {
        testLine.start.copy(point);
        testLine.end.copy(point);
        testLine.start.y += 1e5;
        testLine.end.y -= 1e5;
        plane.intersectLine(testLine, target);
    };
})();
// returns whether the given line is above the given triangle plane
((function () {
    const _v0 = new Vector3();
    const _v1 = new Vector3();
    return function isLineAbovePlane(plane, line) {
        _v0.lerpVectors(line.start, line.end, 0.5);
        getPlaneYAtPoint(plane, _v0, _v1);
        return _v1.y < _v0.y;
    };
}))();
((function () {
    const _tempDir = new Vector3();
    const _upVector = new Vector3(0, 1, 0);
    return function isYProjectedLineDegenerate(line) {
        line.delta(_tempDir).normalize();
        return Math.abs(_tempDir.dot(_upVector)) >= 1.0 - EPSILON;
    };
}))();
// checks whether the y-projected triangle will be degerate
function isYProjectedTriangleDegenerate(tri) {
    if (tri.needsUpdate) {
        tri.update();
    }
    return Math.abs(tri.plane.normal.dot(_upVector)) <= EPSILON;
}
// Extracts the normalized [0, 1] distances along the given line that overlaps with the provided triangle when
// projected along the y axis
((function () {
    const _target = new Line3();
    const _tempDir = new Vector3();
    const _tempVec0 = new Vector3();
    const _tempVec1 = new Vector3();
    const _line = new Line3();
    const _tri = new ExtendedTriangle();
    return function getProjectedOverlaps(tri, line, overlapsTarget) {
        _line.copy(line);
        _tri.copy(tri);
        // flatten them to a common plane
        _line.start.y = 0;
        _line.end.y = 0;
        _tri.a.y = 0;
        _tri.b.y = 0;
        _tri.c.y = 0;
        _tri.needsUpdate = true;
        _tri.update();
        // if the line is meaningfully long and the we have an overlapping line then extract the
        // distances along the original line to return
        if (getOverlappingLine(_line, _tri, _target)) {
            _line.delta(_tempDir);
            _tempVec0.subVectors(_target.start, _line.start);
            _tempVec1.subVectors(_target.end, _line.start);
            let d0 = _tempVec0.length() / _tempDir.length();
            let d1 = _tempVec1.length() / _tempDir.length();
            d0 = Math.min(Math.max(d0, 0), 1);
            d1 = Math.min(Math.max(d1, 0), 1);
            if (!(Math.abs(d0 - d1) <= EPSILON)) {
                overlapsTarget.push(new Float32Array([d0, d1]));
            }
            return true;
        }
        return false;
    };
}))();
// Trim the provided line to just the section below the given triangle plane
((function () {
    const _lineDirection = new Vector3();
    const _planeHit = new Vector3();
    const _centerPoint = new Vector3();
    const _planePoint = new Vector3();
    return function trimToBeneathTriPlane(tri, line, lineTarget) {
        if (tri.needsUpdate) {
            tri.update();
        }
        lineTarget.copy(line);
        // handle vertical triangles
        const { plane } = tri;
        if (isYProjectedTriangleDegenerate(tri)) {
            return false;
        }
        // if the line and plane are coplanar then return that we can't trim
        line.delta(_lineDirection);
        const areCoplanar = plane.normal.dot(_lineDirection) === 0.0;
        if (areCoplanar) {
            return false;
        }
        // if the line does intersect the plane then trim
        const doesLineIntersect = plane.intersectLine(line, _planeHit);
        if (doesLineIntersect) {
            const { start, end } = lineTarget;
            // test the line side with the largest segment extending beyond the plane
            let testPoint;
            let flipped = false;
            if (start.distanceTo(_planeHit) > end.distanceTo(_planeHit)) {
                testPoint = start;
            }
            else {
                testPoint = end;
                flipped = true;
            }
            // get the center point of the line segment and the plane hit
            _centerPoint.lerpVectors(testPoint, _planeHit, 0.5);
            getPlaneYAtPoint(tri.plane, _centerPoint, _planePoint);
            // adjust the appropriate line point align with the plane hit point
            if (_planePoint.y < _centerPoint.y) {
                if (flipped)
                    end.copy(_planeHit);
                else
                    start.copy(_planeHit);
            }
            else if (flipped)
                start.copy(_planeHit);
            else
                end.copy(_planeHit);
            return true;
        }
        return false;
    };
}))();
// Converts the given array of overlaps into line segments
((function () {
    const newLine = new Line3();
    return function overlapsToLines(line, overlaps, target = []) {
        compressEdgeOverlaps(overlaps);
        const invOverlaps = [[0, 1]];
        for (let i = 0, l = overlaps.length; i < l; i++) {
            const invOverlap = invOverlaps[i];
            const overlap = overlaps[i];
            invOverlap[1] = overlap[0];
            invOverlaps.push(new Float32Array([overlap[1], 1]));
        }
        for (let i = 0, l = invOverlaps.length; i < l; i++) {
            const { start, end } = line;
            newLine.start.lerpVectors(start, end, invOverlaps[i][0]);
            newLine.end.lerpVectors(start, end, invOverlaps[i][1]);
            target.push(
            // @ts-ignore
            new Float32Array([
                newLine.start.x,
                newLine.start.y,
                newLine.start.z,
                newLine.end.x,
                newLine.end.y,
                newLine.end.z
            ]));
        }
        return target;
    };
}))();
// compresses the given edge overlaps into a minimal set of representative objects
function compressEdgeOverlaps(overlaps) {
    overlaps.sort((a, b) => {
        return a[0] - b[0];
    });
    for (let i = 1; i < overlaps.length; i++) {
        const overlap = overlaps[i];
        const prevOverlap = overlaps[i - 1];
        if (overlap[0] <= prevOverlap[1]) {
            prevOverlap[1] = Math.max(prevOverlap[1], overlap[1]);
            overlaps.splice(i, 1);
            i--;
        }
    }
}

var SelectionWindowMode;
(function (SelectionWindowMode) {
    SelectionWindowMode[SelectionWindowMode["lasso"] = 0] = "lasso";
    SelectionWindowMode[SelectionWindowMode["box"] = 1] = "box";
})(SelectionWindowMode || (SelectionWindowMode = {}));

//UI functions

  svgPaths = ["M21.172 24l-7.387-7.387c-1.388.874-3.024 1.387-4.785 1.387-4.971 0-9-4.029-9-9s4.029-9 9-9 9 4.029 9 9c0 1.761-.514 3.398-1.387 4.785l7.387 7.387-2.828 2.828zm-12.172-8c3.859 0 7-3.14 7-7s-3.141-7-7-7-7 3.14-7 7 3.141 7 7 7zm-3-8c.552 0 1 .448 1 1s-.448 1-1 1-1-.448-1-1 .448-1 1-1zm3 0c.552 0 1 .448 1 1s-.448 1-1 1-1-.448-1-1 .448-1 1-1zm3 0c.552 0 1 .448 1 1s-.448 1-1 1-1-.448-1-1 .448-1 1-1z",
"M18 10.031v-6.423l-6.036-3.608-5.964 3.569v6.499l-6 3.224v7.216l6.136 3.492 5.864-3.393 5.864 3.393 6.136-3.492v-7.177l-6-3.3zm-1.143.036l-4.321 2.384v-4.956l4.321-2.539v5.111zm-4.895-8.71l4.272 2.596-4.268 2.509-4.176-2.554 4.172-2.551zm-10.172 12.274l4.778-2.53 4.237 2.417-4.668 2.667-4.347-2.554zm4.917 3.587l4.722-2.697v5.056l-4.722 2.757v-5.116zm6.512-3.746l4.247-2.39 4.769 2.594-4.367 2.509-4.649-2.713zm9.638 6.323l-4.421 2.539v-5.116l4.421-2.538v5.115z",
"M14.686 13.646l-6.597 3.181c-1.438.692-2.755-1.124-2.755-1.124l6.813-3.287 2.539 1.23zm6.168 5.354c-.533 0-1.083-.119-1.605-.373-1.511-.731-2.296-2.333-1.943-3.774.203-.822-.23-.934-.891-1.253l-11.036-5.341s1.322-1.812 2.759-1.117c.881.427 4.423 2.136 7.477 3.617l.766-.368c.662-.319 1.094-.43.895-1.252-.351-1.442.439-3.043 1.952-3.77.521-.251 1.068-.369 1.596-.369 1.799 0 3.147 1.32 3.147 2.956 0 1.23-.766 2.454-2.032 3.091-1.266.634-2.15.14-3.406.75l-.394.19.431.21c1.254.614 2.142.122 3.404.759 1.262.638 2.026 1.861 2.026 3.088 0 1.64-1.352 2.956-3.146 2.956zm-1.987-9.967c.381.795 1.459 1.072 2.406.617.945-.455 1.405-1.472 1.027-2.267-.381-.796-1.46-1.073-2.406-.618-.946.455-1.408 1.472-1.027 2.268zm-2.834 2.819c0-.322-.261-.583-.583-.583-.321 0-.583.261-.583.583s.262.583.583.583c.322.001.583-.261.583-.583zm5.272 2.499c-.945-.457-2.025-.183-2.408.611-.381.795.078 1.814 1.022 2.271.945.458 2.024.184 2.406-.611.382-.795-.075-1.814-1.02-2.271zm-18.305-3.351h-3v2h3v-2zm4 0h-3v2h3v-2z",
"M4 22h-4v-4h4v4zm0-12h-4v4h4v-4zm0-8h-4v4h4v-4zm3 0v4h17v-4h-17zm0 12h17v-4h-17v4zm0 8h17v-4h-17v4z",
"M1.438 16.873l-1.438 7.127 7.127-1.437 16.874-16.872-5.69-5.69-16.873 16.872zm1.12 4.572l.722-3.584 2.86 2.861-3.582.723zm18.613-15.755l-13.617 13.617-2.86-2.861 13.617-13.617 2.86 2.861z"];
  

function createCardDiv(projectName, projectId) {
    const card = document.createElement('div');
    card.className = "card";

    const svgElement = document.createElementNS('http://www.w3.org/2000/svg','svg');
    svgElement.setAttribute('width', '24');
    svgElement.setAttribute('height','24');
    svgElement.setAttribute('viewBox','0 0 24 24');
    
    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path1.setAttribute('d', 'M18 10.031v-6.423l-6.036-3.608-5.964 3.569v6.499l-6 3.224v7.216l6.136 3.492 5.864-3.393 5.864 3.393 6.136-3.492v-7.177l-6-3.3zm-1.143.036l-4.321 2.384v-4.956l4.321-2.539v5.111zm-4.895-8.71l4.272 2.596-4.268 2.509-4.176-2.554 4.172-2.551zm-10.172 12.274l4.778-2.53 4.237 2.417-4.668 2.667-4.347-2.554zm4.917 3.587l4.722-2.697v5.056l-4.722 2.757v-5.116zm6.512-3.746l4.247-2.39 4.769 2.594-4.367 2.509-4.649-2.713zm9.638 6.323l-4.421 2.539v-5.116l4.421-2.538v5.115z' );

    svgElement.appendChild(path1);
    card.appendChild(svgElement);

    const h2Element = document.createElement('h2');
    h2Element.textContent = projectName;
    
    card.appendChild(h2Element);

    const button = document.createElement('a');
    button.className = 'button';
    button.href = './bimviewer.html' + `?id=${projectId}`;
    //button.href= projectId; //also needs to be an input
    button.textContent = "Model";

    card.appendChild(button);

    const projectContainer = document.getElementById("projects-container");
    projectContainer.appendChild(card);

}


// https://www.tutorialspoint.com/building-a-map-from-2-arrays-of-values-and-keys-in-javascript
function buildMap (keys, values) {
    const map = new Map();
    for(let i = 0; i < keys.length; i++){
       map.set(keys[i], values[i]);
    }    return map;
 }

//get list of projects from bimserver, create a card for each project

//local
//const socket = io("http://localhost:8088/");
const socket = io("http://192.168.236.229:8088/");

//aws
//const socket = io("http://13.40.172.106:8088/");


// socket.on("hello", (arg) => {
//     console.log(arg);
// })

socket.emit("getProjects", "getProjects"); //get projects from a bimserver

// console.log("hello model list")

socket.on("projectIds",(resname, reslist) => {

    let projectsMap = buildMap(resname, reslist);

    projectsMap.forEach(function (value, key) {
        createCardDiv(key, value);
    });

    console.log(resname + reslist); 
    //console.log("projectIds")

}
);
